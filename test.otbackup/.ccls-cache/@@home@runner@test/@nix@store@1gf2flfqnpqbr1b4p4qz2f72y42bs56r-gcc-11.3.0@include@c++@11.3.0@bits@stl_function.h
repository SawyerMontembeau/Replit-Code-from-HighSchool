[{"ops":[{"insert":"// Functor implementations -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996-1998\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/** @file bits/stl_function.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{functional}\n */\n\n#ifndef _STL_FUNCTION_H\n#define _STL_FUNCTION_H 1\n\n#if __cplusplus > 201103L\n#include <bits/move.h>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // 20.3.1 base classes\n  /** @defgroup functors Function Objects\n   *  @ingroup utilities\n   *\n   *  Function objects, or _functors_, are objects with an `operator()`\n   *  defined and accessible.  They can be passed as arguments to algorithm\n   *  templates and used in place of a function pointer.  Not only is the\n   *  resulting expressiveness of the library increased, but the generated\n   *  code can be more efficient than what you might write by hand.  When we\n   *  refer to _functors_, then, generally we include function pointers in\n   *  the description as well.\n   *\n   *  Often, functors are only created as temporaries passed to algorithm\n   *  calls, rather than being created as named variables.\n   *\n   *  Two examples taken from the standard itself follow.  To perform a\n   *  by-element addition of two vectors `a` and `b` containing `double`,\n   *  and put the result in `a`, use\n   *  \\code\n   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());\n   *  \\endcode\n   *  To negate every element in `a`, use\n   *  \\code\n   *  transform(a.begin(), a.end(), a.begin(), negate<double>());\n   *  \\endcode\n   *  The addition and negation functions will usually be inlined directly.\n   *\n   *  An _adaptable function object_ is one which provides nested typedefs\n   *  `result_type` and either `argument_type` (for a unary function) or\n   *  `first_argument_type` and `second_argument_type` (for a binary function).\n   *  Those typedefs are used by function object adaptors such as `bind2nd`.\n   *  The standard library provides two class templates, `unary_function` and\n   *  `binary_function`, which define those typedefs and so can be used as\n   *  base classes of adaptable function objects.\n   *\n   *  Since C++11 the use of function object adaptors has been superseded by\n   *  more powerful tools such as lambda expressions, `function<>`, and more\n   *  powerful type deduction (using `auto` and `decltype`). The helpers for\n   *  defining adaptable function objects are deprecated since C++11, and no\n   *  longer part of the standard library since C++17. However, they are still\n   *  defined and used by libstdc++ after C++17, as a conforming extension.\n   *\n   *  @{\n   */\n\n  /**\n   *  Helper for defining adaptable unary function objects.\n   *  @deprecated Deprecated in C++11, no longer in the standard since C++17.\n   */\n  template<typename _Arg, typename _Result>\n    struct unary_function\n    {\n      /// @c argument_type is the type of the argument\n      typedef _Arg \targument_type;   \n\n      /// @c result_type is the return type\n      typedef _Result \tresult_type;  \n    };\n\n  /**\n   *  Helper for defining adaptable binary function objects.\n   *  @deprecated Deprecated in C++11, no longer in the standard since C++17.\n   */\n  template<typename _Arg1, typename _Arg2, typename _Result>\n    struct binary_function\n    {\n      /// @c first_argument_type is the type of the first argument\n      typedef _Arg1 \tfirst_argument_type; \n\n      /// @c second_argument_type is the type of the second argument\n      typedef _Arg2 \tsecond_argument_type;\n\n      /// @c result_type is the return type\n      typedef _Result \tresult_type;\n    };\n  /** @}  */\n\n  // 20.3.2 arithmetic\n\n  /** @defgroup arithmetic_functors Arithmetic Function Object Classes\n   *  @ingroup functors\n   *\n   *  The library provides function objects for basic arithmetic operations.\n   *  See the documentation for @link functors function objects @endlink\n   *  for examples of their use.\n   *\n   *  @{\n   */\n\n#if __cplusplus > 201103L\n  struct __is_transparent;  // undefined\n\n  template<typename _Tp = void>\n    struct plus;\n\n  template<typename _Tp = void>\n    struct minus;\n\n  template<typename _Tp = void>\n    struct multiplies;\n\n  template<typename _Tp = void>\n    struct divides;\n\n  template<typename _Tp = void>\n    struct modulus;\n\n  template<typename _Tp = void>\n    struct negate;\n#endif\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<typename _Tp>\n    struct plus : public binary_function<_Tp, _Tp, _Tp>\n    {\n      /// Returns the sum\n      _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x + __y; }\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<typename _Tp>\n    struct minus : public binary_function<_Tp, _Tp, _Tp>\n    {\n      _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x - __y; }\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<typename _Tp>\n    struct multiplies : public binary_function<_Tp, _Tp, _Tp>\n    {\n      _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x * __y; }\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<typename _Tp>\n    struct divides : public binary_function<_Tp, _Tp, _Tp>\n    {\n      _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x / __y; }\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<typename _Tp>\n    struct modulus : public binary_function<_Tp, _Tp, _Tp>\n    {\n      _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x % __y; }\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<typename _Tp>\n    struct negate : public unary_function<_Tp, _Tp>\n    {\n      _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x) const\n      { return -__x; }\n    };\n\n#if __cplusplus > 201103L\n\n#define __cpp_lib_transparent_operators 201510\n\n  template<>\n    struct plus<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<>\n    struct minus<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<>\n    struct multiplies<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<>\n    struct divides<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<>\n    struct modulus<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  /// One of the @link arithmetic_functors math functors@endlink.\n  template<>\n    struct negate<void>\n    {\n      template <typename _Tp>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t) const\n\tnoexcept(noexcept(-std::forward<_Tp>(__t)))\n\t-> decltype(-std::forward<_Tp>(__t))\n\t{ return -std::forward<_Tp>(__t); }\n\n      typedef __is_transparent is_transparent;\n    };\n#endif\n  /** @}  */\n\n  // 20.3.3 comparisons\n  /** @defgroup comparison_functors Comparison Classes\n   *  @ingroup functors\n   *\n   *  The library provides six wrapper functors for all the basic comparisons\n   *  in C++, like @c <.\n   *\n   *  @{\n   */\n#if __cplusplus > 201103L\n  template<typename _Tp = void>\n    struct equal_to;\n\n  template<typename _Tp = void>\n    struct not_equal_to;\n\n  template<typename _Tp = void>\n    struct greater;\n\n  template<typename _Tp = void>\n    struct less;\n\n  template<typename _Tp = void>\n    struct greater_equal;\n\n  template<typename _Tp = void>\n    struct less_equal;\n#endif\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<typename _Tp>\n    struct equal_to : public binary_function<_Tp, _Tp, bool>\n    {\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x == __y; }\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<typename _Tp>\n    struct not_equal_to : public binary_function<_Tp, _Tp, bool>\n    {\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x != __y; }\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<typename _Tp>\n    struct greater : public binary_function<_Tp, _Tp, bool>\n    {\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x > __y; }\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<typename _Tp>\n    struct less : public binary_function<_Tp, _Tp, bool>\n    {\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x < __y; }\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<typename _Tp>\n    struct greater_equal : public binary_function<_Tp, _Tp, bool>\n    {\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x >= __y; }\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<typename _Tp>\n    struct less_equal : public binary_function<_Tp, _Tp, bool>\n    {\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x <= __y; }\n    };\n\n  // Partial specialization of std::greater for pointers.\n  template<typename _Tp>\n    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>\n    {\n      _GLIBCXX14_CONSTEXPR bool\n      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW\n      {\n#if __cplusplus >= 201402L\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED\n\tif (__builtin_is_constant_evaluated())\n#else\n\tif (__builtin_constant_p(__x > __y))\n#endif\n\t  return __x > __y;\n#endif\n\treturn (__UINTPTR_TYPE__)__x > (__UINTPTR_TYPE__)__y;\n      }\n    };\n\n  // Partial specialization of std::less for pointers.\n  template<typename _Tp>\n    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>\n    {\n      _GLIBCXX14_CONSTEXPR bool\n      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW\n      {\n#if __cplusplus >= 201402L\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED\n\tif (__builtin_is_constant_evaluated())\n#else\n\tif (__builtin_constant_p(__x < __y))\n#endif\n\t  return __x < __y;\n#endif\n\treturn (__UINTPTR_TYPE__)__x < (__UINTPTR_TYPE__)__y;\n      }\n    };\n\n  // Partial specialization of std::greater_equal for pointers.\n  template<typename _Tp>\n    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>\n    {\n      _GLIBCXX14_CONSTEXPR bool\n      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW\n      {\n#if __cplusplus >= 201402L\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED\n\tif (__builtin_is_constant_evaluated())\n#else\n\tif (__builtin_constant_p(__x >= __y))\n#endif\n\t  return __x >= __y;\n#endif\n\treturn (__UINTPTR_TYPE__)__x >= (__UINTPTR_TYPE__)__y;\n      }\n    };\n\n  // Partial specialization of std::less_equal for pointers.\n  template<typename _Tp>\n    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>\n    {\n      _GLIBCXX14_CONSTEXPR bool\n      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW\n      {\n#if __cplusplus >= 201402L\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED\n\tif (__builtin_is_constant_evaluated())\n#else\n\tif (__builtin_constant_p(__x <= __y))\n#endif\n\t  return __x <= __y;\n#endif\n\treturn (__UINTPTR_TYPE__)__x <= (__UINTPTR_TYPE__)__y;\n      }\n    };\n\n#if __cplusplus >= 201402L\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<>\n    struct equal_to<void>\n    {\n      template <typename _Tp, typename _Up>\n\tconstexpr auto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<>\n    struct not_equal_to<void>\n    {\n      template <typename _Tp, typename _Up>\n\tconstexpr auto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<>\n    struct greater<void>\n    {\n      template <typename _Tp, typename _Up>\n\tconstexpr auto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))\n\t{\n\t  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),\n\t\t\t__ptr_cmp<_Tp, _Up>{});\n\t}\n\n      template<typename _Tp, typename _Up>\n\tconstexpr bool\n\toperator()(_Tp* __t, _Up* __u) const noexcept\n\t{ return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }\n\n      typedef __is_transparent is_transparent;\n\n    private:\n      template <typename _Tp, typename _Up>\n\tstatic constexpr decltype(auto)\n\t_S_cmp(_Tp&& __t, _Up&& __u, false_type)\n\t{ return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }\n\n      template <typename _Tp, typename _Up>\n\tstatic constexpr bool\n\t_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept\n\t{\n\t  return greater<const volatile void*>{}(\n\t      static_cast<const volatile void*>(std::forward<_Tp>(__t)),\n\t      static_cast<const volatile void*>(std::forward<_Up>(__u)));\n\t}\n\n      // True if there is no viable operator> member function.\n      template<typename _Tp, typename _Up, typename = void>\n\tstruct __not_overloaded2 : true_type { };\n\n      // False if we can call T.operator>(U)\n      template<typename _Tp, typename _Up>\n\tstruct __not_overloaded2<_Tp, _Up, __void_t<\n\t  decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>\n\t: false_type { };\n\n      // True if there is no overloaded operator> for these operands.\n      template<typename _Tp, typename _Up, typename = void>\n\tstruct __not_overloaded : __not_overloaded2<_Tp, _Up> { };\n\n      // False if we can call operator>(T,U)\n      template<typename _Tp, typename _Up>\n\tstruct __not_overloaded<_Tp, _Up, __void_t<\n\t  decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>\n\t: false_type { };\n\n      template<typename _Tp, typename _Up>\n\tusing __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,\n\t      is_convertible<_Tp, const volatile void*>,\n\t      is_convertible<_Up, const volatile void*>>;\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<>\n    struct less<void>\n    {\n      template <typename _Tp, typename _Up>\n\tconstexpr auto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))\n\t{\n\t  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),\n\t\t\t__ptr_cmp<_Tp, _Up>{});\n\t}\n\n      template<typename _Tp, typename _Up>\n\tconstexpr bool\n\toperator()(_Tp* __t, _Up* __u) const noexcept\n\t{ return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }\n\n      typedef __is_transparent is_transparent;\n\n    private:\n      template <typename _Tp, typename _Up>\n\tstatic constexpr decltype(auto)\n\t_S_cmp(_Tp&& __t, _Up&& __u, false_type)\n\t{ return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }\n\n      template <typename _Tp, typename _Up>\n\tstatic constexpr bool\n\t_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept\n\t{\n\t  return less<const volatile void*>{}(\n\t      static_cast<const volatile void*>(std::forward<_Tp>(__t)),\n\t      static_cast<const volatile void*>(std::forward<_Up>(__u)));\n\t}\n\n      // True if there is no viable operator< member function.\n      template<typename _Tp, typename _Up, typename = void>\n\tstruct __not_overloaded2 : true_type { };\n\n      // False if we can call T.operator<(U)\n      template<typename _Tp, typename _Up>\n\tstruct __not_overloaded2<_Tp, _Up, __void_t<\n\t  decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>\n\t: false_type { };\n\n      // True if there is no overloaded operator< for these operands.\n      template<typename _Tp, typename _Up, typename = void>\n\tstruct __not_overloaded : __not_overloaded2<_Tp, _Up> { };\n\n      // False if we can call operator<(T,U)\n      template<typename _Tp, typename _Up>\n\tstruct __not_overloaded<_Tp, _Up, __void_t<\n\t  decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>\n\t: false_type { };\n\n      template<typename _Tp, typename _Up>\n\tusing __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,\n\t      is_convertible<_Tp, const volatile void*>,\n\t      is_convertible<_Up, const volatile void*>>;\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<>\n    struct greater_equal<void>\n    {\n      template <typename _Tp, typename _Up>\n\tconstexpr auto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))\n\t{\n\t  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),\n\t\t\t__ptr_cmp<_Tp, _Up>{});\n\t}\n\n      template<typename _Tp, typename _Up>\n\tconstexpr bool\n\toperator()(_Tp* __t, _Up* __u) const noexcept\n\t{ return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }\n\n      typedef __is_transparent is_transparent;\n\n    private:\n      template <typename _Tp, typename _Up>\n\tstatic constexpr decltype(auto)\n\t_S_cmp(_Tp&& __t, _Up&& __u, false_type)\n\t{ return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }\n\n      template <typename _Tp, typename _Up>\n\tstatic constexpr bool\n\t_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept\n\t{\n\t  return greater_equal<const volatile void*>{}(\n\t      static_cast<const volatile void*>(std::forward<_Tp>(__t)),\n\t      static_cast<const volatile void*>(std::forward<_Up>(__u)));\n\t}\n\n      // True if there is no viable operator>= member function.\n      template<typename _Tp, typename _Up, typename = void>\n\tstruct __not_overloaded2 : true_type { };\n\n      // False if we can call T.operator>=(U)\n      template<typename _Tp, typename _Up>\n\tstruct __not_overloaded2<_Tp, _Up, __void_t<\n\t  decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>\n\t: false_type { };\n\n      // True if there is no overloaded operator>= for these operands.\n      template<typename _Tp, typename _Up, typename = void>\n\tstruct __not_overloaded : __not_overloaded2<_Tp, _Up> { };\n\n      // False if we can call operator>=(T,U)\n      template<typename _Tp, typename _Up>\n\tstruct __not_overloaded<_Tp, _Up, __void_t<\n\t  decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>\n\t: false_type { };\n\n      template<typename _Tp, typename _Up>\n\tusing __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,\n\t      is_convertible<_Tp, const volatile void*>,\n\t      is_convertible<_Up, const volatile void*>>;\n    };\n\n  /// One of the @link comparison_functors comparison functors@endlink.\n  template<>\n    struct less_equal<void>\n    {\n      template <typename _Tp, typename _Up>\n\tconstexpr auto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))\n\t{\n\t  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),\n\t\t\t__ptr_cmp<_Tp, _Up>{});\n\t}\n\n      template<typename _Tp, typename _Up>\n\tconstexpr bool\n\toperator()(_Tp* __t, _Up* __u) const noexcept\n\t{ return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }\n\n      typedef __is_transparent is_transparent;\n\n    private:\n      template <typename _Tp, typename _Up>\n\tstatic constexpr decltype(auto)\n\t_S_cmp(_Tp&& __t, _Up&& __u, false_type)\n\t{ return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }\n\n      template <typename _Tp, typename _Up>\n\tstatic constexpr bool\n\t_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept\n\t{\n\t  return less_equal<const volatile void*>{}(\n\t      static_cast<const volatile void*>(std::forward<_Tp>(__t)),\n\t      static_cast<const volatile void*>(std::forward<_Up>(__u)));\n\t}\n\n      // True if there is no viable operator<= member function.\n      template<typename _Tp, typename _Up, typename = void>\n\tstruct __not_overloaded2 : true_type { };\n\n      // False if we can call T.operator<=(U)\n      template<typename _Tp, typename _Up>\n\tstruct __not_overloaded2<_Tp, _Up, __void_t<\n\t  decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>\n\t: false_type { };\n\n      // True if there is no overloaded operator<= for these operands.\n      template<typename _Tp, typename _Up, typename = void>\n\tstruct __not_overloaded : __not_overloaded2<_Tp, _Up> { };\n\n      // False if we can call operator<=(T,U)\n      template<typename _Tp, typename _Up>\n\tstruct __not_overloaded<_Tp, _Up, __void_t<\n\t  decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>\n\t: false_type { };\n\n      template<typename _Tp, typename _Up>\n\tusing __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,\n\t      is_convertible<_Tp, const volatile void*>,\n\t      is_convertible<_Up, const volatile void*>>;\n    };\n#endif // C++14\n  /** @}  */\n\n  // 20.3.4 logical operations\n  /** @defgroup logical_functors Boolean Operations Classes\n   *  @ingroup functors\n   *\n   *  The library provides function objects for the logical operations:\n   *  `&&`, `||`, and `!`.\n   *\n   *  @{\n   */\n#if __cplusplus > 201103L\n  template<typename _Tp = void>\n    struct logical_and;\n\n  template<typename _Tp = void>\n    struct logical_or;\n\n  template<typename _Tp = void>\n    struct logical_not;\n#endif\n\n  /// One of the @link logical_functors Boolean operations functors@endlink.\n  template<typename _Tp>\n    struct logical_and : public binary_function<_Tp, _Tp, bool>\n    {\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x && __y; }\n    };\n\n  /// One of the @link logical_functors Boolean operations functors@endlink.\n  template<typename _Tp>\n    struct logical_or : public binary_function<_Tp, _Tp, bool>\n    {\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x || __y; }\n    };\n\n  /// One of the @link logical_functors Boolean operations functors@endlink.\n  template<typename _Tp>\n    struct logical_not : public unary_function<_Tp, bool>\n    {\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const _Tp& __x) const\n      { return !__x; }\n    };\n\n#if __cplusplus > 201103L\n  /// One of the @link logical_functors Boolean operations functors@endlink.\n  template<>\n    struct logical_and<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  /// One of the @link logical_functors Boolean operations functors@endlink.\n  template<>\n    struct logical_or<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  /// One of the @link logical_functors Boolean operations functors@endlink.\n  template<>\n    struct logical_not<void>\n    {\n      template <typename _Tp>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t) const\n\tnoexcept(noexcept(!std::forward<_Tp>(__t)))\n\t-> decltype(!std::forward<_Tp>(__t))\n\t{ return !std::forward<_Tp>(__t); }\n\n      typedef __is_transparent is_transparent;\n    };\n#endif\n  /** @}  */\n\n#if __cplusplus > 201103L\n  template<typename _Tp = void>\n    struct bit_and;\n\n  template<typename _Tp = void>\n    struct bit_or;\n\n  template<typename _Tp = void>\n    struct bit_xor;\n\n  template<typename _Tp = void>\n    struct bit_not;\n#endif\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // DR 660. Missing Bitwise Operations.\n  template<typename _Tp>\n    struct bit_and : public binary_function<_Tp, _Tp, _Tp>\n    {\n      _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x & __y; }\n    };\n\n  template<typename _Tp>\n    struct bit_or : public binary_function<_Tp, _Tp, _Tp>\n    {\n      _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x | __y; }\n    };\n\n  template<typename _Tp>\n    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>\n    {\n      _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x, const _Tp& __y) const\n      { return __x ^ __y; }\n    };\n\n  template<typename _Tp>\n    struct bit_not : public unary_function<_Tp, _Tp>\n    {\n    _GLIBCXX14_CONSTEXPR\n      _Tp\n      operator()(const _Tp& __x) const\n      { return ~__x; }\n    };\n\n#if __cplusplus > 201103L\n  template <>\n    struct bit_and<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  template <>\n    struct bit_or<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  template <>\n    struct bit_xor<void>\n    {\n      template <typename _Tp, typename _Up>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t, _Up&& __u) const\n\tnoexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))\n\t-> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))\n\t{ return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n\n  template <>\n    struct bit_not<void>\n    {\n      template <typename _Tp>\n\t_GLIBCXX14_CONSTEXPR\n\tauto\n\toperator()(_Tp&& __t) const\n\tnoexcept(noexcept(~std::forward<_Tp>(__t)))\n\t-> decltype(~std::forward<_Tp>(__t))\n\t{ return ~std::forward<_Tp>(__t); }\n\n      typedef __is_transparent is_transparent;\n    };\n#endif\n\n  // 20.3.5 negators\n  /** @defgroup negators Negators\n   *  @ingroup functors\n   *\n   *  The function templates `not1` and `not2` are function object adaptors,\n   *  which each take a predicate functor and wrap it in an instance of\n   *  `unary_negate` or `binary_negate`, respectively.  Those classes are\n   *  functors whose `operator()` evaluates the wrapped predicate function\n   *  and then returns the negation of the result.\n   *\n   *  For example, given a vector of integers and a trivial predicate,\n   *  \\code\n   *  struct IntGreaterThanThree\n   *    : public std::unary_function<int, bool>\n   *  {\n   *      bool operator() (int x) const { return x > 3; }\n   *  };\n   *\n   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));\n   *  \\endcode\n   *  The call to `find_if` will locate the first index (i) of `v` for which\n   *  `!(v[i] > 3)` is true.\n   *\n   *  The not1/unary_negate combination works on predicates taking a single\n   *  argument.  The not2/binary_negate combination works on predicates taking\n   *  two arguments.\n   *\n   *  @deprecated Deprecated in C++17, no longer in the standard since C++20.\n   *  Use `not_fn` instead.\n   *\n   *  @{\n   */\n  /// One of the @link negators negation functors@endlink.\n  template<typename _Predicate>\n    class unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n    {\n    protected:\n      _Predicate _M_pred;\n\n    public:\n      _GLIBCXX14_CONSTEXPR\n      explicit\n      unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const typename _Predicate::argument_type& __x) const\n      { return !_M_pred(__x); }\n    };\n\n  /// One of the @link negators negation functors@endlink.\n  template<typename _Predicate>\n    _GLIBCXX14_CONSTEXPR\n    inline unary_negate<_Predicate>\n    not1(const _Predicate& __pred)\n    { return unary_negate<_Predicate>(__pred); }\n\n  /// One of the @link negators negation functors@endlink.\n  template<typename _Predicate>\n    class binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n\t\t\t     typename _Predicate::second_argument_type, bool>\n    {\n    protected:\n      _Predicate _M_pred;\n\n    public:\n      _GLIBCXX14_CONSTEXPR\n      explicit\n      binary_negate(const _Predicate& __x) : _M_pred(__x) { }\n\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(const typename _Predicate::first_argument_type& __x,\n\t\t const typename _Predicate::second_argument_type& __y) const\n      { return !_M_pred(__x, __y); }\n    };\n\n  /// One of the @link negators negation functors@endlink.\n  template<typename _Predicate>\n    _GLIBCXX14_CONSTEXPR\n    inline binary_negate<_Predicate>\n    not2(const _Predicate& __pred)\n    { return binary_negate<_Predicate>(__pred); }\n  /** @}  */\n\n  // 20.3.7 adaptors pointers functions\n  /** @defgroup pointer_adaptors Adaptors for pointers to functions\n   *  @ingroup functors\n   *\n   *  The advantage of function objects over pointers to functions is that\n   *  the objects in the standard library declare nested typedefs describing\n   *  their argument and result types with uniform names (e.g., `result_type`\n   *  from the base classes `unary_function` and `binary_function`).\n   *  Sometimes those typedefs are required, not just optional.\n   *\n   *  Adaptors are provided to turn pointers to unary (single-argument) and\n   *  binary (double-argument) functions into function objects.  The\n   *  long-winded functor `pointer_to_unary_function` is constructed with a\n   *  function pointer `f`, and its `operator()` called with argument `x`\n   *  returns `f(x)`.  The functor `pointer_to_binary_function` does the same\n   *  thing, but with a double-argument `f` and `operator()`.\n   *\n   *  The function `ptr_fun` takes a pointer-to-function `f` and constructs\n   *  an instance of the appropriate functor.\n   *\n   *  @deprecated Deprecated in C++11, no longer in the standard since C++17.\n   *\n   *  @{\n   */\n  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.\n  template<typename _Arg, typename _Result>\n    class pointer_to_unary_function : public unary_function<_Arg, _Result>\n    {\n    protected:\n      _Result (*_M_ptr)(_Arg);\n\n    public:\n      pointer_to_unary_function() { }\n\n      explicit\n      pointer_to_unary_function(_Result (*__x)(_Arg))\n      : _M_ptr(__x) { }\n\n      _Result\n      operator()(_Arg __x) const\n      { return _M_ptr(__x); }\n    };\n\n  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.\n  template<typename _Arg, typename _Result>\n    inline pointer_to_unary_function<_Arg, _Result>\n    ptr_fun(_Result (*__x)(_Arg))\n    { return pointer_to_unary_function<_Arg, _Result>(__x); }\n\n  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.\n  template<typename _Arg1, typename _Arg2, typename _Result>\n    class pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n    {\n    protected:\n      _Result (*_M_ptr)(_Arg1, _Arg2);\n\n    public:\n      pointer_to_binary_function() { }\n\n      explicit\n      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))\n      : _M_ptr(__x) { }\n\n      _Result\n      operator()(_Arg1 __x, _Arg2 __y) const\n      { return _M_ptr(__x, __y); }\n    };\n\n  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.\n  template<typename _Arg1, typename _Arg2, typename _Result>\n    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>\n    ptr_fun(_Result (*__x)(_Arg1, _Arg2))\n    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }\n  /** @}  */\n\n  template<typename _Tp>\n    struct _Identity\n    : public unary_function<_Tp, _Tp>\n    {\n      _Tp&\n      operator()(_Tp& __x) const\n      { return __x; }\n\n      const _Tp&\n      operator()(const _Tp& __x) const\n      { return __x; }\n    };\n\n  // Partial specialization, avoids confusing errors in e.g. std::set<const T>.\n  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };\n\n  template<typename _Pair>\n    struct _Select1st\n    : public unary_function<_Pair, typename _Pair::first_type>\n    {\n      typename _Pair::first_type&\n      operator()(_Pair& __x) const\n      { return __x.first; }\n\n      const typename _Pair::first_type&\n      operator()(const _Pair& __x) const\n      { return __x.first; }\n\n#if __cplusplus >= 201103L\n      template<typename _Pair2>\n        typename _Pair2::first_type&\n        operator()(_Pair2& __x) const\n        { return __x.first; }\n\n      template<typename _Pair2>\n        const typename _Pair2::first_type&\n        operator()(const _Pair2& __x) const\n        { return __x.first; }\n#endif\n    };\n\n  template<typename _Pair>\n    struct _Select2nd\n    : public unary_function<_Pair, typename _Pair::second_type>\n    {\n      typename _Pair::second_type&\n      operator()(_Pair& __x) const\n      { return __x.second; }\n\n      const typename _Pair::second_type&\n      operator()(const _Pair& __x) const\n      { return __x.second; }\n    };\n\n  // 20.3.8 adaptors pointers members\n  /** @defgroup ptrmem_adaptors Adaptors for pointers to members\n   *  @ingroup functors\n   *\n   *  There are a total of 8 = 2^3 function objects in this family.\n   *   (1) Member functions taking no arguments vs member functions taking\n   *        one argument.\n   *   (2) Call through pointer vs call through reference.\n   *   (3) Const vs non-const member function.\n   *\n   *  All of this complexity is in the function objects themselves.  You can\n   *   ignore it by using the helper function `mem_fun` and `mem_fun_ref`,\n   *   which create whichever type of adaptor is appropriate.\n   *\n   *  @deprecated Deprecated in C++11, no longer in the standard since C++17.\n   *  Use `mem_fn` instead.\n   *\n   *  @{\n   */\n  /// One of the @link ptrmem_adaptors adaptors for member pointers@endlink.\n  template<typename _Ret, typename _Tp>\n    class mem_fun_t : public unary_function<_Tp*, _Ret>\n    {\n    public:\n      explicit\n      mem_fun_t(_Ret (_Tp::*__pf)())\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(_Tp* __p) const\n      { return (__p->*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)();\n    };\n\n  /// One of the @link ptrmem_adaptors adaptors for member pointers@endlink.\n  template<typename _Ret, typename _Tp>\n    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>\n    {\n    public:\n      explicit\n      const_mem_fun_t(_Ret (_Tp::*__pf)() const)\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(const _Tp* __p) const\n      { return (__p->*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)() const;\n    };\n\n  /// One of the @link ptrmem_adaptors adaptors for member pointers@endlink.\n  template<typename _Ret, typename _Tp>\n    class mem_fun_ref_t : public unary_function<_Tp, _Ret>\n    {\n    public:\n      explicit\n      mem_fun_ref_t(_Ret (_Tp::*__pf)())\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(_Tp& __r) const\n      { return (__r.*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)();\n  };\n\n  /// One of the @link ptrmem_adaptors adaptors for member pointers@endlink.\n  template<typename _Ret, typename _Tp>\n    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>\n    {\n    public:\n      explicit\n      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(const _Tp& __r) const\n      { return (__r.*_M_f)(); }\n\n    private:\n      _Ret (_Tp::*_M_f)() const;\n    };\n\n  /// One of the @link ptrmem_adaptors adaptors for member pointers@endlink.\n  template<typename _Ret, typename _Tp, typename _Arg>\n    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>\n    {\n    public:\n      explicit\n      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(_Tp* __p, _Arg __x) const\n      { return (__p->*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg);\n    };\n\n  /// One of the @link ptrmem_adaptors adaptors for member pointers@endlink.\n  template<typename _Ret, typename _Tp, typename _Arg>\n    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>\n    {\n    public:\n      explicit\n      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(const _Tp* __p, _Arg __x) const\n      { return (__p->*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg) const;\n    };\n\n  /// One of the @link ptrmem_adaptors adaptors for member pointers@endlink.\n  template<typename _Ret, typename _Tp, typename _Arg>\n    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>\n    {\n    public:\n      explicit\n      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(_Tp& __r, _Arg __x) const\n      { return (__r.*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg);\n    };\n\n  /// One of the @link ptrmem_adaptors adaptors for member pointers@endlink.\n  template<typename _Ret, typename _Tp, typename _Arg>\n    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>\n    {\n    public:\n      explicit\n      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)\n      : _M_f(__pf) { }\n\n      _Ret\n      operator()(const _Tp& __r, _Arg __x) const\n      { return (__r.*_M_f)(__x); }\n\n    private:\n      _Ret (_Tp::*_M_f)(_Arg) const;\n    };\n\n  // Mem_fun adaptor helper functions.  There are only two:\n  // mem_fun and mem_fun_ref.\n  template<typename _Ret, typename _Tp>\n    inline mem_fun_t<_Ret, _Tp>\n    mem_fun(_Ret (_Tp::*__f)())\n    { return mem_fun_t<_Ret, _Tp>(__f); }\n\n  template<typename _Ret, typename _Tp>\n    inline const_mem_fun_t<_Ret, _Tp>\n    mem_fun(_Ret (_Tp::*__f)() const)\n    { return const_mem_fun_t<_Ret, _Tp>(__f); }\n\n  template<typename _Ret, typename _Tp>\n    inline mem_fun_ref_t<_Ret, _Tp>\n    mem_fun_ref(_Ret (_Tp::*__f)())\n    { return mem_fun_ref_t<_Ret, _Tp>(__f); }\n\n  template<typename _Ret, typename _Tp>\n    inline const_mem_fun_ref_t<_Ret, _Tp>\n    mem_fun_ref(_Ret (_Tp::*__f)() const)\n    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    inline mem_fun1_t<_Ret, _Tp, _Arg>\n    mem_fun(_Ret (_Tp::*__f)(_Arg))\n    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    inline const_mem_fun1_t<_Ret, _Tp, _Arg>\n    mem_fun(_Ret (_Tp::*__f)(_Arg) const)\n    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>\n    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))\n    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }\n\n  template<typename _Ret, typename _Tp, typename _Arg>\n    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>\n    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)\n    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }\n\n  /** @}  */\n\n#if __cplusplus >= 201402L\n  template<typename _Func, typename _SfinaeType, typename = __void_t<>>\n    struct __has_is_transparent\n    { };\n\n  template<typename _Func, typename _SfinaeType>\n    struct __has_is_transparent<_Func, _SfinaeType,\n\t\t\t\t__void_t<typename _Func::is_transparent>>\n    { typedef void type; };\n\n  template<typename _Func, typename _SfinaeType>\n    using __has_is_transparent_t\n      = typename __has_is_transparent<_Func, _SfinaeType>::type;\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#if (__cplusplus < 201103L) || _GLIBCXX_USE_DEPRECATED\n# include <backward/binders.h>\n#endif\n\n#endif /* _STL_FUNCTION_H */\n"}],"crc32":2920244231,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]