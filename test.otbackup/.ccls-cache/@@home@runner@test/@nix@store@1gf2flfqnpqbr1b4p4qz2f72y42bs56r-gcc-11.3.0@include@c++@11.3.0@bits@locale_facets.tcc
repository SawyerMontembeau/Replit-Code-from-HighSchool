[{"ops":[{"insert":"// Locale support -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/locale_facets.tcc\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{locale}\n */\n\n#ifndef _LOCALE_FACETS_TCC\n#define _LOCALE_FACETS_TCC 1\n\n#pragma GCC system_header\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // Routine to access a cache for the facet.  If the cache didn't\n  // exist before, it gets constructed on the fly.\n  template<typename _Facet>\n    struct __use_cache\n    {\n      const _Facet*\n      operator() (const locale& __loc) const;\n    };\n\n  // Specializations.\n  template<typename _CharT>\n    struct __use_cache<__numpunct_cache<_CharT> >\n    {\n      const __numpunct_cache<_CharT>*\n      operator() (const locale& __loc) const\n      {\n\tconst size_t __i = numpunct<_CharT>::id._M_id();\n\tconst locale::facet** __caches = __loc._M_impl->_M_caches;\n\tif (!__caches[__i])\n\t  {\n\t    __numpunct_cache<_CharT>* __tmp = 0;\n\t    __try\n\t      {\n\t\t__tmp = new __numpunct_cache<_CharT>;\n\t\t__tmp->_M_cache(__loc);\n\t      }\n\t    __catch(...)\n\t      {\n\t\tdelete __tmp;\n\t\t__throw_exception_again;\n\t      }\n\t    __loc._M_impl->_M_install_cache(__tmp, __i);\n\t  }\n\treturn static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);\n      }\n    };\n\n  template<typename _CharT>\n    void\n    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)\n    {\n      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n\n      char* __grouping = 0;\n      _CharT* __truename = 0;\n      _CharT* __falsename = 0;\n      __try\n\t{\n\t  const string& __g = __np.grouping();\n\t  _M_grouping_size = __g.size();\n\t  __grouping = new char[_M_grouping_size];\n\t  __g.copy(__grouping, _M_grouping_size);\n\t  _M_use_grouping = (_M_grouping_size\n\t\t\t     && static_cast<signed char>(__grouping[0]) > 0\n\t\t\t     && (__grouping[0]\n\t\t\t\t != __gnu_cxx::__numeric_traits<char>::__max));\n\n\t  const basic_string<_CharT>& __tn = __np.truename();\n\t  _M_truename_size = __tn.size();\n\t  __truename = new _CharT[_M_truename_size];\n\t  __tn.copy(__truename, _M_truename_size);\n\n\t  const basic_string<_CharT>& __fn = __np.falsename();\n\t  _M_falsename_size = __fn.size();\n\t  __falsename = new _CharT[_M_falsename_size];\n\t  __fn.copy(__falsename, _M_falsename_size);\n\n\t  _M_decimal_point = __np.decimal_point();\n\t  _M_thousands_sep = __np.thousands_sep();\n\n\t  const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);\n\t  __ct.widen(__num_base::_S_atoms_out,\n\t\t     __num_base::_S_atoms_out\n\t\t     + __num_base::_S_oend, _M_atoms_out);\n\t  __ct.widen(__num_base::_S_atoms_in,\n\t\t     __num_base::_S_atoms_in\n\t\t     + __num_base::_S_iend, _M_atoms_in);\n\n\t  _M_grouping = __grouping;\n\t  _M_truename = __truename;\n\t  _M_falsename = __falsename;\n\t  _M_allocated = true;\n\t}\n      __catch(...)\n\t{\n\t  delete [] __grouping;\n\t  delete [] __truename;\n\t  delete [] __falsename;\n\t  __throw_exception_again;\n\t}\n    }\n\n  // Used by both numeric and monetary facets.\n  // Check to make sure that the __grouping_tmp string constructed in\n  // money_get or num_get matches the canonical grouping for a given\n  // locale.\n  // __grouping_tmp is parsed L to R\n  // 1,222,444 == __grouping_tmp of \"\\1\\3\\3\"\n  // __grouping is parsed R to L\n  // 1,222,444 == __grouping of \"\\3\" == \"\\3\\3\\3\"\n  _GLIBCXX_PURE bool\n  __verify_grouping(const char* __grouping, size_t __grouping_size,\n\t\t    const string& __grouping_tmp) throw ();\n\n_GLIBCXX_BEGIN_NAMESPACE_LDBL\n\n  template<typename _CharT, typename _InIter>\n    _GLIBCXX_DEFAULT_ABI_TAG\n    _InIter\n    num_get<_CharT, _InIter>::\n    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,\n\t\t     ios_base::iostate& __err, string& __xtrc) const\n    {\n      typedef char_traits<_CharT>\t\t\t__traits_type;\n      typedef __numpunct_cache<_CharT>                  __cache_type;\n      __use_cache<__cache_type> __uc;\n      const locale& __loc = __io._M_getloc();\n      const __cache_type* __lc = __uc(__loc);\n      const _CharT* __lit = __lc->_M_atoms_in;\n      char_type __c = char_type();\n\n      // True if __beg becomes equal to __end.\n      bool __testeof = __beg == __end;\n\n      // First check for sign.\n      if (!__testeof)\n\t{\n\t  __c = *__beg;\n\t  const bool __plus = __c == __lit[__num_base::_S_iplus];\n\t  if ((__plus || __c == __lit[__num_base::_S_iminus])\n\t      && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n\t      && !(__c == __lc->_M_decimal_point))\n\t    {\n\t      __xtrc += __plus ? '+' : '-';\n\t      if (++__beg != __end)\n\t\t__c = *__beg;\n\t      else\n\t\t__testeof = true;\n\t    }\n\t}\n\n      // Next, look for leading zeros.\n      bool __found_mantissa = false;\n      int __sep_pos = 0;\n      while (!__testeof)\n\t{\n\t  if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n\t      || __c == __lc->_M_decimal_point)\n\t    break;\n\t  else if (__c == __lit[__num_base::_S_izero])\n\t    {\n\t      if (!__found_mantissa)\n\t\t{\n\t\t  __xtrc += '0';\n\t\t  __found_mantissa = true;\n\t\t}\n\t      ++__sep_pos;\n\n\t      if (++__beg != __end)\n\t\t__c = *__beg;\n\t      else\n\t\t__testeof = true;\n\t    }\n\t  else\n\t    break;\n\t}\n\n      // Only need acceptable digits for floating point numbers.\n      bool __found_dec = false;\n      bool __found_sci = false;\n      string __found_grouping;\n      if (__lc->_M_use_grouping)\n\t__found_grouping.reserve(32);\n      const char_type* __lit_zero = __lit + __num_base::_S_izero;\n\n      if (!__lc->_M_allocated)\n\t// \"C\" locale\n\twhile (!__testeof)\n\t  {\n\t    const int __digit = _M_find(__lit_zero, 10, __c);\n\t    if (__digit != -1)\n\t      {\n\t\t__xtrc += '0' + __digit;\n\t\t__found_mantissa = true;\n\t      }\n\t    else if (__c == __lc->_M_decimal_point\n\t\t     && !__found_dec && !__found_sci)\n\t      {\n\t\t__xtrc += '.';\n\t\t__found_dec = true;\n\t      }\n\t    else if ((__c == __lit[__num_base::_S_ie] \n\t\t      || __c == __lit[__num_base::_S_iE])\n\t\t     && !__found_sci && __found_mantissa)\n\t      {\n\t\t// Scientific notation.\n\t\t__xtrc += 'e';\n\t\t__found_sci = true;\n\t\t\n\t\t// Remove optional plus or minus sign, if they exist.\n\t\tif (++__beg != __end)\n\t\t  {\n\t\t    __c = *__beg;\n\t\t    const bool __plus = __c == __lit[__num_base::_S_iplus];\n\t\t    if (__plus || __c == __lit[__num_base::_S_iminus])\n\t\t      __xtrc += __plus ? '+' : '-';\n\t\t    else\n\t\t      continue;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    __testeof = true;\n\t\t    break;\n\t\t  }\n\t      }\n\t    else\n\t      break;\n\n\t    if (++__beg != __end)\n\t      __c = *__beg;\n\t    else\n\t      __testeof = true;\n\t  }\n      else\n\twhile (!__testeof)\n\t  {\n\t    // According to 22.2.2.1.2, p8-9, first look for thousands_sep\n\t    // and decimal_point.\n\t    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n\t      {\n\t\tif (!__found_dec && !__found_sci)\n\t\t  {\n\t\t    // NB: Thousands separator at the beginning of a string\n\t\t    // is a no-no, as is two consecutive thousands separators.\n\t\t    if (__sep_pos)\n\t\t      {\n\t\t\t__found_grouping += static_cast<char>(__sep_pos);\n\t\t\t__sep_pos = 0;\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\t// NB: __convert_to_v will not assign __v and will\n\t\t\t// set the failbit.\n\t\t\t__xtrc.clear();\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  break;\n\t      }\n\t    else if (__c == __lc->_M_decimal_point)\n\t      {\n\t\tif (!__found_dec && !__found_sci)\n\t\t  {\n\t\t    // If no grouping chars are seen, no grouping check\n\t\t    // is applied. Therefore __found_grouping is adjusted\n\t\t    // only if decimal_point comes after some thousands_sep.\n\t\t    if (__found_grouping.size())\n\t\t      __found_grouping += static_cast<char>(__sep_pos);\n\t\t    __xtrc += '.';\n\t\t    __found_dec = true;\n\t\t  }\n\t\telse\n\t\t  break;\n\t      }\n\t    else\n\t      {\n\t\tconst char_type* __q =\n\t\t  __traits_type::find(__lit_zero, 10, __c);\n\t\tif (__q)\n\t\t  {\n\t\t    __xtrc += '0' + (__q - __lit_zero);\n\t\t    __found_mantissa = true;\n\t\t    ++__sep_pos;\n\t\t  }\n\t\telse if ((__c == __lit[__num_base::_S_ie] \n\t\t\t  || __c == __lit[__num_base::_S_iE])\n\t\t\t && !__found_sci && __found_mantissa)\n\t\t  {\n\t\t    // Scientific notation.\n\t\t    if (__found_grouping.size() && !__found_dec)\n\t\t      __found_grouping += static_cast<char>(__sep_pos);\n\t\t    __xtrc += 'e';\n\t\t    __found_sci = true;\n\t\t    \n\t\t    // Remove optional plus or minus sign, if they exist.\n\t\t    if (++__beg != __end)\n\t\t      {\n\t\t\t__c = *__beg;\n\t\t\tconst bool __plus = __c == __lit[__num_base::_S_iplus];\n\t\t\tif ((__plus || __c == __lit[__num_base::_S_iminus])\n\t\t\t    && !(__lc->_M_use_grouping\n\t\t\t\t && __c == __lc->_M_thousands_sep)\n\t\t\t    && !(__c == __lc->_M_decimal_point))\n\t\t      __xtrc += __plus ? '+' : '-';\n\t\t\telse\n\t\t\t  continue;\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\t__testeof = true;\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  break;\n\t      }\n\t    \n\t    if (++__beg != __end)\n\t      __c = *__beg;\n\t    else\n\t      __testeof = true;\n\t  }\n\n      // Digit grouping is checked. If grouping and found_grouping don't\n      // match, then get very very upset, and set failbit.\n      if (__found_grouping.size())\n        {\n          // Add the ending grouping if a decimal or 'e'/'E' wasn't found.\n\t  if (!__found_dec && !__found_sci)\n\t    __found_grouping += static_cast<char>(__sep_pos);\n\n          if (!std::__verify_grouping(__lc->_M_grouping, \n\t\t\t\t      __lc->_M_grouping_size,\n\t\t\t\t      __found_grouping))\n\t    __err = ios_base::failbit;\n        }\n\n      return __beg;\n    }\n\n  template<typename _CharT, typename _InIter>\n    template<typename _ValueT>\n      _GLIBCXX_DEFAULT_ABI_TAG\n      _InIter\n      num_get<_CharT, _InIter>::\n      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,\n\t\t     ios_base::iostate& __err, _ValueT& __v) const\n      {\n        typedef char_traits<_CharT>\t\t\t    __traits_type;\n\tusing __gnu_cxx::__add_unsigned;\n\ttypedef typename __add_unsigned<_ValueT>::__type    __unsigned_type;\n\ttypedef __numpunct_cache<_CharT>                    __cache_type;\n\t__use_cache<__cache_type> __uc;\n\tconst locale& __loc = __io._M_getloc();\n\tconst __cache_type* __lc = __uc(__loc);\n\tconst _CharT* __lit = __lc->_M_atoms_in;\n\tchar_type __c = char_type();\n\n\t// NB: Iff __basefield == 0, __base can change based on contents.\n\tconst ios_base::fmtflags __basefield = __io.flags()\n\t                                       & ios_base::basefield;\n\tconst bool __oct = __basefield == ios_base::oct;\n\tint __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);\n\n\t// True if __beg becomes equal to __end.\n\tbool __testeof = __beg == __end;\n\n\t// First check for sign.\n\tbool __negative = false;\n\tif (!__testeof)\n\t  {\n\t    __c = *__beg;\n\t    __negative = __c == __lit[__num_base::_S_iminus];\n\t    if ((__negative || __c == __lit[__num_base::_S_iplus])\n\t\t&& !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n\t\t&& !(__c == __lc->_M_decimal_point))\n\t      {\n\t\tif (++__beg != __end)\n\t\t  __c = *__beg;\n\t\telse\n\t\t  __testeof = true;\n\t      }\n\t  }\n\n\t// Next, look for leading zeros and check required digits\n\t// for base formats.\n\tbool __found_zero = false;\n\tint __sep_pos = 0;\n\twhile (!__testeof)\n\t  {\n\t    if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n\t\t|| __c == __lc->_M_decimal_point)\n\t      break;\n\t    else if (__c == __lit[__num_base::_S_izero] \n\t\t     && (!__found_zero || __base == 10))\n\t      {\n\t\t__found_zero = true;\n\t\t++__sep_pos;\n\t\tif (__basefield == 0)\n\t\t  __base = 8;\n\t\tif (__base == 8)\n\t\t  __sep_pos = 0;\n\t      }\n\t    else if (__found_zero\n\t\t     && (__c == __lit[__num_base::_S_ix]\n\t\t\t || __c == __lit[__num_base::_S_iX]))\n\t      {\n\t\tif (__basefield == 0)\n\t\t  __base = 16;\n\t\tif (__base == 16)\n\t\t  {\n\t\t    __found_zero = false;\n\t\t    __sep_pos = 0;\n\t\t  }\n\t\telse\n\t\t  break;\n\t      }\n\t    else\n\t      break;\n\n\t    if (++__beg != __end)\n\t      {\n\t\t__c = *__beg;\n\t\tif (!__found_zero)\n\t\t  break;\n\t      }\n\t    else\n\t      __testeof = true;\n\t  }\n\t\n\t// At this point, base is determined. If not hex, only allow\n\t// base digits as valid input.\n\tconst size_t __len = (__base == 16 ? __num_base::_S_iend\n\t\t\t      - __num_base::_S_izero : __base);\n\n\t// Extract.\n\ttypedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;\n\tstring __found_grouping;\n\tif (__lc->_M_use_grouping)\n\t  __found_grouping.reserve(32);\n\tbool __testfail = false;\n\tbool __testoverflow = false;\n\tconst __unsigned_type __max =\n\t  (__negative && __num_traits::__is_signed)\n\t  ? -static_cast<__unsigned_type>(__num_traits::__min)\n\t  : __num_traits::__max;\n\tconst __unsigned_type __smax = __max / __base;\n\t__unsigned_type __result = 0;\n\tint __digit = 0;\n\tconst char_type* __lit_zero = __lit + __num_base::_S_izero;\n\n\tif (!__lc->_M_allocated)\n\t  // \"C\" locale\n\t  while (!__testeof)\n\t    {\n\t      __digit = _M_find(__lit_zero, __len, __c);\n\t      if (__digit == -1)\n\t\tbreak;\n\t      \n\t      if (__result > __smax)\n\t\t__testoverflow = true;\n\t      else\n\t\t{\n\t\t  __result *= __base;\n\t\t  __testoverflow |= __result > __max - __digit;\n\t\t  __result += __digit;\n\t\t  ++__sep_pos;\n\t\t}\n\t      \n\t      if (++__beg != __end)\n\t\t__c = *__beg;\n\t      else\n\t\t__testeof = true;\n\t    }\n\telse\n\t  while (!__testeof)\n\t    {\n\t      // According to 22.2.2.1.2, p8-9, first look for thousands_sep\n\t      // and decimal_point.\n\t      if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n\t\t{\n\t\t  // NB: Thousands separator at the beginning of a string\n\t\t  // is a no-no, as is two consecutive thousands separators.\n\t\t  if (__sep_pos)\n\t\t    {\n\t\t      __found_grouping += static_cast<char>(__sep_pos);\n\t\t      __sep_pos = 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      __testfail = true;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      else if (__c == __lc->_M_decimal_point)\n\t\tbreak;\n\t      else\n\t\t{\n\t\t  const char_type* __q =\n\t\t    __traits_type::find(__lit_zero, __len, __c);\n\t\t  if (!__q)\n\t\t    break;\n\t\t  \n\t\t  __digit = __q - __lit_zero;\n\t\t  if (__digit > 15)\n\t\t    __digit -= 6;\n\t\t  if (__result > __smax)\n\t\t    __testoverflow = true;\n\t\t  else\n\t\t    {\n\t\t      __result *= __base;\n\t\t      __testoverflow |= __result > __max - __digit;\n\t\t      __result += __digit;\n\t\t      ++__sep_pos;\n\t\t    }\n\t\t}\n\t      \n\t      if (++__beg != __end)\n\t\t__c = *__beg;\n\t      else\n\t\t__testeof = true;\n\t    }\n\t\n\t// Digit grouping is checked. If grouping and found_grouping don't\n\t// match, then get very very upset, and set failbit.\n\tif (__found_grouping.size())\n\t  {\n\t    // Add the ending grouping.\n\t    __found_grouping += static_cast<char>(__sep_pos);\n\n\t    if (!std::__verify_grouping(__lc->_M_grouping,\n\t\t\t\t\t__lc->_M_grouping_size,\n\t\t\t\t\t__found_grouping))\n\t      __err = ios_base::failbit;\n\t  }\n\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 23. Num_get overflow result.\n\tif ((!__sep_pos && !__found_zero && !__found_grouping.size())\n\t    || __testfail)\n\t  {\n\t    __v = 0;\n\t    __err = ios_base::failbit;\n\t  }\n\telse if (__testoverflow)\n\t  {\n\t    if (__negative && __num_traits::__is_signed)\n\t      __v = __num_traits::__min;\n\t    else\n\t      __v = __num_traits::__max;\n\t    __err = ios_base::failbit;\n\t  }\n\telse\n\t  __v = __negative ? -__result : __result;\n\n\tif (__testeof)\n\t  __err |= ios_base::eofbit;\n\treturn __beg;\n      }\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 17.  Bad bool parsing\n  template<typename _CharT, typename _InIter>\n    _InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n           ios_base::iostate& __err, bool& __v) const\n    {\n      if (!(__io.flags() & ios_base::boolalpha))\n        {\n\t  // Parse bool values as long.\n          // NB: We can't just call do_get(long) here, as it might\n          // refer to a derived class.\n\t  long __l = -1;\n          __beg = _M_extract_int(__beg, __end, __io, __err, __l);\n\t  if (__l == 0 || __l == 1)\n\t    __v = bool(__l);\n\t  else\n\t    {\n\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t      // 23. Num_get overflow result.\n\t      __v = true;\n\t      __err = ios_base::failbit;\n\t      if (__beg == __end)\n\t\t__err |= ios_base::eofbit;\n\t    }\n        }\n      else\n        {\n\t  // Parse bool values as alphanumeric.\n\t  typedef __numpunct_cache<_CharT>  __cache_type;\n\t  __use_cache<__cache_type> __uc;\n\t  const locale& __loc = __io._M_getloc();\n\t  const __cache_type* __lc = __uc(__loc);\n\n\t  bool __testf = true;\n\t  bool __testt = true;\n\t  bool __donef = __lc->_M_falsename_size == 0;\n\t  bool __donet = __lc->_M_truename_size == 0;\n\t  bool __testeof = false;\n\t  size_t __n = 0;\n\t  while (!__donef || !__donet)\n\t    {\n\t      if (__beg == __end)\n\t\t{\n\t\t  __testeof = true;\n\t\t  break;\n\t\t}\n\n\t      const char_type __c = *__beg;\n\n\t      if (!__donef)\n\t\t__testf = __c == __lc->_M_falsename[__n];\n\n\t      if (!__testf && __donet)\n\t\tbreak;\n\n\t      if (!__donet)\n\t\t__testt = __c == __lc->_M_truename[__n];\n\n\t      if (!__testt && __donef)\n\t\tbreak;\n\n\t      if (!__testt && !__testf)\n\t\tbreak;\n\n\t      ++__n;\n\t      ++__beg;\n\n\t      __donef = !__testf || __n >= __lc->_M_falsename_size;\n\t      __donet = !__testt || __n >= __lc->_M_truename_size;\n\t    }\n\t  if (__testf && __n == __lc->_M_falsename_size && __n)\n\t    {\n\t      __v = false;\n\t      if (__testt && __n == __lc->_M_truename_size)\n\t\t__err = ios_base::failbit;\n\t      else\n\t\t__err = __testeof ? ios_base::eofbit : ios_base::goodbit;\n\t    }\n\t  else if (__testt && __n == __lc->_M_truename_size && __n)\n\t    {\n\t      __v = true;\n\t      __err = __testeof ? ios_base::eofbit : ios_base::goodbit;\n\t    }\n\t  else\n\t    {\n\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t      // 23. Num_get overflow result.\n\t      __v = false;\n\t      __err = ios_base::failbit;\n\t      if (__testeof)\n\t\t__err |= ios_base::eofbit;\n\t    }\n\t}\n      return __beg;\n    }\n\n  template<typename _CharT, typename _InIter>\n    _InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n\t   ios_base::iostate& __err, float& __v) const\n    {\n      string __xtrc;\n      __xtrc.reserve(32);\n      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);\n      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());\n      if (__beg == __end)\n\t__err |= ios_base::eofbit;\n      return __beg;\n    }\n\n  template<typename _CharT, typename _InIter>\n    _InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n           ios_base::iostate& __err, double& __v) const\n    {\n      string __xtrc;\n      __xtrc.reserve(32);\n      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);\n      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());\n      if (__beg == __end)\n\t__err |= ios_base::eofbit;\n      return __beg;\n    }\n\n#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n  template<typename _CharT, typename _InIter>\n    _InIter\n    num_get<_CharT, _InIter>::\n    __do_get(iter_type __beg, iter_type __end, ios_base& __io,\n\t     ios_base::iostate& __err, double& __v) const\n    {\n      string __xtrc;\n      __xtrc.reserve(32);\n      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);\n      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());\n      if (__beg == __end)\n\t__err |= ios_base::eofbit;\n      return __beg;\n    }\n#endif\n\n  template<typename _CharT, typename _InIter>\n    _InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n           ios_base::iostate& __err, long double& __v) const\n    {\n      string __xtrc;\n      __xtrc.reserve(32);\n      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);\n      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());\n      if (__beg == __end)\n\t__err |= ios_base::eofbit;\n      return __beg;\n    }\n\n  template<typename _CharT, typename _InIter>\n    _InIter\n    num_get<_CharT, _InIter>::\n    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n           ios_base::iostate& __err, void*& __v) const\n    {\n      // Prepare for hex formatted input.\n      typedef ios_base::fmtflags        fmtflags;\n      const fmtflags __fmt = __io.flags();\n      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);\n\n      typedef __gnu_cxx::__conditional_type<(sizeof(void*)\n\t\t\t\t\t     <= sizeof(unsigned long)),\n\tunsigned long, unsigned long long>::__type _UIntPtrType;       \n\n      _UIntPtrType __ul;\n      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);\n\n      // Reset from hex formatted input.\n      __io.flags(__fmt);\n\n      __v = reinterpret_cast<void*>(__ul);\n      return __beg;\n    }\n\n#if defined _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT \\\n      && defined __LONG_DOUBLE_IEEE128__\n  template<typename _CharT, typename _InIter>\n    _InIter\n    num_get<_CharT, _InIter>::\n    __do_get(iter_type __beg, iter_type __end, ios_base& __io,\n\t     ios_base::iostate& __err, __ibm128& __v) const\n    {\n      string __xtrc;\n      __xtrc.reserve(32);\n      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);\n      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());\n      if (__beg == __end)\n\t__err |= ios_base::eofbit;\n      return __beg;\n    }\n#endif\n\n  // For use by integer and floating-point types after they have been\n  // converted into a char_type string.\n  template<typename _CharT, typename _OutIter>\n    void\n    num_put<_CharT, _OutIter>::\n    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,\n\t   _CharT* __new, const _CharT* __cs, int& __len) const\n    {\n      // [22.2.2.2.2] Stage 3.\n      // If necessary, pad.\n      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,\n\t\t\t\t\t\t  __cs, __w, __len);\n      __len = static_cast<int>(__w);\n    }\n\n_GLIBCXX_END_NAMESPACE_LDBL\n\n  template<typename _CharT, typename _ValueT>\n    int\n    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,\n\t\t  ios_base::fmtflags __flags, bool __dec)\n    {\n      _CharT* __buf = __bufend;\n      if (__builtin_expect(__dec, true))\n\t{\n\t  // Decimal.\n\t  do\n\t    {\n\t      *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];\n\t      __v /= 10;\n\t    }\n\t  while (__v != 0);\n\t}\n      else if ((__flags & ios_base::basefield) == ios_base::oct)\n\t{\n\t  // Octal.\n\t  do\n\t    {\n\t      *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];\n\t      __v >>= 3;\n\t    }\n\t  while (__v != 0);\n\t}\n      else\n\t{\n\t  // Hex.\n\t  const bool __uppercase = __flags & ios_base::uppercase;\n\t  const int __case_offset = __uppercase ? __num_base::_S_oudigits\n\t                                        : __num_base::_S_odigits;\n\t  do\n\t    {\n\t      *--__buf = __lit[(__v & 0xf) + __case_offset];\n\t      __v >>= 4;\n\t    }\n\t  while (__v != 0);\n\t}\n      return __bufend - __buf;\n    }\n\n_GLIBCXX_BEGIN_NAMESPACE_LDBL\n\n  template<typename _CharT, typename _OutIter>\n    void\n    num_put<_CharT, _OutIter>::\n    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,\n\t\t ios_base&, _CharT* __new, _CharT* __cs, int& __len) const\n    {\n      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,\n\t\t\t\t\t__grouping_size, __cs, __cs + __len);\n      __len = __p - __new;\n    }\n  \n  template<typename _CharT, typename _OutIter>\n    template<typename _ValueT>\n      _OutIter\n      num_put<_CharT, _OutIter>::\n      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,\n\t\t    _ValueT __v) const\n      {\n\tusing __gnu_cxx::__add_unsigned;\n\ttypedef typename __add_unsigned<_ValueT>::__type __unsigned_type;\n\ttypedef __numpunct_cache<_CharT>\t             __cache_type;\n\t__use_cache<__cache_type> __uc;\n\tconst locale& __loc = __io._M_getloc();\n\tconst __cache_type* __lc = __uc(__loc);\n\tconst _CharT* __lit = __lc->_M_atoms_out;\n\tconst ios_base::fmtflags __flags = __io.flags();\n\n\t// Long enough to hold hex, dec, and octal representations.\n\tconst int __ilen = 5 * sizeof(_ValueT);\n\t_CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n\t\t\t\t\t\t\t     * __ilen));\n\n\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n\t// Result is returned right-justified in the buffer.\n\tconst ios_base::fmtflags __basefield = __flags & ios_base::basefield;\n\tconst bool __dec = (__basefield != ios_base::oct\n\t\t\t    && __basefield != ios_base::hex);\n\tconst __unsigned_type __u = ((__v > 0 || !__dec)\n\t\t\t\t     ? __unsigned_type(__v)\n\t\t\t\t     : -__unsigned_type(__v));\n \tint __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);\n\t__cs += __ilen - __len;\n\n\t// Add grouping, if necessary.\n\tif (__lc->_M_use_grouping)\n\t  {\n\t    // Grouping can add (almost) as many separators as the number\n\t    // of digits + space is reserved for numeric base or sign.\n\t    _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n\t\t\t\t\t\t\t\t  * (__len + 1)\n\t\t\t\t\t\t\t\t  * 2));\n\t    _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,\n\t\t\t __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);\n\t    __cs = __cs2 + 2;\n\t  }\n\n\t// Complete Stage 1, prepend numeric base or sign.\n\tif (__builtin_expect(__dec, true))\n\t  {\n\t    // Decimal.\n\t    if (__v >= 0)\n\t      {\n\t\tif (bool(__flags & ios_base::showpos)\n\t\t    && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)\n\t\t  *--__cs = __lit[__num_base::_S_oplus], ++__len;\n\t      }\n\t    else\n\t      *--__cs = __lit[__num_base::_S_ominus], ++__len;\n\t  }\n\telse if (bool(__flags & ios_base::showbase) && __v)\n\t  {\n\t    if (__basefield == ios_base::oct)\n\t      *--__cs = __lit[__num_base::_S_odigits], ++__len;\n\t    else\n\t      {\n\t\t// 'x' or 'X'\n\t\tconst bool __uppercase = __flags & ios_base::uppercase;\n\t\t*--__cs = __lit[__num_base::_S_ox + __uppercase];\n\t\t// '0'\n\t\t*--__cs = __lit[__num_base::_S_odigits];\n\t\t__len += 2;\n\t      }\n\t  }\n\n\t// Pad.\n\tconst streamsize __w = __io.width();\n\tif (__w > static_cast<streamsize>(__len))\n\t  {\n\t    _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n\t\t\t\t\t\t\t\t  * __w));\n\t    _M_pad(__fill, __w, __io, __cs3, __cs, __len);\n\t    __cs = __cs3;\n\t  }\n\t__io.width(0);\n\n\t// [22.2.2.2.2] Stage 4.\n\t// Write resulting, fully-formatted string to output iterator.\n\treturn std::__write(__s, __cs, __len);\n      }\n\n  template<typename _CharT, typename _OutIter>\n    void\n    num_put<_CharT, _OutIter>::\n    _M_group_float(const char* __grouping, size_t __grouping_size,\n\t\t   _CharT __sep, const _CharT* __p, _CharT* __new,\n\t\t   _CharT* __cs, int& __len) const\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 282. What types does numpunct grouping refer to?\n      // Add grouping, if necessary.\n      const int __declen = __p ? __p - __cs : __len;\n      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,\n\t\t\t\t\t __grouping_size,\n\t\t\t\t\t __cs, __cs + __declen);\n\n      // Tack on decimal part.\n      int __newlen = __p2 - __new;\n      if (__p)\n\t{\n\t  char_traits<_CharT>::copy(__p2, __p, __len - __declen);\n\t  __newlen += __len - __declen;\n\t}\n      __len = __newlen;\n    }\n\n  // The following code uses vsnprintf (or vsprintf(), when\n  // _GLIBCXX_USE_C99_STDIO is not defined) to convert floating point\n  // values for insertion into a stream.  An optimization would be to\n  // replace them with code that works directly on a wide buffer and\n  // then use __pad to do the padding.  It would be good to replace\n  // them anyway to gain back the efficiency that C++ provides by\n  // knowing up front the type of the values to insert.  Also, sprintf\n  // is dangerous since may lead to accidental buffer overruns.  This\n  // implementation follows the C++ standard fairly directly as\n  // outlined in 22.2.2.2 [lib.locale.num.put]\n  template<typename _CharT, typename _OutIter>\n    template<typename _ValueT>\n      _OutIter\n      num_put<_CharT, _OutIter>::\n      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,\n\t\t       _ValueT __v) const\n      {\n\ttypedef __numpunct_cache<_CharT>                __cache_type;\n\t__use_cache<__cache_type> __uc;\n\tconst locale& __loc = __io._M_getloc();\n\tconst __cache_type* __lc = __uc(__loc);\n\n\t// Use default precision if out of range.\n\tconst streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();\n\n\tconst int __max_digits =\n\t  __gnu_cxx::__numeric_traits<_ValueT>::__digits10;\n\n\t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n\tint __len;\n\t// Long enough for the max format spec.\n\tchar __fbuf[16];\n\t__num_base::_S_format_float(__io, __fbuf, __mod);\n\n#if _GLIBCXX_USE_C99_STDIO && !_GLIBCXX_HAVE_BROKEN_VSNPRINTF\n\t// Precision is always used except for hexfloat format.\n\tconst bool __use_prec =\n\t  (__io.flags() & ios_base::floatfield) != ios_base::floatfield;\n\n\t// First try a buffer perhaps big enough (most probably sufficient\n\t// for non-ios_base::fixed outputs)\n\tint __cs_size = __max_digits * 3;\n\tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n\tif (__use_prec)\n\t  __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,\n\t\t\t\t\t__fbuf, __prec, __v);\n\telse\n\t  __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,\n\t\t\t\t\t__fbuf, __v);\n\n\t// If the buffer was not large enough, try again with the correct size.\n\tif (__len >= __cs_size)\n\t  {\n\t    __cs_size = __len + 1;\n\t    __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n\t    if (__use_prec)\n\t      __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,\n\t\t\t\t\t    __fbuf, __prec, __v);\n\t    else\n\t      __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,\n\t\t\t\t\t    __fbuf, __v);\n\t  }\n#else\n\t// Consider the possibility of long ios_base::fixed outputs\n\tconst bool __fixed = __io.flags() & ios_base::fixed;\n\tconst int __max_exp =\n\t  __gnu_cxx::__numeric_traits<_ValueT>::__max_exponent10;\n\n\t// The size of the output string is computed as follows.\n\t// ios_base::fixed outputs may need up to __max_exp + 1 chars\n\t// for the integer part + __prec chars for the fractional part\n\t// + 3 chars for sign, decimal point, '\\0'. On the other hand,\n\t// for non-fixed outputs __max_digits * 2 + __prec chars are\n\t// largely sufficient.\n\tconst int __cs_size = __fixed ? __max_exp + __prec + 4\n\t                              : __max_digits * 2 + __prec;\n\tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n\t__len = std::__convert_from_v(_S_get_c_locale(), __cs, 0, __fbuf, \n\t\t\t\t      __prec, __v);\n#endif\n\n\t// [22.2.2.2.2] Stage 2, convert to char_type, using correct\n\t// numpunct.decimal_point() values for '.' and adding grouping.\n\tconst ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n\t\n\t_CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n\t\t\t\t\t\t\t     * __len));\n\t__ctype.widen(__cs, __cs + __len, __ws);\n\t\n\t// Replace decimal point.\n\t_CharT* __wp = 0;\n\tconst char* __p = char_traits<char>::find(__cs, __len, '.');\n\tif (__p)\n\t  {\n\t    __wp = __ws + (__p - __cs);\n\t    *__wp = __lc->_M_decimal_point;\n\t  }\n\t\n\t// Add grouping, if necessary.\n\t// N.B. Make sure to not group things like 2e20, i.e., no decimal\n\t// point, scientific notation.\n\tif (__lc->_M_use_grouping\n\t    && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'\n\t\t\t\t      && __cs[1] >= '0' && __cs[2] >= '0')))\n\t  {\n\t    // Grouping can add (almost) as many separators as the\n\t    // number of digits, but no more.\n\t    _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n\t\t\t\t\t\t\t\t  * __len * 2));\n\t    \n\t    streamsize __off = 0;\n\t    if (__cs[0] == '-' || __cs[0] == '+')\n\t      {\n\t\t__off = 1;\n\t\t__ws2[0] = __ws[0];\n\t\t__len -= 1;\n\t      }\n\t    \n\t    _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,\n\t\t\t   __lc->_M_thousands_sep, __wp, __ws2 + __off,\n\t\t\t   __ws + __off, __len);\n\t    __len += __off;\n\t    \n\t    __ws = __ws2;\n\t  }\n\n\t// Pad.\n\tconst streamsize __w = __io.width();\n\tif (__w > static_cast<streamsize>(__len))\n\t  {\n\t    _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n\t\t\t\t\t\t\t\t  * __w));\n\t    _M_pad(__fill, __w, __io, __ws3, __ws, __len);\n\t    __ws = __ws3;\n\t  }\n\t__io.width(0);\n\t\n\t// [22.2.2.2.2] Stage 4.\n\t// Write resulting, fully-formatted string to output iterator.\n\treturn std::__write(__s, __ws, __len);\n      }\n  \n  template<typename _CharT, typename _OutIter>\n    _OutIter\n    num_put<_CharT, _OutIter>::\n    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n    {\n      const ios_base::fmtflags __flags = __io.flags();\n      if ((__flags & ios_base::boolalpha) == 0)\n        {\n          const long __l = __v;\n          __s = _M_insert_int(__s, __io, __fill, __l);\n        }\n      else\n        {\n\t  typedef __numpunct_cache<_CharT>              __cache_type;\n\t  __use_cache<__cache_type> __uc;\n\t  const locale& __loc = __io._M_getloc();\n\t  const __cache_type* __lc = __uc(__loc);\n\n\t  const _CharT* __name = __v ? __lc->_M_truename\n\t                             : __lc->_M_falsename;\n\t  int __len = __v ? __lc->_M_truename_size\n\t                  : __lc->_M_falsename_size;\n\n\t  const streamsize __w = __io.width();\n\t  if (__w > static_cast<streamsize>(__len))\n\t    {\n\t      const streamsize __plen = __w - __len;\n\t      _CharT* __ps\n\t\t= static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n\t\t\t\t\t\t\t* __plen));\n\n\t      char_traits<_CharT>::assign(__ps, __plen, __fill);\n\t      __io.width(0);\n\n\t      if ((__flags & ios_base::adjustfield) == ios_base::left)\n\t\t{\n\t\t  __s = std::__write(__s, __name, __len);\n\t\t  __s = std::__write(__s, __ps, __plen);\n\t\t}\n\t      else\n\t\t{\n\t\t  __s = std::__write(__s, __ps, __plen);\n\t\t  __s = std::__write(__s, __name, __len);\n\t\t}\n\t      return __s;\n\t    }\n\t  __io.width(0);\n\t  __s = std::__write(__s, __name, __len);\n\t}\n      return __s;\n    }\n\n  template<typename _CharT, typename _OutIter>\n    _OutIter\n    num_put<_CharT, _OutIter>::\n    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n    { return _M_insert_float(__s, __io, __fill, char(), __v); }\n\n#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n  template<typename _CharT, typename _OutIter>\n    _OutIter\n    num_put<_CharT, _OutIter>::\n    __do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n    { return _M_insert_float(__s, __io, __fill, char(), __v); }\n#endif\n\n  template<typename _CharT, typename _OutIter>\n    _OutIter\n    num_put<_CharT, _OutIter>::\n    do_put(iter_type __s, ios_base& __io, char_type __fill,\n\t   long double __v) const\n    { return _M_insert_float(__s, __io, __fill, 'L', __v); }\n\n  template<typename _CharT, typename _OutIter>\n    _OutIter\n    num_put<_CharT, _OutIter>::\n    do_put(iter_type __s, ios_base& __io, char_type __fill,\n           const void* __v) const\n    {\n      const ios_base::fmtflags __flags = __io.flags();\n      const ios_base::fmtflags __fmt = ~(ios_base::basefield\n\t\t\t\t\t | ios_base::uppercase);\n      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));\n\n      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)\n\t\t\t\t\t     <= sizeof(unsigned long)),\n\tunsigned long, unsigned long long>::__type _UIntPtrType;       \n\n      __s = _M_insert_int(__s, __io, __fill,\n\t\t\t  reinterpret_cast<_UIntPtrType>(__v));\n      __io.flags(__flags);\n      return __s;\n    }\n\n#if defined _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT \\\n      && defined __LONG_DOUBLE_IEEE128__\n  template<typename _CharT, typename _OutIter>\n    _OutIter\n    num_put<_CharT, _OutIter>::\n    __do_put(iter_type __s, ios_base& __io, char_type __fill,\n\t     __ibm128 __v) const\n    { return _M_insert_float(__s, __io, __fill, 'L', __v); }\n#endif\n_GLIBCXX_END_NAMESPACE_LDBL\n\n  // Construct correctly padded string, as per 22.2.2.2.2\n  // Assumes\n  // __newlen > __oldlen\n  // __news is allocated for __newlen size\n\n  // NB: Of the two parameters, _CharT can be deduced from the\n  // function arguments. The other (_Traits) has to be explicitly specified.\n  template<typename _CharT, typename _Traits>\n    void\n    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,\n\t\t\t\t   _CharT* __news, const _CharT* __olds,\n\t\t\t\t   streamsize __newlen, streamsize __oldlen)\n    {\n      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);\n      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;\n\n      // Padding last.\n      if (__adjust == ios_base::left)\n\t{\n\t  _Traits::copy(__news, __olds, __oldlen);\n\t  _Traits::assign(__news + __oldlen, __plen, __fill);\n\t  return;\n\t}\n\n      size_t __mod = 0;\n      if (__adjust == ios_base::internal)\n\t{\n\t  // Pad after the sign, if there is one.\n\t  // Pad after 0[xX], if there is one.\n\t  // Who came up with these rules, anyway? Jeeze.\n          const locale& __loc = __io._M_getloc();\n\t  const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n\n\t  if (__ctype.widen('-') == __olds[0]\n\t      || __ctype.widen('+') == __olds[0])\n\t    {\n\t      __news[0] = __olds[0];\n\t      __mod = 1;\n\t      ++__news;\n\t    }\n\t  else if (__ctype.widen('0') == __olds[0]\n\t\t   && __oldlen > 1\n\t\t   && (__ctype.widen('x') == __olds[1]\n\t\t       || __ctype.widen('X') == __olds[1]))\n\t    {\n\t      __news[0] = __olds[0];\n\t      __news[1] = __olds[1];\n\t      __mod = 2;\n\t      __news += 2;\n\t    }\n\t  // else Padding first.\n\t}\n      _Traits::assign(__news, __plen, __fill);\n      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);\n    }\n\n  template<typename _CharT>\n    _CharT*\n    __add_grouping(_CharT* __s, _CharT __sep,\n\t\t   const char* __gbeg, size_t __gsize,\n\t\t   const _CharT* __first, const _CharT* __last)\n    {\n      size_t __idx = 0;\n      size_t __ctr = 0;\n\n      while (__last - __first > __gbeg[__idx]\n\t     && static_cast<signed char>(__gbeg[__idx]) > 0\n\t     && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)\n\t{\n\t  __last -= __gbeg[__idx];\n\t  __idx < __gsize - 1 ? ++__idx : ++__ctr;\n\t}\n\n      while (__first != __last)\n\t*__s++ = *__first++;\n\n      while (__ctr--)\n\t{\n\t  *__s++ = __sep;\t  \n\t  for (char __i = __gbeg[__idx]; __i > 0; --__i)\n\t    *__s++ = *__first++;\n\t}\n\n      while (__idx--)\n\t{\n\t  *__s++ = __sep;\t  \n\t  for (char __i = __gbeg[__idx]; __i > 0; --__i)\n\t    *__s++ = *__first++;\n\t}\n\n      return __s;\n    }\n\n  // Inhibit implicit instantiations for required instantiations,\n  // which are defined via explicit instantiations elsewhere.\n#if _GLIBCXX_EXTERN_TEMPLATE\n  extern template class _GLIBCXX_NAMESPACE_CXX11 numpunct<char>;\n  extern template class _GLIBCXX_NAMESPACE_CXX11 numpunct_byname<char>;\n  extern template class _GLIBCXX_NAMESPACE_LDBL num_get<char>;\n  extern template class _GLIBCXX_NAMESPACE_LDBL num_put<char>;\n  extern template class ctype_byname<char>;\n\n  extern template\n    const ctype<char>&\n    use_facet<ctype<char> >(const locale&);\n\n  extern template\n    const numpunct<char>&\n    use_facet<numpunct<char> >(const locale&);\n\n  extern template\n    const num_put<char>&\n    use_facet<num_put<char> >(const locale&);\n\n  extern template\n    const num_get<char>&\n    use_facet<num_get<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<ctype<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<numpunct<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_put<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_get<char> >(const locale&);\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  extern template class _GLIBCXX_NAMESPACE_CXX11 numpunct<wchar_t>;\n  extern template class _GLIBCXX_NAMESPACE_CXX11 numpunct_byname<wchar_t>;\n  extern template class _GLIBCXX_NAMESPACE_LDBL num_get<wchar_t>;\n  extern template class _GLIBCXX_NAMESPACE_LDBL num_put<wchar_t>;\n  extern template class ctype_byname<wchar_t>;\n\n  extern template\n    const ctype<wchar_t>&\n    use_facet<ctype<wchar_t> >(const locale&);\n\n  extern template\n    const numpunct<wchar_t>&\n    use_facet<numpunct<wchar_t> >(const locale&);\n\n  extern template\n    const num_put<wchar_t>&\n    use_facet<num_put<wchar_t> >(const locale&);\n\n  extern template\n    const num_get<wchar_t>&\n    use_facet<num_get<wchar_t> >(const locale&);\n\n extern template\n    bool\n    has_facet<ctype<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<numpunct<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_put<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<num_get<wchar_t> >(const locale&);\n#endif\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif\n"}],"crc32":245990754,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]