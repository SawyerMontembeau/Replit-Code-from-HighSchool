[{"ops":[{"insert":"// Pointer Traits -*- C++ -*-\n\n// Copyright (C) 2011-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/ptr_traits.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _PTR_TRAITS_H\n#define _PTR_TRAITS_H 1\n\n#if __cplusplus >= 201103L\n\n#include <bits/move.h>\n\n#if __cplusplus > 201703L\n#define __cpp_lib_constexpr_memory 201811L\nnamespace __gnu_debug { struct _Safe_iterator_base; }\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  class __undefined;\n\n  // Given Template<T, ...> and U return Template<U, ...>, otherwise invalid.\n  template<typename _Tp, typename _Up>\n    struct __replace_first_arg\n    { };\n\n  template<template<typename, typename...> class _Template, typename _Up,\n           typename _Tp, typename... _Types>\n    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>\n    { using type = _Template<_Up, _Types...>; };\n\n  template<typename _Tp, typename _Up>\n    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;\n\n  template<typename _Tp>\n    using __make_not_void\n      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;\n\n  template<typename _Ptr>\n    struct __ptr_traits_elem_1\n    { };\n\n  template<template<typename, typename...> class _SomePointer, typename _Tp,\n\t   typename... _Args>\n    struct __ptr_traits_elem_1<_SomePointer<_Tp, _Args...>>\n    {\n      using element_type = _Tp;\n      using pointer = _SomePointer<_Tp, _Args...>;\n\n      static pointer\n      pointer_to(__make_not_void<element_type>& __e)\n      { return pointer::pointer_to(__e); }\n    };\n\n  template<typename _Ptr, typename = void>\n    struct __ptr_traits_elem : __ptr_traits_elem_1<_Ptr>\n    { };\n\n  template<typename _Ptr>\n    struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>>\n    {\n      using element_type = typename _Ptr::element_type;\n\n      static _Ptr\n      pointer_to(__make_not_void<element_type>& __e)\n      { return _Ptr::pointer_to(__e); }\n    };\n\n  /**\n   * @brief  Uniform interface to all pointer-like types\n   * @ingroup pointer_abstractions\n  */\n  template<typename _Ptr>\n    struct pointer_traits : __ptr_traits_elem<_Ptr>\n    {\n    private:\n      template<typename _Tp>\n\tusing __difference_type = typename _Tp::difference_type;\n\n      template<typename _Tp, typename _Up, typename = void>\n\tstruct __rebind : __replace_first_arg<_Tp, _Up> { };\n\n      template<typename _Tp, typename _Up>\n\tstruct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>\n\t{ using type = typename _Tp::template rebind<_Up>; };\n\n    public:\n      /// The pointer type.\n      using pointer = _Ptr;\n\n      /// The type used to represent the difference between two pointers.\n      using difference_type\n\t= __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;\n\n      /// A pointer to a different type.\n      template<typename _Up>\n        using rebind = typename __rebind<_Ptr, _Up>::type;\n    };\n\n  /**\n   * @brief  Partial specialization for built-in pointers.\n   * @ingroup pointer_abstractions\n  */\n  template<typename _Tp>\n    struct pointer_traits<_Tp*>\n    {\n      /// The pointer type\n      typedef _Tp* pointer;\n      /// The type pointed to\n      typedef _Tp  element_type;\n      /// Type used to represent the difference between two pointers\n      typedef ptrdiff_t difference_type;\n\n      template<typename _Up>\n        using rebind = _Up*;\n\n      /**\n       *  @brief  Obtain a pointer to an object\n       *  @param  __r  A reference to an object of type @c element_type\n       *  @return @c addressof(__r)\n      */\n      static _GLIBCXX20_CONSTEXPR pointer\n      pointer_to(__make_not_void<element_type>& __r) noexcept\n      { return std::addressof(__r); }\n    };\n\n  /// Convenience alias for rebinding pointers.\n  template<typename _Ptr, typename _Tp>\n    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;\n\n  template<typename _Tp>\n    constexpr _Tp*\n    __to_address(_Tp* __ptr) noexcept\n    {\n      static_assert(!std::is_function<_Tp>::value, \"not a function pointer\");\n      return __ptr;\n    }\n\n#if __cplusplus <= 201703L\n  template<typename _Ptr>\n    constexpr typename std::pointer_traits<_Ptr>::element_type*\n    __to_address(const _Ptr& __ptr)\n    { return std::__to_address(__ptr.operator->()); }\n#else\n\n  template<typename _Ptr>\n    constexpr auto\n    __to_address(const _Ptr& __ptr) noexcept\n    -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))\n    { return std::pointer_traits<_Ptr>::to_address(__ptr); }\n\n  template<typename _Ptr, typename... _None>\n    constexpr auto\n    __to_address(const _Ptr& __ptr, _None...) noexcept\n    {\n      if constexpr (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)\n\treturn std::__to_address(__ptr.base().operator->());\n      else\n\treturn std::__to_address(__ptr.operator->());\n    }\n\n#define __cpp_lib_to_address 201711L\n\n  /**\n   * @brief Obtain address referenced by a pointer to an object\n   * @param __ptr A pointer to an object\n   * @return @c __ptr\n   * @ingroup pointer_abstractions\n  */\n  template<typename _Tp>\n    constexpr _Tp*\n    to_address(_Tp* __ptr) noexcept\n    { return std::__to_address(__ptr); }\n\n  /**\n   * @brief Obtain address referenced by a pointer to an object\n   * @param __ptr A pointer to an object\n   * @return @c pointer_traits<_Ptr>::to_address(__ptr) if that expression is\n             well-formed, otherwise @c to_address(__ptr.operator->())\n   * @ingroup pointer_abstractions\n  */\n  template<typename _Ptr>\n    constexpr auto\n    to_address(const _Ptr& __ptr) noexcept\n    { return std::__to_address(__ptr); }\n#endif // C++2a\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif\n\n#endif\n"}],"crc32":3743394057,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]