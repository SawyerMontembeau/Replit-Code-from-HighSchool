[{"ops":[{"insert":"// nonstandard construct and destroy functions -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/** @file bits/stl_construct.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _STL_CONSTRUCT_H\n#define _STL_CONSTRUCT_H 1\n\n#include <new>\n#include <bits/move.h>\n#include <bits/stl_iterator_base_types.h> // for iterator_traits\n#include <bits/stl_iterator_base_funcs.h> // for advance\n\n/* This file provides the C++17 functions std::destroy_at, std::destroy, and\n * std::destroy_n, and the C++20 function std::construct_at.\n * It also provides std::_Construct, std::_Destroy,and std::_Destroy_n functions\n * which are defined in all standard modes and so can be used in C++98-14 code.\n * The _Destroy functions will dispatch to destroy_at during constant\n * evaluation, because calls to that function are intercepted by the compiler\n * to allow use in constant expressions.\n */\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus >= 201703L\n  template <typename _Tp>\n    _GLIBCXX20_CONSTEXPR inline void\n    destroy_at(_Tp* __location)\n    {\n      if constexpr (__cplusplus > 201703L && is_array_v<_Tp>)\n\t{\n\t  for (auto& __x : *__location)\n\t    std::destroy_at(std::__addressof(__x));\n\t}\n      else\n\t__location->~_Tp();\n    }\n\n#if __cplusplus >= 202002L\n  template<typename _Tp, typename... _Args>\n    constexpr auto\n    construct_at(_Tp* __location, _Args&&... __args)\n    noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))\n    -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))\n    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }\n#endif // C++20\n#endif// C++17\n\n  /**\n   * Constructs an object in existing memory by invoking an allocated\n   * object's constructor with an initializer.\n   */\n#if __cplusplus >= 201103L\n  template<typename _Tp, typename... _Args>\n    _GLIBCXX20_CONSTEXPR\n    inline void\n    _Construct(_Tp* __p, _Args&&... __args)\n    {\n#if __cplusplus >= 202002L && __has_builtin(__builtin_is_constant_evaluated)\n      if (__builtin_is_constant_evaluated())\n\t{\n\t  // Allow std::_Construct to be used in constant expressions.\n\t  std::construct_at(__p, std::forward<_Args>(__args)...);\n\t  return;\n\t}\n#endif\n      ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...);\n    }\n#else\n  template<typename _T1, typename _T2>\n    inline void\n    _Construct(_T1* __p, const _T2& __value)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 402. wrong new expression in [some_]allocator::construct\n      ::new(static_cast<void*>(__p)) _T1(__value);\n    }\n#endif\n\n  template<typename _T1>\n    inline void\n    _Construct_novalue(_T1* __p)\n    { ::new(static_cast<void*>(__p)) _T1; }\n\n  template<typename _ForwardIterator>\n    _GLIBCXX20_CONSTEXPR void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last);\n\n  /**\n   * Destroy the object pointed to by a pointer type.\n   */\n  template<typename _Tp>\n    _GLIBCXX14_CONSTEXPR inline void\n    _Destroy(_Tp* __pointer)\n    {\n#if __cplusplus > 201703L\n      std::destroy_at(__pointer);\n#else\n      __pointer->~_Tp();\n#endif\n    }\n\n  template<bool>\n    struct _Destroy_aux\n    {\n      template<typename _ForwardIterator>\n\tstatic _GLIBCXX20_CONSTEXPR void\n\t__destroy(_ForwardIterator __first, _ForwardIterator __last)\n\t{\n\t  for (; __first != __last; ++__first)\n\t    std::_Destroy(std::__addressof(*__first));\n\t}\n    };\n\n  template<>\n    struct _Destroy_aux<true>\n    {\n      template<typename _ForwardIterator>\n        static void\n        __destroy(_ForwardIterator, _ForwardIterator) { }\n    };\n\n  /**\n   * Destroy a range of objects.  If the value_type of the object has\n   * a trivial destructor, the compiler should optimize all of this\n   * away, otherwise the objects' destructors must be invoked.\n   */\n  template<typename _ForwardIterator>\n    _GLIBCXX20_CONSTEXPR inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n                       _Value_type;\n#if __cplusplus >= 201103L\n      // A deleted destructor is trivial, this ensures we reject such types:\n      static_assert(is_destructible<_Value_type>::value,\n\t\t    \"value type is destructible\");\n#endif\n#if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated\n      if (std::is_constant_evaluated())\n\treturn _Destroy_aux<false>::__destroy(__first, __last);\n#endif\n      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::\n\t__destroy(__first, __last);\n    }\n\n  template<bool>\n    struct _Destroy_n_aux\n    {\n      template<typename _ForwardIterator, typename _Size>\n\tstatic _GLIBCXX20_CONSTEXPR _ForwardIterator\n\t__destroy_n(_ForwardIterator __first, _Size __count)\n\t{\n\t  for (; __count > 0; (void)++__first, --__count)\n\t    std::_Destroy(std::__addressof(*__first));\n\t  return __first;\n\t}\n    };\n\n  template<>\n    struct _Destroy_n_aux<true>\n    {\n      template<typename _ForwardIterator, typename _Size>\n        static _ForwardIterator\n        __destroy_n(_ForwardIterator __first, _Size __count)\n\t{\n\t  std::advance(__first, __count);\n\t  return __first;\n\t}\n    };\n\n  /**\n   * Destroy a range of objects.  If the value_type of the object has\n   * a trivial destructor, the compiler should optimize all of this\n   * away, otherwise the objects' destructors must be invoked.\n   */\n  template<typename _ForwardIterator, typename _Size>\n    _GLIBCXX20_CONSTEXPR inline _ForwardIterator\n    _Destroy_n(_ForwardIterator __first, _Size __count)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::value_type\n                       _Value_type;\n#if __cplusplus >= 201103L\n      // A deleted destructor is trivial, this ensures we reject such types:\n      static_assert(is_destructible<_Value_type>::value,\n\t\t    \"value type is destructible\");\n#endif\n#if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated\n      if (std::is_constant_evaluated())\n\treturn _Destroy_n_aux<false>::__destroy_n(__first, __count);\n#endif\n      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::\n\t__destroy_n(__first, __count);\n    }\n\n#if __cplusplus >= 201703L\n  template <typename _ForwardIterator>\n    _GLIBCXX20_CONSTEXPR inline void\n    destroy(_ForwardIterator __first, _ForwardIterator __last)\n    {\n      std::_Destroy(__first, __last);\n    }\n\n  template <typename _ForwardIterator, typename _Size>\n    _GLIBCXX20_CONSTEXPR inline _ForwardIterator\n    destroy_n(_ForwardIterator __first, _Size __count)\n    {\n      return std::_Destroy_n(__first, __count);\n    }\n#endif // C++17\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif /* _STL_CONSTRUCT_H */\n"}],"crc32":974020834,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]