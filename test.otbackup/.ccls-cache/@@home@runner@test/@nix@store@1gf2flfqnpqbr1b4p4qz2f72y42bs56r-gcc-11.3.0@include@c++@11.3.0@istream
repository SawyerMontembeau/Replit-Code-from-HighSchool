[{"ops":[{"insert":"// Input streams -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n//\n// ISO C++ 14882: 27.6.1  Input streams\n//\n\n/** @file include/istream\n *  This is a Standard C++ Library header.\n */\n\n#ifndef _GLIBCXX_ISTREAM\n#define _GLIBCXX_ISTREAM 1\n\n#pragma GCC system_header\n\n#include <ios>\n#include <ostream>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @brief  Template class basic_istream.\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *\n   *  This is the base class for all input streams.  It provides text\n   *  formatting of all builtin types, and communicates with any class\n   *  derived from basic_streambuf to do the actual input.\n  */\n  template<typename _CharT, typename _Traits>\n    class basic_istream : virtual public basic_ios<_CharT, _Traits>\n    {\n    public:\n      // Types (inherited from basic_ios (27.4.4)):\n      typedef _CharT\t\t\t \t\tchar_type;\n      typedef typename _Traits::int_type \t\tint_type;\n      typedef typename _Traits::pos_type \t\tpos_type;\n      typedef typename _Traits::off_type \t\toff_type;\n      typedef _Traits\t\t\t \t\ttraits_type;\n\n      // Non-standard Types:\n      typedef basic_streambuf<_CharT, _Traits> \t\t__streambuf_type;\n      typedef basic_ios<_CharT, _Traits>\t\t__ios_type;\n      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >\n \t\t\t\t\t\t\t__num_get_type;\n      typedef ctype<_CharT>\t      \t\t\t__ctype_type;\n\n    protected:\n      // Data Members:\n      /**\n       *  The number of characters extracted in the previous unformatted\n       *  function; see gcount().\n      */\n      streamsize \t\t_M_gcount;\n\n    public:\n      /**\n       *  @brief  Base constructor.\n       *\n       *  This ctor is almost never called by the user directly, rather from\n       *  derived classes' initialization lists, which pass a pointer to\n       *  their own stream buffer.\n      */\n      explicit\n      basic_istream(__streambuf_type* __sb)\n      : _M_gcount(streamsize(0))\n      { this->init(__sb); }\n\n      /**\n       *  @brief  Base destructor.\n       *\n       *  This does very little apart from providing a virtual base dtor.\n      */\n      virtual\n      ~basic_istream()\n      { _M_gcount = streamsize(0); }\n\n      /// Safe prefix/suffix operations.\n      class sentry;\n      friend class sentry;\n\n      ///@{\n      /**\n       *  @brief  Interface for manipulators.\n       *\n       *  Manipulators such as @c std::ws and @c std::dec use these\n       *  functions in constructs like\n       *  <code>std::cin >> std::ws</code>.\n       *  For more information, see the iomanip header.\n      */\n      __istream_type&\n      operator>>(__istream_type& (*__pf)(__istream_type&))\n      { return __pf(*this); }\n\n      __istream_type&\n      operator>>(__ios_type& (*__pf)(__ios_type&))\n      {\n\t__pf(*this);\n\treturn *this;\n      }\n\n      __istream_type&\n      operator>>(ios_base& (*__pf)(ios_base&))\n      {\n\t__pf(*this);\n\treturn *this;\n      }\n      ///@}\n\n      ///@{\n      /**\n       *  @name Extractors\n       *\n       *  All the @c operator>> functions (aka <em>formatted input\n       *  functions</em>) have some common behavior.  Each starts by\n       *  constructing a temporary object of type std::basic_istream::sentry\n       *  with the second argument (noskipws) set to false.  This has several\n       *  effects, concluding with the setting of a status flag; see the\n       *  sentry documentation for more.\n       *\n       *  If the sentry status is good, the function tries to extract\n       *  whatever data is appropriate for the type of the argument.\n       *\n       *  If an exception is thrown during extraction, ios_base::badbit\n       *  will be turned on in the stream's error state (without causing an\n       *  ios_base::failure to be thrown) and the original exception will\n       *  be rethrown if badbit is set in the exceptions mask.\n      */\n\n      ///@{\n      /**\n       *  @brief  Integer arithmetic extractors\n       *  @param  __n A variable of builtin integral type.\n       *  @return  @c *this if successful\n       *\n       *  These functions use the stream's current locale (specifically, the\n       *  @c num_get facet) to parse the input data.\n      */\n      __istream_type&\n      operator>>(bool& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(short& __n);\n\n      __istream_type&\n      operator>>(unsigned short& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(int& __n);\n\n      __istream_type&\n      operator>>(unsigned int& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(long& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(unsigned long& __n)\n      { return _M_extract(__n); }\n\n#ifdef _GLIBCXX_USE_LONG_LONG\n      __istream_type&\n      operator>>(long long& __n)\n      { return _M_extract(__n); }\n\n      __istream_type&\n      operator>>(unsigned long long& __n)\n      { return _M_extract(__n); }\n#endif\n      ///@}\n\n      ///@{\n      /**\n       *  @brief  Floating point arithmetic extractors\n       *  @param  __f A variable of builtin floating point type.\n       *  @return  @c *this if successful\n       *\n       *  These functions use the stream's current locale (specifically, the\n       *  @c num_get facet) to parse the input data.\n      */\n      __istream_type&\n      operator>>(float& __f)\n      { return _M_extract(__f); }\n\n      __istream_type&\n      operator>>(double& __f)\n      { return _M_extract(__f); }\n\n      __istream_type&\n      operator>>(long double& __f)\n      { return _M_extract(__f); }\n      ///@}\n\n      /**\n       *  @brief  Basic arithmetic extractors\n       *  @param  __p A variable of pointer type.\n       *  @return  @c *this if successful\n       *\n       *  These functions use the stream's current locale (specifically, the\n       *  @c num_get facet) to parse the input data.\n      */\n      __istream_type&\n      operator>>(void*& __p)\n      { return _M_extract(__p); }\n\n      /**\n       *  @brief  Extracting into another streambuf.\n       *  @param  __sb  A pointer to a streambuf\n       *\n       *  This function behaves like one of the basic arithmetic extractors,\n       *  in that it also constructs a sentry object and has the same error\n       *  handling behavior.\n       *\n       *  If @p __sb is NULL, the stream will set failbit in its error state.\n       *\n       *  Characters are extracted from this stream and inserted into the\n       *  @p __sb streambuf until one of the following occurs:\n       *\n       *  - the input stream reaches end-of-file,\n       *  - insertion into the output buffer fails (in this case, the\n       *    character that would have been inserted is not extracted), or\n       *  - an exception occurs (and in this case is caught)\n       *\n       *  If the function inserts no characters, failbit is set.\n      */\n      __istream_type&\n      operator>>(__streambuf_type* __sb);\n      ///@}\n\n      // [27.6.1.3] unformatted input\n      /**\n       *  @brief  Character counting\n       *  @return  The number of characters extracted by the previous\n       *           unformatted input function dispatched for this stream.\n      */\n      streamsize\n      gcount() const\n      { return _M_gcount; }\n\n      ///@{\n      /**\n       *  @name Unformatted Input Functions\n       *\n       *  All the unformatted input functions have some common behavior.\n       *  Each starts by constructing a temporary object of type\n       *  std::basic_istream::sentry with the second argument (noskipws)\n       *  set to true.  This has several effects, concluding with the\n       *  setting of a status flag; see the sentry documentation for more.\n       *\n       *  If the sentry status is good, the function tries to extract\n       *  whatever data is appropriate for the type of the argument.\n       *\n       *  The number of characters extracted is stored for later retrieval\n       *  by gcount().\n       *\n       *  If an exception is thrown during extraction, ios_base::badbit\n       *  will be turned on in the stream's error state (without causing an\n       *  ios_base::failure to be thrown) and the original exception will\n       *  be rethrown if badbit is set in the exceptions mask.\n      */\n\n      /**\n       *  @brief  Simple extraction.\n       *  @return  A character, or eof().\n       *\n       *  Tries to extract a character.  If none are available, sets failbit\n       *  and returns traits::eof().\n      */\n      int_type\n      get();\n\n      /**\n       *  @brief  Simple extraction.\n       *  @param  __c  The character in which to store data.\n       *  @return  *this\n       *\n       *  Tries to extract a character and store it in @a __c.  If none are\n       *  available, sets failbit and returns traits::eof().\n       *\n       *  @note  This function is not overloaded on signed char and\n       *         unsigned char.\n      */\n      __istream_type&\n      get(char_type& __c);\n\n      /**\n       *  @brief  Simple multiple-character extraction.\n       *  @param  __s  Pointer to an array.\n       *  @param  __n  Maximum number of characters to store in @a __s.\n       *  @param  __delim  A \"stop\" character.\n       *  @return  *this\n       *\n       *  Characters are extracted and stored into @a __s until one of the\n       *  following happens:\n       *\n       *  - @c __n-1 characters are stored\n       *  - the input sequence reaches EOF\n       *  - the next character equals @a __delim, in which case the character\n       *    is not extracted\n       *\n       * If no characters are stored, failbit is set in the stream's error\n       * state.\n       *\n       * In any case, a null character is stored into the next location in\n       * the array.\n       *\n       *  @note  This function is not overloaded on signed char and\n       *         unsigned char.\n      */\n      __istream_type&\n      get(char_type* __s, streamsize __n, char_type __delim);\n\n      /**\n       *  @brief  Simple multiple-character extraction.\n       *  @param  __s  Pointer to an array.\n       *  @param  __n  Maximum number of characters to store in @a s.\n       *  @return  *this\n       *\n       *  Returns @c get(__s,__n,widen(&apos;\\\\n&apos;)).\n      */\n      __istream_type&\n      get(char_type* __s, streamsize __n)\n      { return this->get(__s, __n, this->widen('\\n')); }\n\n      /**\n       *  @brief  Extraction into another streambuf.\n       *  @param  __sb  A streambuf in which to store data.\n       *  @param  __delim  A \"stop\" character.\n       *  @return  *this\n       *\n       *  Characters are extracted and inserted into @a __sb until one of the\n       *  following happens:\n       *\n       *  - the input sequence reaches EOF\n       *  - insertion into the output buffer fails (in this case, the\n       *    character that would have been inserted is not extracted)\n       *  - the next character equals @a __delim (in this case, the character\n       *    is not extracted)\n       *  - an exception occurs (and in this case is caught)\n       *\n       * If no characters are stored, failbit is set in the stream's error\n       * state.\n      */\n      __istream_type&\n      get(__streambuf_type& __sb, char_type __delim);\n\n      /**\n       *  @brief  Extraction into another streambuf.\n       *  @param  __sb  A streambuf in which to store data.\n       *  @return  *this\n       *\n       *  Returns @c get(__sb,widen(&apos;\\\\n&apos;)).\n      */\n      __istream_type&\n      get(__streambuf_type& __sb)\n      { return this->get(__sb, this->widen('\\n')); }\n\n      /**\n       *  @brief  String extraction.\n       *  @param  __s  A character array in which to store the data.\n       *  @param  __n  Maximum number of characters to extract.\n       *  @param  __delim  A \"stop\" character.\n       *  @return  *this\n       *\n       *  Extracts and stores characters into @a __s until one of the\n       *  following happens.  Note that these criteria are required to be\n       *  tested in the order listed here, to allow an input line to exactly\n       *  fill the @a __s array without setting failbit.\n       *\n       *  -# the input sequence reaches end-of-file, in which case eofbit\n       *     is set in the stream error state\n       *  -# the next character equals @c __delim, in which case the character\n       *     is extracted (and therefore counted in @c gcount()) but not stored\n       *  -# @c __n-1 characters are stored, in which case failbit is set\n       *     in the stream error state\n       *\n       *  If no characters are extracted, failbit is set.  (An empty line of\n       *  input should therefore not cause failbit to be set.)\n       *\n       *  In any case, a null character is stored in the next location in\n       *  the array.\n      */\n      __istream_type&\n      getline(char_type* __s, streamsize __n, char_type __delim);\n\n      /**\n       *  @brief  String extraction.\n       *  @param  __s  A character array in which to store the data.\n       *  @param  __n  Maximum number of characters to extract.\n       *  @return  *this\n       *\n       *  Returns @c getline(__s,__n,widen(&apos;\\\\n&apos;)).\n      */\n      __istream_type&\n      getline(char_type* __s, streamsize __n)\n      { return this->getline(__s, __n, this->widen('\\n')); }\n\n      /**\n       *  @brief  Discarding characters\n       *  @param  __n  Number of characters to discard.\n       *  @param  __delim  A \"stop\" character.\n       *  @return  *this\n       *\n       *  Extracts characters and throws them away until one of the\n       *  following happens:\n       *  - if @a __n @c != @c std::numeric_limits<int>::max(), @a __n\n       *    characters are extracted\n       *  - the input sequence reaches end-of-file\n       *  - the next character equals @a __delim (in this case, the character\n       *    is extracted); note that this condition will never occur if\n       *    @a __delim equals @c traits::eof().\n       *\n       *  NB: Provide three overloads, instead of the single function\n       *  (with defaults) mandated by the Standard: this leads to a\n       *  better performing implementation, while still conforming to\n       *  the Standard.\n      */\n      __istream_type&\n      ignore(streamsize __n, int_type __delim);\n\n      __istream_type&\n      ignore(streamsize __n);\n\n      __istream_type&\n      ignore();\n\n      /**\n       *  @brief  Looking ahead in the stream\n       *  @return  The next character, or eof().\n       *\n       *  If, after constructing the sentry object, @c good() is false,\n       *  returns @c traits::eof().  Otherwise reads but does not extract\n       *  the next input character.\n      */\n      int_type\n      peek();\n\n      /**\n       *  @brief  Extraction without delimiters.\n       *  @param  __s  A character array.\n       *  @param  __n  Maximum number of characters to store.\n       *  @return  *this\n       *\n       *  If the stream state is @c good(), extracts characters and stores\n       *  them into @a __s until one of the following happens:\n       *  - @a __n characters are stored\n       *  - the input sequence reaches end-of-file, in which case the error\n       *    state is set to @c failbit|eofbit.\n       *\n       *  @note  This function is not overloaded on signed char and\n       *         unsigned char.\n      */\n      __istream_type&\n      read(char_type* __s, streamsize __n);\n\n      /**\n       *  @brief  Extraction until the buffer is exhausted, but no more.\n       *  @param  __s  A character array.\n       *  @param  __n  Maximum number of characters to store.\n       *  @return  The number of characters extracted.\n       *\n       *  Extracts characters and stores them into @a __s depending on the\n       *  number of characters remaining in the streambuf's buffer,\n       *  @c rdbuf()->in_avail(), called @c A here:\n       *  - if @c A @c == @c -1, sets eofbit and extracts no characters\n       *  - if @c A @c == @c 0, extracts no characters\n       *  - if @c A @c > @c 0, extracts @c min(A,n)\n       *\n       *  The goal is to empty the current buffer, and to not request any\n       *  more from the external input sequence controlled by the streambuf.\n      */\n      streamsize\n      readsome(char_type* __s, streamsize __n);\n\n      /**\n       *  @brief  Unextracting a single character.\n       *  @param  __c  The character to push back into the input stream.\n       *  @return  *this\n       *\n       *  If @c rdbuf() is not null, calls @c rdbuf()->sputbackc(c).\n       *\n       *  If @c rdbuf() is null or if @c sputbackc() fails, sets badbit in\n       *  the error state.\n       *\n       *  @note  This function first clears eofbit.  Since no characters\n       *         are extracted, the next call to @c gcount() will return 0,\n       *         as required by DR 60.\n      */\n      __istream_type&\n      putback(char_type __c);\n\n      /**\n       *  @brief  Unextracting the previous character.\n       *  @return  *this\n       *\n       *  If @c rdbuf() is not null, calls @c rdbuf()->sungetc(c).\n       *\n       *  If @c rdbuf() is null or if @c sungetc() fails, sets badbit in\n       *  the error state.\n       *\n       *  @note  This function first clears eofbit.  Since no characters\n       *         are extracted, the next call to @c gcount() will return 0,\n       *         as required by DR 60.\n      */\n      __istream_type&\n      unget();\n\n      /**\n       *  @brief  Synchronizing the stream buffer.\n       *  @return  0 on success, -1 on failure\n       *\n       *  If @c rdbuf() is a null pointer, returns -1.\n       *\n       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,\n       *  sets badbit and returns -1.\n       *\n       *  Otherwise, returns 0.\n       *\n       *  @note  This function does not count the number of characters\n       *         extracted, if any, and therefore does not affect the next\n       *         call to @c gcount().\n      */\n      int\n      sync();\n\n      /**\n       *  @brief  Getting the current read position.\n       *  @return  A file position object.\n       *\n       *  If @c fail() is not false, returns @c pos_type(-1) to indicate\n       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,in).\n       *\n       *  @note  This function does not count the number of characters\n       *         extracted, if any, and therefore does not affect the next\n       *         call to @c gcount().  At variance with putback, unget and\n       *         seekg, eofbit is not cleared first.\n      */\n      pos_type\n      tellg();\n\n      /**\n       *  @brief  Changing the current read position.\n       *  @param  __pos  A file position object.\n       *  @return  *this\n       *\n       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(__pos).  If\n       *  that function fails, sets failbit.\n       *\n       *  @note  This function first clears eofbit.  It does not count the\n       *         number of characters extracted, if any, and therefore does\n       *         not affect the next call to @c gcount().\n      */\n      __istream_type&\n      seekg(pos_type);\n\n      /**\n       *  @brief  Changing the current read position.\n       *  @param  __off  A file offset object.\n       *  @param  __dir  The direction in which to seek.\n       *  @return  *this\n       *\n       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(__off,__dir).\n       *  If that function fails, sets failbit.\n       *\n       *  @note  This function first clears eofbit.  It does not count the\n       *         number of characters extracted, if any, and therefore does\n       *         not affect the next call to @c gcount().\n      */\n      __istream_type&\n      seekg(off_type, ios_base::seekdir);\n      ///@}\n\n    protected:\n      basic_istream()\n      : _M_gcount(streamsize(0))\n      { this->init(0); }\n\n#if __cplusplus >= 201103L\n      basic_istream(const basic_istream&) = delete;\n\n      basic_istream(basic_istream&& __rhs)\n      : __ios_type(), _M_gcount(__rhs._M_gcount)\n      {\n\t__ios_type::move(__rhs);\n\t__rhs._M_gcount = 0;\n      }\n\n      // 27.7.3.3 Assign/swap\n\n      basic_istream& operator=(const basic_istream&) = delete;\n\n      basic_istream&\n      operator=(basic_istream&& __rhs)\n      {\n\tswap(__rhs);\n\treturn *this;\n      }\n\n      void\n      swap(basic_istream& __rhs)\n      {\n\t__ios_type::swap(__rhs);\n\tstd::swap(_M_gcount, __rhs._M_gcount);\n      }\n#endif\n\n      template<typename _ValueT>\n\t__istream_type&\n\t_M_extract(_ValueT& __v);\n    };\n\n  /// Explicit specialization declarations, defined in src/istream.cc.\n  template<>\n    basic_istream<char>&\n    basic_istream<char>::\n    getline(char_type* __s, streamsize __n, char_type __delim);\n\n  template<>\n    basic_istream<char>&\n    basic_istream<char>::\n    ignore(streamsize __n);\n\n  template<>\n    basic_istream<char>&\n    basic_istream<char>::\n    ignore(streamsize __n, int_type __delim);\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  template<>\n    basic_istream<wchar_t>&\n    basic_istream<wchar_t>::\n    getline(char_type* __s, streamsize __n, char_type __delim);\n\n  template<>\n    basic_istream<wchar_t>&\n    basic_istream<wchar_t>::\n    ignore(streamsize __n);\n\n  template<>\n    basic_istream<wchar_t>&\n    basic_istream<wchar_t>::\n    ignore(streamsize __n, int_type __delim);\n#endif\n\n  /**\n   *  @brief  Performs setup work for input streams.\n   *\n   *  Objects of this class are created before all of the standard\n   *  extractors are run.  It is responsible for <em>exception-safe\n   *  prefix and suffix operations,</em> although only prefix actions\n   *  are currently required by the standard.\n  */\n  template<typename _CharT, typename _Traits>\n    class basic_istream<_CharT, _Traits>::sentry\n    {\n      // Data Members.\n      bool _M_ok;\n\n    public:\n      /// Easy access to dependent types.\n      typedef _Traits \t\t\t\t\ttraits_type;\n      typedef basic_streambuf<_CharT, _Traits> \t\t__streambuf_type;\n      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n      typedef typename __istream_type::__ctype_type \t__ctype_type;\n      typedef typename _Traits::int_type\t\t__int_type;\n\n      /**\n       *  @brief  The constructor performs all the work.\n       *  @param  __is  The input stream to guard.\n       *  @param  __noskipws  Whether to consume whitespace or not.\n       *\n       *  If the stream state is good (@a __is.good() is true), then the\n       *  following actions are performed, otherwise the sentry state\n       *  is false (<em>not okay</em>) and failbit is set in the\n       *  stream state.\n       *\n       *  The sentry's preparatory actions are:\n       *\n       *  -# if the stream is tied to an output stream, @c is.tie()->flush()\n       *     is called to synchronize the output sequence\n       *  -# if @a __noskipws is false, and @c ios_base::skipws is set in\n       *     @c is.flags(), the sentry extracts and discards whitespace\n       *     characters from the stream.  The currently imbued locale is\n       *     used to determine whether each character is whitespace.\n       *\n       *  If the stream state is still good, then the sentry state becomes\n       *  true (@a okay).\n      */\n      explicit\n      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);\n\n      /**\n       *  @brief  Quick status checking.\n       *  @return  The sentry state.\n       *\n       *  For ease of use, sentries may be converted to booleans.  The\n       *  return value is that of the sentry state (true == okay).\n      */\n#if __cplusplus >= 201103L\n      explicit\n#endif\n      operator bool() const\n      { return _M_ok; }\n    };\n\n  ///@{\n  /**\n   *  @brief  Character extractors\n   *  @param  __in  An input stream.\n   *  @param  __c  A character reference.\n   *  @return  in\n   *\n   *  Behaves like one of the formatted arithmetic extractors described in\n   *  std::basic_istream.  After constructing a sentry object with good\n   *  status, this function extracts a character (if one is available) and\n   *  stores it in @a __c.  Otherwise, sets failbit in the input stream.\n  */\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);\n\n  template<class _Traits>\n    inline basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)\n    { return (__in >> reinterpret_cast<char&>(__c)); }\n\n  template<class _Traits>\n    inline basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)\n    { return (__in >> reinterpret_cast<char&>(__c)); }\n  ///@}\n\n\n  template<typename _CharT, typename _Traits>\n    void\n    __istream_extract(basic_istream<_CharT, _Traits>&, _CharT*, streamsize);\n\n  void __istream_extract(istream&, char*, streamsize);\n\n  ///@{\n  /**\n   *  @brief  Character string extractors\n   *  @param  __in  An input stream.\n   *  @param  __s  A character array (or a pointer to an array before C++20).\n   *  @return  __in\n   *\n   *  Behaves like one of the formatted arithmetic extractors described in\n   *  `std::basic_istream`.  After constructing a sentry object with good\n   *  status, this function extracts up to `n` characters and stores them\n   *  into the array `__s`.  `n` is defined as:\n   *\n   *  - if `width()` is greater than zero, `n` is `min(width(), n)`\n   *  - otherwise `n` is the number of elements of the array\n   *  - (before C++20 the pointer is assumed to point to an array of\n   *  - the largest possible size for an array of `char_type`).\n   *\n   *  Characters are extracted and stored until one of the following happens:\n   *  - `n - 1` characters are stored\n   *  - EOF is reached\n   *  - the next character is whitespace according to the current locale\n   *\n   *  `width(0)` is then called for the input stream.\n   *\n   *  If no characters are extracted, sets failbit.\n  */\n\n#if __cplusplus <= 201703L\n  template<typename _CharT, typename _Traits>\n    __attribute__((__nonnull__(2), __access__(__write_only__, 2)))\n    inline basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)\n    {\n      size_t __n = __builtin_object_size(__s, 0);\n      if (__builtin_expect(__n < sizeof(_CharT), false))\n\t{\n\t  // There is not even space for the required null terminator.\n\t  __glibcxx_assert(__n >= sizeof(_CharT));\n\t  __in.width(0);\n\t  __in.setstate(ios_base::failbit);\n\t}\n      else\n\t{\n\t  if (__n == (size_t)-1)\n\t    __n = __gnu_cxx::__numeric_traits<streamsize>::__max;\n\t  std::__istream_extract(__in, __s, __n / sizeof(_CharT));\n\t}\n      return __in;\n    }\n\n  template<class _Traits>\n    __attribute__((__nonnull__(2), __access__(__write_only__, 2)))\n    inline basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)\n    { return __in >> reinterpret_cast<char*>(__s); }\n\n  template<class _Traits>\n    __attribute__((__nonnull__(2), __access__(__write_only__, 2)))\n    inline basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)\n    { return __in >> reinterpret_cast<char*>(__s); }\n#else\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2499. operator>>(istream&, char*) makes it hard to avoid buffer overflows\n  template<typename _CharT, typename _Traits, size_t _Num>\n    inline basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT (&__s)[_Num])\n    {\n      static_assert(_Num <= __gnu_cxx::__numeric_traits<streamsize>::__max);\n      std::__istream_extract(__in, __s, _Num);\n      return __in;\n    }\n\n  template<class _Traits, size_t _Num>\n    inline basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, unsigned char (&__s)[_Num])\n    { return __in >> reinterpret_cast<char(&)[_Num]>(__s); }\n\n  template<class _Traits, size_t _Num>\n    inline basic_istream<char, _Traits>&\n    operator>>(basic_istream<char, _Traits>& __in, signed char (&__s)[_Num])\n    { return __in >> reinterpret_cast<char(&)[_Num]>(__s); }\n#endif\n  ///@}\n\n  /**\n   *  @brief  Template class basic_iostream\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *\n   *  This class multiply inherits from the input and output stream classes\n   *  simply to provide a single interface.\n  */\n  template<typename _CharT, typename _Traits>\n    class basic_iostream\n    : public basic_istream<_CharT, _Traits>,\n      public basic_ostream<_CharT, _Traits>\n    {\n    public:\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 271. basic_iostream missing typedefs\n      // Types (inherited):\n      typedef _CharT\t\t\t \t\tchar_type;\n      typedef typename _Traits::int_type \t\tint_type;\n      typedef typename _Traits::pos_type \t\tpos_type;\n      typedef typename _Traits::off_type \t\toff_type;\n      typedef _Traits\t\t\t \t\ttraits_type;\n\n      // Non-standard Types:\n      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n      typedef basic_ostream<_CharT, _Traits>\t\t__ostream_type;\n\n      /**\n       *  @brief  Constructor does nothing.\n       *\n       *  Both of the parent classes are initialized with the same\n       *  streambuf pointer passed to this constructor.\n      */\n      explicit\n      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)\n      : __istream_type(__sb), __ostream_type(__sb) { }\n\n      /**\n       *  @brief  Destructor does nothing.\n      */\n      virtual\n      ~basic_iostream() { }\n\n    protected:\n      basic_iostream()\n      : __istream_type(), __ostream_type() { }\n\n#if __cplusplus >= 201103L\n      basic_iostream(const basic_iostream&) = delete;\n\n      basic_iostream(basic_iostream&& __rhs)\n      : __istream_type(std::move(__rhs)), __ostream_type(*this)\n      { }\n\n      // 27.7.3.3 Assign/swap\n\n      basic_iostream& operator=(const basic_iostream&) = delete;\n\n      basic_iostream&\n      operator=(basic_iostream&& __rhs)\n      {\n\tswap(__rhs);\n\treturn *this;\n      }\n\n      void\n      swap(basic_iostream& __rhs)\n      { __istream_type::swap(__rhs); }\n#endif\n    };\n\n  /**\n   *  @brief  Quick and easy way to eat whitespace\n   *\n   *  This manipulator extracts whitespace characters, stopping when the\n   *  next character is non-whitespace, or when the input sequence is empty.\n   *  If the sequence is empty, @c eofbit is set in the stream, but not\n   *  @c failbit.\n   *\n   *  The current locale is used to distinguish whitespace characters.\n   *\n   *  Example:\n   *  @code\n   *     MyClass   mc;\n   *\n   *     std::cin >> std::ws >> mc;\n   *  @endcode\n   *  will skip leading whitespace before calling operator>> on cin and your\n   *  object.  Note that the same effect can be achieved by creating a\n   *  std::basic_istream::sentry inside your definition of operator>>.\n  */\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    ws(basic_istream<_CharT, _Traits>& __is);\n\n#if __cplusplus >= 201103L\n  // C++11 27.7.2.6 Rvalue stream extraction [istream.rvalue]\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2328. Rvalue stream extraction should use perfect forwarding\n  // 1203. More useful rvalue stream insertion\n\n#if __cpp_lib_concepts\n  template<typename _Is, typename _Tp>\n    requires __derived_from_ios_base<_Is>\n      && requires (_Is& __is, _Tp&& __t) { __is >> std::forward<_Tp>(__t); }\n    using __rvalue_stream_extraction_t = _Is&&;\n#else\n  template<typename _Is, typename _Tp,\n\t   typename = _Require_derived_from_ios_base<_Is>,\n\t   typename = decltype(std::declval<_Is&>() >> std::declval<_Tp>())>\n    using __rvalue_stream_extraction_t = _Is&&;\n#endif\n\n  /**\n   *  @brief  Generic extractor for rvalue stream\n   *  @param  __is  An input stream.\n   *  @param  __x  A reference to the extraction target.\n   *  @return  __is\n   *\n   *  This is just a forwarding function to allow extraction from\n   *  rvalue streams since they won't bind to the extractor functions\n   *  that take an lvalue reference.\n  */\n  template<typename _Istream, typename _Tp>\n    inline __rvalue_stream_extraction_t<_Istream, _Tp>\n    operator>>(_Istream&& __is, _Tp&& __x)\n    {\n      __is >> std::forward<_Tp>(__x);\n      return std::move(__is);\n    }\n#endif // C++11\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#include <bits/istream.tcc>\n\n#endif\t/* _GLIBCXX_ISTREAM */\n"}],"crc32":730045539,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]