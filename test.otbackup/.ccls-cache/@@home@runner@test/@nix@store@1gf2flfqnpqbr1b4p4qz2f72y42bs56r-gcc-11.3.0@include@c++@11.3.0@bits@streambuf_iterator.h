[{"ops":[{"insert":"// Streambuf iterators\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/streambuf_iterator.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{iterator}\n */\n\n#ifndef _STREAMBUF_ITERATOR_H\n#define _STREAMBUF_ITERATOR_H 1\n\n#pragma GCC system_header\n\n#include <streambuf>\n#include <debug/debug.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   * @addtogroup iterators\n   * @{\n   */\n\n  // 24.5.3 Template class istreambuf_iterator\n  /// Provides input iterator semantics for streambufs.\n  template<typename _CharT, typename _Traits>\n    class istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,\n\t\t      _CharT*, _CharT>\n    {\n    public:\n      // Types:\n      ///@{\n      /// Public typedefs\n#if __cplusplus < 201103L\n      typedef _CharT& reference; // Changed to _CharT by LWG 445\n#elif __cplusplus > 201703L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3188. istreambuf_iterator::pointer should not be unspecified\n      using pointer = void;\n#endif\n\n      typedef _CharT\t\t\t\t\tchar_type;\n      typedef _Traits\t\t\t\t\ttraits_type;\n      typedef typename _Traits::int_type\t\tint_type;\n      typedef basic_streambuf<_CharT, _Traits>\t\tstreambuf_type;\n      typedef basic_istream<_CharT, _Traits>\t\tistream_type;\n      ///@}\n\n      template<typename _CharT2>\n\tfriend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n\t\t\t\t    ostreambuf_iterator<_CharT2> >::__type\n\tcopy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,\n\t     ostreambuf_iterator<_CharT2>);\n\n      template<bool _IsMove, typename _CharT2>\n\tfriend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n\t\t\t\t\t       _CharT2*>::__type\n\t__copy_move_a2(istreambuf_iterator<_CharT2>,\n\t\t       istreambuf_iterator<_CharT2>, _CharT2*);\n\n      template<typename _CharT2, typename _Size>\n\tfriend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n\t\t\t\t\t       _CharT2*>::__type\n\t__copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2*, bool);\n\n      template<typename _CharT2>\n\tfriend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n\t\t\t\t    istreambuf_iterator<_CharT2> >::__type\n\tfind(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,\n\t     const _CharT2&);\n\n      template<typename _CharT2, typename _Distance>\n\tfriend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n\t\t\t\t\t       void>::__type\n\tadvance(istreambuf_iterator<_CharT2>&, _Distance);\n\n    private:\n      // 24.5.3 istreambuf_iterator\n      // p 1\n      // If the end of stream is reached (streambuf_type::sgetc()\n      // returns traits_type::eof()), the iterator becomes equal to\n      // the \"end of stream\" iterator value.\n      // NB: This implementation assumes the \"end of stream\" value\n      // is EOF, or -1.\n      mutable streambuf_type*\t_M_sbuf;\n      int_type\t\t\t_M_c;\n\n    public:\n      ///  Construct end of input stream iterator.\n      _GLIBCXX_CONSTEXPR istreambuf_iterator() _GLIBCXX_USE_NOEXCEPT\n      : _M_sbuf(0), _M_c(traits_type::eof()) { }\n\n#if __cplusplus > 201703L && __cpp_lib_concepts\n      constexpr istreambuf_iterator(default_sentinel_t) noexcept\n      : istreambuf_iterator() { }\n#endif\n\n#if __cplusplus >= 201103L\n      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;\n\n      ~istreambuf_iterator() = default;\n#endif\n\n      ///  Construct start of input stream iterator.\n      istreambuf_iterator(istream_type& __s) _GLIBCXX_USE_NOEXCEPT\n      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }\n\n      ///  Construct start of streambuf iterator.\n      istreambuf_iterator(streambuf_type* __s) _GLIBCXX_USE_NOEXCEPT\n      : _M_sbuf(__s), _M_c(traits_type::eof()) { }\n\n#if __cplusplus >= 201103L\n      istreambuf_iterator&\n      operator=(const istreambuf_iterator&) noexcept = default;\n#endif\n\n      ///  Return the current character pointed to by iterator.  This returns\n      ///  streambuf.sgetc().  It cannot be assigned.  NB: The result of\n      ///  operator*() on an end of stream is undefined.\n      char_type\n      operator*() const\n      {\n\tint_type __c = _M_get();\n\n#ifdef _GLIBCXX_DEBUG_PEDANTIC\n\t// Dereferencing a past-the-end istreambuf_iterator is a\n\t// libstdc++ extension\n\t__glibcxx_requires_cond(!_S_is_eof(__c),\n\t\t\t\t_M_message(__gnu_debug::__msg_deref_istreambuf)\n\t\t\t\t._M_iterator(*this));\n#endif\n\treturn traits_type::to_char_type(__c);\n      }\n\n      /// Advance the iterator.  Calls streambuf.sbumpc().\n      istreambuf_iterator&\n      operator++()\n      {\n\t__glibcxx_requires_cond(_M_sbuf &&\n\t\t\t\t(!_S_is_eof(_M_c) || !_S_is_eof(_M_sbuf->sgetc())),\n\t\t\t\t_M_message(__gnu_debug::__msg_inc_istreambuf)\n\t\t\t\t._M_iterator(*this));\n\n\t_M_sbuf->sbumpc();\n\t_M_c = traits_type::eof();\n\treturn *this;\n      }\n\n      /// Advance the iterator.  Calls streambuf.sbumpc().\n      istreambuf_iterator\n      operator++(int)\n      {\n\t__glibcxx_requires_cond(_M_sbuf &&\n\t\t\t\t(!_S_is_eof(_M_c) || !_S_is_eof(_M_sbuf->sgetc())),\n\t\t\t\t_M_message(__gnu_debug::__msg_inc_istreambuf)\n\t\t\t\t._M_iterator(*this));\n\n\tistreambuf_iterator __old = *this;\n\t__old._M_c = _M_sbuf->sbumpc();\n\t_M_c = traits_type::eof();\n\treturn __old;\n      }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 110 istreambuf_iterator::equal not const\n      // NB: there is also number 111 (NAD) relevant to this function.\n      /// Return true both iterators are end or both are not end.\n      bool\n      equal(const istreambuf_iterator& __b) const\n      { return _M_at_eof() == __b._M_at_eof(); }\n\n    private:\n      int_type\n      _M_get() const\n      {\n\tint_type __ret = _M_c;\n\tif (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))\n\t  _M_sbuf = 0;\n\treturn __ret;\n      }\n\n      bool\n      _M_at_eof() const\n      { return _S_is_eof(_M_get()); }\n\n      static bool\n      _S_is_eof(int_type __c)\n      {\n\tconst int_type __eof = traits_type::eof();\n\treturn traits_type::eq_int_type(__c, __eof);\n      }\n\n#if __cplusplus > 201703L && __cpp_lib_concepts\n      friend bool\n      operator==(const istreambuf_iterator& __i, default_sentinel_t __s)\n      { return __i._M_at_eof(); }\n#endif\n    };\n\n  template<typename _CharT, typename _Traits>\n    inline bool\n    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,\n\t       const istreambuf_iterator<_CharT, _Traits>& __b)\n    { return __a.equal(__b); }\n\n  template<typename _CharT, typename _Traits>\n    inline bool\n    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,\n\t       const istreambuf_iterator<_CharT, _Traits>& __b)\n    { return !__a.equal(__b); }\n\n  /// Provides output iterator semantics for streambufs.\n  template<typename _CharT, typename _Traits>\n    class ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n    {\n    public:\n      // Types:\n      ///@{\n      /// Public typedefs\n#if __cplusplus > 201703L\n      using difference_type = ptrdiff_t;\n#endif\n      typedef _CharT\t\t\t       char_type;\n      typedef _Traits\t\t\t       traits_type;\n      typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n      typedef basic_ostream<_CharT, _Traits>   ostream_type;\n      ///@}\n\n      template<typename _CharT2>\n\tfriend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n\t\t\t\t    ostreambuf_iterator<_CharT2> >::__type\n\tcopy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,\n\t     ostreambuf_iterator<_CharT2>);\n\n    private:\n      streambuf_type*\t_M_sbuf;\n      bool\t\t_M_failed;\n\n    public:\n\n#if __cplusplus > 201703L\n      constexpr\n      ostreambuf_iterator() noexcept\n      : _M_sbuf(nullptr), _M_failed(true) { }\n#endif\n\n      ///  Construct output iterator from ostream.\n      ostreambuf_iterator(ostream_type& __s) _GLIBCXX_USE_NOEXCEPT\n      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n\n      ///  Construct output iterator from streambuf.\n      ostreambuf_iterator(streambuf_type* __s) _GLIBCXX_USE_NOEXCEPT\n      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }\n\n      ///  Write character to streambuf.  Calls streambuf.sputc().\n      ostreambuf_iterator&\n      operator=(_CharT __c)\n      {\n\tif (!_M_failed &&\n\t    _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))\n\t  _M_failed = true;\n\treturn *this;\n      }\n\n      /// Return *this.\n      ostreambuf_iterator&\n      operator*()\n      { return *this; }\n\n      /// Return *this.\n      ostreambuf_iterator&\n      operator++(int)\n      { return *this; }\n\n      /// Return *this.\n      ostreambuf_iterator&\n      operator++()\n      { return *this; }\n\n      /// Return true if previous operator=() failed.\n      bool\n      failed() const _GLIBCXX_USE_NOEXCEPT\n      { return _M_failed; }\n\n      ostreambuf_iterator&\n      _M_put(const _CharT* __ws, streamsize __len)\n      {\n\tif (__builtin_expect(!_M_failed, true)\n\t    && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,\n\t\t\t\tfalse))\n\t  _M_failed = true;\n\treturn *this;\n      }\n    };\n\n  // Overloads for streambuf iterators.\n  template<typename _CharT>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t\t\t\t    ostreambuf_iterator<_CharT> >::__type\n    copy(istreambuf_iterator<_CharT> __first,\n\t istreambuf_iterator<_CharT> __last,\n\t ostreambuf_iterator<_CharT> __result)\n    {\n      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)\n\t{\n\t  bool __ineof;\n\t  __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);\n\t  if (!__ineof)\n\t    __result._M_failed = true;\n\t}\n      return __result;\n    }\n\n  template<bool _IsMove, typename _CharT>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t\t\t\t    ostreambuf_iterator<_CharT> >::__type\n    __copy_move_a2(_CharT* __first, _CharT* __last,\n\t\t   ostreambuf_iterator<_CharT> __result)\n    {\n      const streamsize __num = __last - __first;\n      if (__num > 0)\n\t__result._M_put(__first, __num);\n      return __result;\n    }\n\n  template<bool _IsMove, typename _CharT>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t\t\t\t    ostreambuf_iterator<_CharT> >::__type\n    __copy_move_a2(const _CharT* __first, const _CharT* __last,\n\t\t   ostreambuf_iterator<_CharT> __result)\n    {\n      const streamsize __num = __last - __first;\n      if (__num > 0)\n\t__result._M_put(__first, __num);\n      return __result;\n    }\n\n  template<bool _IsMove, typename _CharT>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t\t\t\t    _CharT*>::__type\n    __copy_move_a2(istreambuf_iterator<_CharT> __first,\n\t\t   istreambuf_iterator<_CharT> __last, _CharT* __result)\n    {\n      typedef istreambuf_iterator<_CharT>\t\t   __is_iterator_type;\n      typedef typename __is_iterator_type::traits_type\t   traits_type;\n      typedef typename __is_iterator_type::streambuf_type  streambuf_type;\n      typedef typename traits_type::int_type\t\t   int_type;\n\n      if (__first._M_sbuf && !__last._M_sbuf)\n\t{\n\t  streambuf_type* __sb = __first._M_sbuf;\n\t  int_type __c = __sb->sgetc();\n\t  while (!traits_type::eq_int_type(__c, traits_type::eof()))\n\t    {\n\t      const streamsize __n = __sb->egptr() - __sb->gptr();\n\t      if (__n > 1)\n\t\t{\n\t\t  traits_type::copy(__result, __sb->gptr(), __n);\n\t\t  __sb->__safe_gbump(__n);\n\t\t  __result += __n;\n\t\t  __c = __sb->underflow();\n\t\t}\n\t      else\n\t\t{\n\t\t  *__result++ = traits_type::to_char_type(__c);\n\t\t  __c = __sb->snextc();\n\t\t}\n\t    }\n\t}\n      return __result;\n    }\n\n  template<typename _CharT, typename _Size>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t\t\t\t    _CharT*>::__type\n    __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT* __result,\n\t       bool __strict __attribute__((__unused__)))\n    {\n      if (__n == 0)\n\treturn __result;\n\n      __glibcxx_requires_cond(__it._M_sbuf,\n\t\t\t      _M_message(__gnu_debug::__msg_inc_istreambuf)\n\t\t\t      ._M_iterator(__it));\n      _CharT* __beg = __result;\n      __result += __it._M_sbuf->sgetn(__beg, __n);\n      __glibcxx_requires_cond(!__strict || __result - __beg == __n,\n\t\t\t      _M_message(__gnu_debug::__msg_inc_istreambuf)\n\t\t\t      ._M_iterator(__it));\n      return __result;\n    }\n\n  template<typename _CharT>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t\t  \t\t    istreambuf_iterator<_CharT> >::__type\n    find(istreambuf_iterator<_CharT> __first,\n\t istreambuf_iterator<_CharT> __last, const _CharT& __val)\n    {\n      typedef istreambuf_iterator<_CharT>\t\t   __is_iterator_type;\n      typedef typename __is_iterator_type::traits_type     traits_type;\n      typedef typename __is_iterator_type::streambuf_type  streambuf_type;\n      typedef typename traits_type::int_type\t\t   int_type;\n      const int_type __eof = traits_type::eof();\n\n      if (__first._M_sbuf && !__last._M_sbuf)\n\t{\n\t  const int_type __ival = traits_type::to_int_type(__val);\n\t  streambuf_type* __sb = __first._M_sbuf;\n\t  int_type __c = __sb->sgetc();\n\t  while (!traits_type::eq_int_type(__c, __eof)\n\t\t && !traits_type::eq_int_type(__c, __ival))\n\t    {\n\t      streamsize __n = __sb->egptr() - __sb->gptr();\n\t      if (__n > 1)\n\t\t{\n\t\t  const _CharT* __p = traits_type::find(__sb->gptr(),\n\t\t\t\t\t\t\t__n, __val);\n\t\t  if (__p)\n\t\t    __n = __p - __sb->gptr();\n\t\t  __sb->__safe_gbump(__n);\n\t\t  __c = __sb->sgetc();\n\t\t}\n\t      else\n\t\t__c = __sb->snextc();\n\t    }\n\n\t  __first._M_c = __eof;\n\t}\n\n      return __first;\n    }\n\n  template<typename _CharT, typename _Distance>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t\t\t\t    void>::__type\n    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)\n    {\n      if (__n == 0)\n\treturn;\n\n      __glibcxx_assert(__n > 0);\n      __glibcxx_requires_cond(!__i._M_at_eof(),\n\t\t\t      _M_message(__gnu_debug::__msg_inc_istreambuf)\n\t\t\t      ._M_iterator(__i));\n\n      typedef istreambuf_iterator<_CharT>\t\t   __is_iterator_type;\n      typedef typename __is_iterator_type::traits_type\t   traits_type;\n      typedef typename __is_iterator_type::streambuf_type  streambuf_type;\n      typedef typename traits_type::int_type\t\t   int_type;\n      const int_type __eof = traits_type::eof();\n\n      streambuf_type* __sb = __i._M_sbuf;\n      while (__n > 0)\n\t{\n\t  streamsize __size = __sb->egptr() - __sb->gptr();\n\t  if (__size > __n)\n\t    {\n\t      __sb->__safe_gbump(__n);\n\t      break;\n\t    }\n\n\t  __sb->__safe_gbump(__size);\n\t  __n -= __size;\n\t  if (traits_type::eq_int_type(__sb->underflow(), __eof))\n\t    {\n\t      __glibcxx_requires_cond(__n == 0,\n\t\t\t\t_M_message(__gnu_debug::__msg_inc_istreambuf)\n\t\t\t\t._M_iterator(__i));\n\t      break;\n\t    }\n\t}\n\n      __i._M_c = __eof;\n    }\n\n/// @} group iterators\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif\n"}],"crc32":3675870765,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]