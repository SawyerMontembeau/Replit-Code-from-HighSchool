[{"ops":[{"insert":"// Stream buffer classes -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/streambuf.tcc\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{streambuf}\n */\n\n//\n// ISO C++ 14882: 27.5  Stream buffers\n//\n\n#ifndef _STREAMBUF_TCC\n#define _STREAMBUF_TCC 1\n\n#pragma GCC system_header\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template<typename _CharT, typename _Traits>\n    streamsize\n    basic_streambuf<_CharT, _Traits>::\n    xsgetn(char_type* __s, streamsize __n)\n    {\n      streamsize __ret = 0;\n      while (__ret < __n)\n\t{\n\t  const streamsize __buf_len = this->egptr() - this->gptr();\n\t  if (__buf_len)\n\t    {\n\t      const streamsize __remaining = __n - __ret;\n\t      const streamsize __len = std::min(__buf_len, __remaining);\n\t      traits_type::copy(__s, this->gptr(), __len);\n\t      __ret += __len;\n\t      __s += __len;\n\t      this->__safe_gbump(__len);\n\t    }\n\n\t  if (__ret < __n)\n\t    {\n\t      const int_type __c = this->uflow();\n\t      if (!traits_type::eq_int_type(__c, traits_type::eof()))\n\t\t{\n\t\t  traits_type::assign(*__s++, traits_type::to_char_type(__c));\n\t\t  ++__ret;\n\t\t}\n\t      else\n\t\tbreak;\n\t    }\n\t}\n      return __ret;\n    }\n\n  template<typename _CharT, typename _Traits>\n    streamsize\n    basic_streambuf<_CharT, _Traits>::\n    xsputn(const char_type* __s, streamsize __n)\n    {\n      streamsize __ret = 0;\n      while (__ret < __n)\n\t{\n\t  const streamsize __buf_len = this->epptr() - this->pptr();\n\t  if (__buf_len)\n\t    {\n\t      const streamsize __remaining = __n - __ret;\n\t      const streamsize __len = std::min(__buf_len, __remaining);\n\t      traits_type::copy(this->pptr(), __s, __len);\n\t      __ret += __len;\n\t      __s += __len;\n\t      this->__safe_pbump(__len);\n\t    }\n\n\t  if (__ret < __n)\n\t    {\n\t      int_type __c = this->overflow(traits_type::to_int_type(*__s));\n\t      if (!traits_type::eq_int_type(__c, traits_type::eof()))\n\t\t{\n\t\t  ++__ret;\n\t\t  ++__s;\n\t\t}\n\t      else\n\t\tbreak;\n\t    }\n\t}\n      return __ret;\n    }\n\n  // Conceivably, this could be used to implement buffer-to-buffer\n  // copies, if this was ever desired in an un-ambiguous way by the\n  // standard.\n  template<typename _CharT, typename _Traits>\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,\n\t\t\t  basic_streambuf<_CharT, _Traits>* __sbout,\n\t\t\t  bool& __ineof)\n    {\n      streamsize __ret = 0;\n      __ineof = true;\n      typename _Traits::int_type __c = __sbin->sgetc();\n      while (!_Traits::eq_int_type(__c, _Traits::eof()))\n\t{\n\t  __c = __sbout->sputc(_Traits::to_char_type(__c));\n\t  if (_Traits::eq_int_type(__c, _Traits::eof()))\n\t    {\n\t      __ineof = false;\n\t      break;\n\t    }\n\t  ++__ret;\n\t  __c = __sbin->snextc();\n\t}\n      return __ret;\n    }\n\n  template<typename _CharT, typename _Traits>\n    inline streamsize\n    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,\n\t\t      basic_streambuf<_CharT, _Traits>* __sbout)\n    {\n      bool __ineof;\n      return __copy_streambufs_eof(__sbin, __sbout, __ineof);\n    }\n\n  // Inhibit implicit instantiations for required instantiations,\n  // which are defined via explicit instantiations elsewhere.\n#if _GLIBCXX_EXTERN_TEMPLATE\n  extern template class basic_streambuf<char>;\n  extern template\n    streamsize\n    __copy_streambufs(basic_streambuf<char>*,\n\t\t      basic_streambuf<char>*);\n  extern template\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<char>*,\n\t\t\t  basic_streambuf<char>*, bool&);\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  extern template class basic_streambuf<wchar_t>;\n  extern template\n    streamsize\n    __copy_streambufs(basic_streambuf<wchar_t>*,\n\t\t      basic_streambuf<wchar_t>*);\n  extern template\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<wchar_t>*,\n\t\t\t  basic_streambuf<wchar_t>*, bool&);\n#endif\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif\n"}],"crc32":2356045580,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]