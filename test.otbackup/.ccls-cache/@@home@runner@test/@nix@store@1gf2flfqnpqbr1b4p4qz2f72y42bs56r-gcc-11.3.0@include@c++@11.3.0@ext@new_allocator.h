[{"ops":[{"insert":"// Allocator that wraps operator new -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file ext/new_allocator.h\n *  This file is a GNU extension to the Standard C++ Library.\n */\n\n#ifndef _NEW_ALLOCATOR_H\n#define _NEW_ALLOCATOR_H 1\n\n#include <bits/c++config.h>\n#include <new>\n#include <bits/functexcept.h>\n#include <bits/move.h>\n#if __cplusplus >= 201103L\n#include <type_traits>\n#endif\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].\n   *  @ingroup allocators\n   *\n   *  This is precisely the allocator defined in the C++ Standard.\n   *    - all allocation calls operator new\n   *    - all deallocation calls operator delete\n   *\n   *  @tparam  _Tp  Type of allocated object.\n   */\n  template<typename _Tp>\n    class new_allocator\n    {\n    public:\n      typedef _Tp        value_type;\n      typedef std::size_t     size_type;\n      typedef std::ptrdiff_t  difference_type;\n#if __cplusplus <= 201703L\n      typedef _Tp*       pointer;\n      typedef const _Tp* const_pointer;\n      typedef _Tp&       reference;\n      typedef const _Tp& const_reference;\n\n      template<typename _Tp1>\n\tstruct rebind\n\t{ typedef new_allocator<_Tp1> other; };\n#endif\n\n#if __cplusplus >= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2103. propagate_on_container_move_assignment\n      typedef std::true_type propagate_on_container_move_assignment;\n#endif\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }\n\n      template<typename _Tp1>\n\t_GLIBCXX20_CONSTEXPR\n\tnew_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }\n\n#if __cplusplus <= 201703L\n      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      pointer\n      address(reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n\n      const_pointer\n      address(const_reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n#endif\n\n      // NB: __n is permitted to be 0.  The C++ standard says nothing\n      // about what the return value is when __n == 0.\n      _GLIBCXX_NODISCARD _Tp*\n      allocate(size_type __n, const void* = static_cast<const void*>(0))\n      {\n#if __cplusplus >= 201103L\n\t // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t // 3308. std::allocator<void>().allocate(n)\n\t static_assert(sizeof(_Tp) != 0, \"cannot allocate incomplete types\");\n#endif\n\n\tif (__builtin_expect(__n > this->_M_max_size(), false))\n\t  {\n\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t    // 3190. allocator::allocate sometimes returns too little storage\n\t    if (__n > (std::size_t(-1) / sizeof(_Tp)))\n\t      std::__throw_bad_array_new_length();\n\t    std::__throw_bad_alloc();\n\t  }\n\n#if __cpp_aligned_new\n\tif (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    std::align_val_t __al = std::align_val_t(alignof(_Tp));\n\t    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));\n\t  }\n#endif\n\treturn static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));\n      }\n\n      // __p is not permitted to be a null pointer.\n      void\n      deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))\n      {\n#if __cpp_aligned_new\n\tif (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    ::operator delete(__p,\n# if __cpp_sized_deallocation\n\t\t\t      __t * sizeof(_Tp),\n# endif\n\t\t\t      std::align_val_t(alignof(_Tp)));\n\t    return;\n\t  }\n#endif\n\t::operator delete(__p\n#if __cpp_sized_deallocation\n\t\t\t  , __t * sizeof(_Tp)\n#endif\n\t\t\t );\n      }\n\n#if __cplusplus <= 201703L\n      size_type\n      max_size() const _GLIBCXX_USE_NOEXCEPT\n      { return _M_max_size(); }\n\n#if __cplusplus >= 201103L\n      template<typename _Up, typename... _Args>\n\tvoid\n\tconstruct(_Up* __p, _Args&&... __args)\n\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n\n      template<typename _Up>\n\tvoid\n\tdestroy(_Up* __p)\n\tnoexcept(std::is_nothrow_destructible<_Up>::value)\n\t{ __p->~_Up(); }\n#else\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 402. wrong new expression in [some_] allocator::construct\n      void\n      construct(pointer __p, const _Tp& __val)\n      { ::new((void *)__p) _Tp(__val); }\n\n      void\n      destroy(pointer __p) { __p->~_Tp(); }\n#endif\n#endif // ! C++20\n\n      template<typename _Up>\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator==(const new_allocator&, const new_allocator<_Up>&)\n\t_GLIBCXX_NOTHROW\n\t{ return true; }\n\n#if __cpp_impl_three_way_comparison < 201907L\n      template<typename _Up>\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator!=(const new_allocator&, const new_allocator<_Up>&)\n\t_GLIBCXX_NOTHROW\n\t{ return false; }\n#endif\n\n    private:\n      _GLIBCXX_CONSTEXPR size_type\n      _M_max_size() const _GLIBCXX_USE_NOEXCEPT\n      {\n#if __PTRDIFF_MAX__ < __SIZE_MAX__\n\treturn std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);\n#else\n\treturn std::size_t(-1) / sizeof(_Tp);\n#endif\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif\n"}],"crc32":3634820041,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]