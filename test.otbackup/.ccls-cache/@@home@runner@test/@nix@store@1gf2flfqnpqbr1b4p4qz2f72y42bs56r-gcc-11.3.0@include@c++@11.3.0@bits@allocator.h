[{"ops":[{"insert":"// Allocators -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/*\n * Copyright (c) 1996-1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/** @file bits/allocator.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _ALLOCATOR_H\n#define _ALLOCATOR_H 1\n\n#include <bits/c++allocator.h> // Define the base class to std::allocator.\n#include <bits/memoryfwd.h>\n#if __cplusplus >= 201103L\n#include <type_traits>\n#endif\n\n#define __cpp_lib_incomplete_container_elements 201505\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @addtogroup allocators\n   *  @{\n   */\n\n  // Since C++20 the primary template should be used for allocator<void>,\n  // but then it would have a non-trivial default ctor and dtor for C++20,\n  // but trivial for C++98-17, which would be an ABI incompatibiliy between\n  // different standard dialects. So C++20 still uses the allocator<void>\n  // explicit specialization, with the historical ABI properties, but with\n  // the same members that are present in the primary template.\n\n  /// allocator<void> specialization.\n  template<>\n    class allocator<void>\n    {\n    public:\n      typedef void        value_type;\n      typedef size_t      size_type;\n      typedef ptrdiff_t   difference_type;\n\n#if __cplusplus <= 201703L\n      // These were removed for C++20, allocator_traits does the right thing.\n      typedef void*       pointer;\n      typedef const void* const_pointer;\n\n      template<typename _Tp1>\n\tstruct rebind\n\t{ typedef allocator<_Tp1> other; };\n#endif\n\n#if __cplusplus >= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2103. std::allocator propagate_on_container_move_assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      using is_always_equal\n\t_GLIBCXX20_DEPRECATED_SUGGEST(\"std::allocator_traits::is_always_equal\")\n\t= true_type;\n\n#if __cplusplus >= 202002L\n      // As noted above, these members are present for C++20 to provide the\n      // same API as the primary template, but still trivial as in pre-C++20.\n      allocator() = default;\n      ~allocator() = default;\n\n      template<typename _Up>\n\tconstexpr\n\tallocator(const allocator<_Up>&) noexcept { }\n\n      // No allocate member because it's ill-formed by LWG 3307.\n      // No deallocate member because it would be undefined to call it\n      // with any pointer which wasn't obtained from allocate.\n#endif // C++20\n#endif // C++11\n    };\n\n  /**\n   * @brief  The @a standard allocator, as per C++03 [20.4.1].\n   *\n   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator\n   *  for further details.\n   *\n   *  @tparam  _Tp  Type of allocated object.\n   */\n  template<typename _Tp>\n    class allocator : public __allocator_base<_Tp>\n    {\n    public:\n      typedef _Tp        value_type;\n      typedef size_t     size_type;\n      typedef ptrdiff_t  difference_type;\n\n#if __cplusplus <= 201703L\n      // These were removed for C++20.\n      typedef _Tp*       pointer;\n      typedef const _Tp* const_pointer;\n      typedef _Tp&       reference;\n      typedef const _Tp& const_reference;\n\n      template<typename _Tp1>\n\tstruct rebind\n\t{ typedef allocator<_Tp1> other; };\n#endif\n\n#if __cplusplus >= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2103. std::allocator propagate_on_container_move_assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      using is_always_equal\n\t_GLIBCXX20_DEPRECATED_SUGGEST(\"std::allocator_traits::is_always_equal\")\n\t= true_type;\n#endif\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3035. std::allocator's constructors should be constexpr\n      _GLIBCXX20_CONSTEXPR\n      allocator() _GLIBCXX_NOTHROW { }\n\n      _GLIBCXX20_CONSTEXPR\n      allocator(const allocator& __a) _GLIBCXX_NOTHROW\n      : __allocator_base<_Tp>(__a) { }\n\n#if __cplusplus >= 201103L\n      // Avoid implicit deprecation.\n      allocator& operator=(const allocator&) = default;\n#endif\n\n      template<typename _Tp1>\n\t_GLIBCXX20_CONSTEXPR\n\tallocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }\n\n#if __cpp_constexpr_dynamic_alloc\n      constexpr\n#endif\n      ~allocator() _GLIBCXX_NOTHROW { }\n\n#if __cplusplus > 201703L\n      [[nodiscard,__gnu__::__always_inline__]]\n      constexpr _Tp*\n      allocate(size_t __n)\n      {\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));\n#endif\n\treturn __allocator_base<_Tp>::allocate(__n, 0);\n      }\n\n      [[__gnu__::__always_inline__]]\n      constexpr void\n      deallocate(_Tp* __p, size_t __n)\n      {\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  {\n\t    ::operator delete(__p);\n\t    return;\n\t  }\n#endif\n\t__allocator_base<_Tp>::deallocate(__p, __n);\n      }\n#endif // C++20\n\n      friend _GLIBCXX20_CONSTEXPR bool\n      operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n      { return true; }\n\n#if __cpp_impl_three_way_comparison < 201907L\n      friend _GLIBCXX20_CONSTEXPR bool\n      operator!=(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n      { return false; }\n#endif\n\n      // Inherit everything else.\n    };\n\n  template<typename _T1, typename _T2>\n    inline _GLIBCXX20_CONSTEXPR bool\n    operator==(const allocator<_T1>&, const allocator<_T2>&)\n    _GLIBCXX_NOTHROW\n    { return true; }\n\n#if __cpp_impl_three_way_comparison < 201907L\n  template<typename _T1, typename _T2>\n    inline _GLIBCXX20_CONSTEXPR bool\n    operator!=(const allocator<_T1>&, const allocator<_T2>&)\n    _GLIBCXX_NOTHROW\n    { return false; }\n#endif\n\n  // Invalid allocator<cv T> partial specializations.\n  // allocator_traits::rebind_alloc can be used to form a valid allocator type.\n  template<typename _Tp>\n    class allocator<const _Tp>\n    {\n    public:\n      typedef _Tp value_type;\n      template<typename _Up> allocator(const allocator<_Up>&) { }\n    };\n\n  template<typename _Tp>\n    class allocator<volatile _Tp>\n    {\n    public:\n      typedef _Tp value_type;\n      template<typename _Up> allocator(const allocator<_Up>&) { }\n    };\n\n  template<typename _Tp>\n    class allocator<const volatile _Tp>\n    {\n    public:\n      typedef _Tp value_type;\n      template<typename _Up> allocator(const allocator<_Up>&) { }\n    };\n\n  /// @} group allocator\n\n  // Inhibit implicit instantiations for required instantiations,\n  // which are defined via explicit instantiations elsewhere.\n#if _GLIBCXX_EXTERN_TEMPLATE\n  extern template class allocator<char>;\n  extern template class allocator<wchar_t>;\n#endif\n\n  // Undefine.\n#undef __allocator_base\n\n  // To implement Option 3 of DR 431.\n  template<typename _Alloc, bool = __is_empty(_Alloc)>\n    struct __alloc_swap\n    { static void _S_do_it(_Alloc&, _Alloc&) _GLIBCXX_NOEXCEPT { } };\n\n  template<typename _Alloc>\n    struct __alloc_swap<_Alloc, false>\n    {\n      static void\n      _S_do_it(_Alloc& __one, _Alloc& __two) _GLIBCXX_NOEXCEPT\n      {\n\t// Precondition: swappable allocators.\n\tif (__one != __two)\n\t  swap(__one, __two);\n      }\n    };\n\n  // Optimize for stateless allocators.\n  template<typename _Alloc, bool = __is_empty(_Alloc)>\n    struct __alloc_neq\n    {\n      static bool\n      _S_do_it(const _Alloc&, const _Alloc&)\n      { return false; }\n    };\n\n  template<typename _Alloc>\n    struct __alloc_neq<_Alloc, false>\n    {\n      static bool\n      _S_do_it(const _Alloc& __one, const _Alloc& __two)\n      { return __one != __two; }\n    };\n\n#if __cplusplus >= 201103L\n  template<typename _Tp, bool\n    = __or_<is_copy_constructible<typename _Tp::value_type>,\n            is_nothrow_move_constructible<typename _Tp::value_type>>::value>\n    struct __shrink_to_fit_aux\n    { static bool _S_do_it(_Tp&) noexcept { return false; } };\n\n  template<typename _Tp>\n    struct __shrink_to_fit_aux<_Tp, true>\n    {\n      static bool\n      _S_do_it(_Tp& __c) noexcept\n      {\n#if __cpp_exceptions\n\ttry\n\t  {\n\t    _Tp(__make_move_if_noexcept_iterator(__c.begin()),\n\t\t__make_move_if_noexcept_iterator(__c.end()),\n\t\t__c.get_allocator()).swap(__c);\n\t    return true;\n\t  }\n\tcatch(...)\n\t  { return false; }\n#else\n\treturn false;\n#endif\n      }\n    };\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif\n"}],"crc32":3315345138,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]