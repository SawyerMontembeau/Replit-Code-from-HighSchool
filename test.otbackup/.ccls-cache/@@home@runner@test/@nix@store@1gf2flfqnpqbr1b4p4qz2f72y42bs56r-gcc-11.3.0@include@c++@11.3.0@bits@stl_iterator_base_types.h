[{"ops":[{"insert":"// Types used in iterator implementation -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996-1998\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/** @file bits/stl_iterator_base_types.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{iterator}\n *\n *  This file contains all of the general iterator-related utility types,\n *  such as iterator_traits and struct iterator.\n */\n\n#ifndef _STL_ITERATOR_BASE_TYPES_H\n#define _STL_ITERATOR_BASE_TYPES_H 1\n\n#pragma GCC system_header\n\n#include <bits/c++config.h>\n\n#if __cplusplus >= 201103L\n# include <type_traits>  // For __void_t, is_convertible\n#endif\n\n#if __cplusplus > 201703L && __cpp_concepts >= 201907L\n# include <bits/iterator_concepts.h>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @defgroup iterators Iterators\n   *  Abstractions for uniform iterating through various underlying types.\n  */\n  ///@{\n\n  /**\n   *  @defgroup iterator_tags Iterator Tags\n   *  These are empty types, used to distinguish different iterators.  The\n   *  distinction is not made by what they contain, but simply by what they\n   *  are.  Different underlying algorithms can then be used based on the\n   *  different operations supported by different iterator types.\n  */\n  ///@{\n  ///  Marking input iterators.\n  struct input_iterator_tag { };\n\n  ///  Marking output iterators.\n  struct output_iterator_tag { };\n\n  /// Forward iterators support a superset of input iterator operations.\n  struct forward_iterator_tag : public input_iterator_tag { };\n\n  /// Bidirectional iterators support a superset of forward iterator\n  /// operations.\n  struct bidirectional_iterator_tag : public forward_iterator_tag { };\n\n  /// Random-access iterators support a superset of bidirectional\n  /// iterator operations.\n  struct random_access_iterator_tag : public bidirectional_iterator_tag { };\n\n#if __cplusplus > 201703L\n  /// Contiguous iterators point to objects stored contiguously in memory.\n  struct contiguous_iterator_tag : public random_access_iterator_tag { };\n#endif\n  ///@}\n\n  /**\n   *  @brief  Common %iterator class.\n   *\n   *  This class does nothing but define nested typedefs.  %Iterator classes\n   *  can inherit from this class to save some work.  The typedefs are then\n   *  used in specializations and overloading.\n   *\n   *  In particular, there are no default implementations of requirements\n   *  such as @c operator++ and the like.  (How could there be?)\n  */\n  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,\n           typename _Pointer = _Tp*, typename _Reference = _Tp&>\n    struct iterator\n    {\n      /// One of the @link iterator_tags tag types@endlink.\n      typedef _Category  iterator_category;\n      /// The type \"pointed to\" by the iterator.\n      typedef _Tp        value_type;\n      /// Distance between iterators is represented as this type.\n      typedef _Distance  difference_type;\n      /// This type represents a pointer-to-value_type.\n      typedef _Pointer   pointer;\n      /// This type represents a reference-to-value_type.\n      typedef _Reference reference;\n    };\n\n  /**\n   *  @brief  Traits class for iterators.\n   *\n   *  This class does nothing but define nested typedefs.  The general\n   *  version simply @a forwards the nested typedefs from the Iterator\n   *  argument.  Specialized versions for pointers and pointers-to-const\n   *  provide tighter, more correct semantics.\n  */\n  template<typename _Iterator>\n    struct iterator_traits;\n\n#if __cplusplus >= 201103L\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14\n  template<typename _Iterator, typename = __void_t<>>\n    struct __iterator_traits { };\n\n#if ! __cpp_lib_concepts\n\n  template<typename _Iterator>\n    struct __iterator_traits<_Iterator,\n\t\t\t     __void_t<typename _Iterator::iterator_category,\n\t\t\t\t      typename _Iterator::value_type,\n\t\t\t\t      typename _Iterator::difference_type,\n\t\t\t\t      typename _Iterator::pointer,\n\t\t\t\t      typename _Iterator::reference>>\n    {\n      typedef typename _Iterator::iterator_category iterator_category;\n      typedef typename _Iterator::value_type        value_type;\n      typedef typename _Iterator::difference_type   difference_type;\n      typedef typename _Iterator::pointer           pointer;\n      typedef typename _Iterator::reference         reference;\n    };\n#endif // ! concepts\n\n  template<typename _Iterator>\n    struct iterator_traits\n    : public __iterator_traits<_Iterator> { };\n\n#else // ! C++11\n  template<typename _Iterator>\n    struct iterator_traits\n    {\n      typedef typename _Iterator::iterator_category iterator_category;\n      typedef typename _Iterator::value_type        value_type;\n      typedef typename _Iterator::difference_type   difference_type;\n      typedef typename _Iterator::pointer           pointer;\n      typedef typename _Iterator::reference         reference;\n    };\n#endif // C++11\n\n#if __cplusplus > 201703L\n  /// Partial specialization for object pointer types.\n  template<typename _Tp>\n#if __cpp_concepts >= 201907L\n    requires is_object_v<_Tp>\n#endif\n    struct iterator_traits<_Tp*>\n    {\n      using iterator_concept  = contiguous_iterator_tag;\n      using iterator_category = random_access_iterator_tag;\n      using value_type\t      = remove_cv_t<_Tp>;\n      using difference_type   = ptrdiff_t;\n      using pointer\t      = _Tp*;\n      using reference\t      = _Tp&;\n    };\n#else\n  /// Partial specialization for pointer types.\n  template<typename _Tp>\n    struct iterator_traits<_Tp*>\n    {\n      typedef random_access_iterator_tag iterator_category;\n      typedef _Tp                         value_type;\n      typedef ptrdiff_t                   difference_type;\n      typedef _Tp*                        pointer;\n      typedef _Tp&                        reference;\n    };\n\n  /// Partial specialization for const pointer types.\n  template<typename _Tp>\n    struct iterator_traits<const _Tp*>\n    {\n      typedef random_access_iterator_tag iterator_category;\n      typedef _Tp                         value_type;\n      typedef ptrdiff_t                   difference_type;\n      typedef const _Tp*                  pointer;\n      typedef const _Tp&                  reference;\n    };\n#endif\n\n  /**\n   *  This function is not a part of the C++ standard but is syntactic\n   *  sugar for internal library use only.\n  */\n  template<typename _Iter>\n    inline _GLIBCXX_CONSTEXPR\n    typename iterator_traits<_Iter>::iterator_category\n    __iterator_category(const _Iter&)\n    { return typename iterator_traits<_Iter>::iterator_category(); }\n\n  ///@}\n\n#if __cplusplus >= 201103L\n  template<typename _Iter>\n    using __iterator_category_t\n      = typename iterator_traits<_Iter>::iterator_category;\n\n  template<typename _InIter>\n    using _RequireInputIter =\n      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,\n\t\t\t\t   input_iterator_tag>::value>;\n\n  template<typename _It,\n\t   typename _Cat = __iterator_category_t<_It>>\n    struct __is_random_access_iter\n      : is_base_of<random_access_iterator_tag, _Cat>\n    {\n      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;\n      enum { __value = _Base::value };\n    };\n#else\n  template<typename _It, typename _Traits = iterator_traits<_It>,\n\t   typename _Cat = typename _Traits::iterator_category>\n    struct __is_random_access_iter\n    { enum { __value = __is_base_of(random_access_iterator_tag, _Cat) }; };\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif /* _STL_ITERATOR_BASE_TYPES_H */\n"}],"crc32":2770673751,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]