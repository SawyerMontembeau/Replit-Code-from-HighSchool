[{"ops":[{"insert":"// Pair implementation -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/** @file bits/stl_pair.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{utility}\n */\n\n#ifndef _STL_PAIR_H\n#define _STL_PAIR_H 1\n\n#include <bits/move.h> // for std::move / std::forward, and std::swap\n\n#if __cplusplus >= 201103L\n# include <type_traits> // for std::__decay_and_strip, std::is_reference_v\n#endif\n#if __cplusplus > 201703L\n# include <compare>\n# define __cpp_lib_constexpr_utility 201811L\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @addtogroup utilities\n   *  @{\n   */\n\n#if __cplusplus >= 201103L\n  /// Tag type for piecewise construction of std::pair objects.\n  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };\n\n  /// Tag for piecewise construction of std::pair objects.\n  _GLIBCXX17_INLINE constexpr piecewise_construct_t piecewise_construct =\n    piecewise_construct_t();\n\n  /// @cond undocumented\n\n  // Forward declarations.\n  template<typename...>\n    class tuple;\n\n  template<size_t...>\n    struct _Index_tuple;\n\n  // Concept utility functions, reused in conditionally-explicit\n  // constructors.\n  // See PR 70437, don't look at is_constructible or\n  // is_convertible if the types are the same to\n  // avoid querying those properties for incomplete types.\n  template <bool, typename _T1, typename _T2>\n    struct _PCC\n    {\n      template <typename _U1, typename _U2>\n      static constexpr bool _ConstructiblePair()\n      {\n\treturn __and_<is_constructible<_T1, const _U1&>,\n\t\t      is_constructible<_T2, const _U2&>>::value;\n      }\n\n      template <typename _U1, typename _U2>\n      static constexpr bool _ImplicitlyConvertiblePair()\n      {\n\treturn __and_<is_convertible<const _U1&, _T1>,\n\t\t      is_convertible<const _U2&, _T2>>::value;\n      }\n\n      template <typename _U1, typename _U2>\n      static constexpr bool _MoveConstructiblePair()\n      {\n\treturn __and_<is_constructible<_T1, _U1&&>,\n\t\t      is_constructible<_T2, _U2&&>>::value;\n      }\n\n      template <typename _U1, typename _U2>\n      static constexpr bool _ImplicitlyMoveConvertiblePair()\n      {\n\treturn __and_<is_convertible<_U1&&, _T1>,\n\t\t      is_convertible<_U2&&, _T2>>::value;\n      }\n\n      template <bool __implicit, typename _U1, typename _U2>\n      static constexpr bool _CopyMovePair()\n      {\n\tusing __do_converts = __and_<is_convertible<const _U1&, _T1>,\n\t\t\t\t  is_convertible<_U2&&, _T2>>;\n\tusing __converts = typename conditional<__implicit,\n\t\t\t\t       __do_converts,\n\t\t\t\t       __not_<__do_converts>>::type;\n\treturn __and_<is_constructible<_T1, const _U1&>,\n\t\t      is_constructible<_T2, _U2&&>,\n\t\t      __converts\n\t\t      >::value;\n      }\n\n      template <bool __implicit, typename _U1, typename _U2>\n      static constexpr bool _MoveCopyPair()\n      {\n\tusing __do_converts = __and_<is_convertible<_U1&&, _T1>,\n\t\t\t\t  is_convertible<const _U2&, _T2>>;\n\tusing __converts = typename conditional<__implicit,\n\t\t\t\t       __do_converts,\n\t\t\t\t       __not_<__do_converts>>::type;\n\treturn __and_<is_constructible<_T1, _U1&&>,\n\t\t      is_constructible<_T2, const _U2&&>,\n\t\t      __converts\n\t\t      >::value;\n      }\n  };\n\n  template <typename _T1, typename _T2>\n    struct _PCC<false, _T1, _T2>\n    {\n      template <typename _U1, typename _U2>\n      static constexpr bool _ConstructiblePair()\n      {\n\treturn false;\n      }\n\n      template <typename _U1, typename _U2>\n      static constexpr bool _ImplicitlyConvertiblePair()\n      {\n\treturn false;\n      }\n\n      template <typename _U1, typename _U2>\n      static constexpr bool _MoveConstructiblePair()\n      {\n\treturn false;\n      }\n\n      template <typename _U1, typename _U2>\n      static constexpr bool _ImplicitlyMoveConvertiblePair()\n      {\n\treturn false;\n      }\n  };\n#endif // C++11\n\n  template<typename _U1, typename _U2> class __pair_base\n  {\n#if __cplusplus >= 201103L\n    template<typename _T1, typename _T2> friend struct pair;\n    __pair_base() = default;\n    ~__pair_base() = default;\n    __pair_base(const __pair_base&) = default;\n    __pair_base& operator=(const __pair_base&) = delete;\n#endif // C++11\n  };\n\n  /// @endcond\n\n /**\n   *  @brief Struct holding two objects of arbitrary type.\n   *\n   *  @tparam _T1  Type of first object.\n   *  @tparam _T2  Type of second object.\n   *\n   *  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>\n   */\n  template<typename _T1, typename _T2>\n    struct pair\n    : private __pair_base<_T1, _T2>\n    {\n      typedef _T1 first_type;    ///< The type of the `first` member\n      typedef _T2 second_type;   ///< The type of the `second` member\n\n      _T1 first;                 ///< The first member\n      _T2 second;                ///< The second member\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 265.  std::pair::pair() effects overly restrictive\n      /** The default constructor creates @c first and @c second using their\n       *  respective default constructors.  */\n#if __cplusplus >= 201103L\n      template <typename _U1 = _T1,\n                typename _U2 = _T2,\n                typename enable_if<__and_<\n                                     __is_implicitly_default_constructible<_U1>,\n                                     __is_implicitly_default_constructible<_U2>>\n                                   ::value, bool>::type = true>\n#endif\n      _GLIBCXX_CONSTEXPR pair()\n      : first(), second() { }\n\n#if __cplusplus >= 201103L\n      template <typename _U1 = _T1,\n                typename _U2 = _T2,\n                typename enable_if<__and_<\n                       is_default_constructible<_U1>,\n                       is_default_constructible<_U2>,\n                       __not_<\n                         __and_<__is_implicitly_default_constructible<_U1>,\n                                __is_implicitly_default_constructible<_U2>>>>\n                                   ::value, bool>::type = false>\n      explicit constexpr pair()\n      : first(), second() { }\n#endif\n\n#if __cplusplus < 201103L\n      /// Two objects may be passed to a @c pair constructor to be copied.\n      pair(const _T1& __a, const _T2& __b)\n      : first(__a), second(__b) { }\n#else\n      // Shortcut for constraining the templates that don't take pairs.\n      /// @cond undocumented\n      using _PCCP = _PCC<true, _T1, _T2>;\n      /// @endcond\n\n      /// Construct from two const lvalues, allowing implicit conversions.\n      template<typename _U1 = _T1, typename _U2=_T2, typename\n\t       enable_if<_PCCP::template\n\t\t\t   _ConstructiblePair<_U1, _U2>()\n\t                 && _PCCP::template\n\t\t\t   _ImplicitlyConvertiblePair<_U1, _U2>(),\n                         bool>::type=true>\n      constexpr pair(const _T1& __a, const _T2& __b)\n      : first(__a), second(__b) { }\n\n      /// Construct from two const lvalues, disallowing implicit conversions.\n       template<typename _U1 = _T1, typename _U2=_T2, typename\n\t\tenable_if<_PCCP::template\n\t\t\t    _ConstructiblePair<_U1, _U2>()\n\t                  && !_PCCP::template\n\t\t\t    _ImplicitlyConvertiblePair<_U1, _U2>(),\n                         bool>::type=false>\n      explicit constexpr pair(const _T1& __a, const _T2& __b)\n      : first(__a), second(__b) { }\n#endif\n\n#if __cplusplus < 201103L\n      /// There is also a templated constructor to convert from other pairs.\n      template<typename _U1, typename _U2>\n\tpair(const pair<_U1, _U2>& __p)\n\t: first(__p.first), second(__p.second) { }\n#else\n      // Shortcut for constraining the templates that take pairs.\n      /// @cond undocumented\n      template <typename _U1, typename _U2>\n        using _PCCFP = _PCC<!is_same<_T1, _U1>::value\n\t\t\t    || !is_same<_T2, _U2>::value,\n\t\t\t    _T1, _T2>;\n      /// @endcond\n\n      template<typename _U1, typename _U2, typename\n\t       enable_if<_PCCFP<_U1, _U2>::template\n\t\t\t   _ConstructiblePair<_U1, _U2>()\n\t                 && _PCCFP<_U1, _U2>::template\n\t\t\t   _ImplicitlyConvertiblePair<_U1, _U2>(),\n\t\t\t  bool>::type=true>\n        constexpr pair(const pair<_U1, _U2>& __p)\n        : first(__p.first), second(__p.second) { }\n\n      template<typename _U1, typename _U2, typename\n\t       enable_if<_PCCFP<_U1, _U2>::template\n\t\t\t   _ConstructiblePair<_U1, _U2>()\n\t\t\t && !_PCCFP<_U1, _U2>::template\n\t\t\t   _ImplicitlyConvertiblePair<_U1, _U2>(),\n                         bool>::type=false>\n\texplicit constexpr pair(const pair<_U1, _U2>& __p)\n\t: first(__p.first), second(__p.second) { }\n#endif\n\n#if __cplusplus >= 201103L\n      constexpr pair(const pair&) = default;\t///< Copy constructor\n      constexpr pair(pair&&) = default;\t\t///< Move constructor\n\n      // DR 811.\n      template<typename _U1, typename\n\t       enable_if<_PCCP::template\n\t\t\t   _MoveCopyPair<true, _U1, _T2>(),\n                         bool>::type=true>\n       constexpr pair(_U1&& __x, const _T2& __y)\n       : first(std::forward<_U1>(__x)), second(__y) { }\n\n      template<typename _U1, typename\n\t       enable_if<_PCCP::template\n\t\t\t   _MoveCopyPair<false, _U1, _T2>(),\n                         bool>::type=false>\n       explicit constexpr pair(_U1&& __x, const _T2& __y)\n       : first(std::forward<_U1>(__x)), second(__y) { }\n\n      template<typename _U2, typename\n\t       enable_if<_PCCP::template\n\t\t\t   _CopyMovePair<true, _T1, _U2>(),\n                         bool>::type=true>\n       constexpr pair(const _T1& __x, _U2&& __y)\n       : first(__x), second(std::forward<_U2>(__y)) { }\n\n      template<typename _U2, typename\n\t       enable_if<_PCCP::template\n\t\t\t   _CopyMovePair<false, _T1, _U2>(),\n                         bool>::type=false>\n       explicit pair(const _T1& __x, _U2&& __y)\n       : first(__x), second(std::forward<_U2>(__y)) { }\n\n      template<typename _U1, typename _U2, typename\n\t       enable_if<_PCCP::template\n\t\t\t   _MoveConstructiblePair<_U1, _U2>()\n\t\t\t  && _PCCP::template\n\t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                         bool>::type=true>\n\tconstexpr pair(_U1&& __x, _U2&& __y)\n\t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n\n      template<typename _U1, typename _U2, typename\n\t       enable_if<_PCCP::template\n\t\t\t   _MoveConstructiblePair<_U1, _U2>()\n\t\t\t  && !_PCCP::template\n\t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                         bool>::type=false>\n\texplicit constexpr pair(_U1&& __x, _U2&& __y)\n\t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n\n\n      template<typename _U1, typename _U2, typename\n\t       enable_if<_PCCFP<_U1, _U2>::template\n\t\t\t   _MoveConstructiblePair<_U1, _U2>()\n\t\t\t  && _PCCFP<_U1, _U2>::template\n\t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                         bool>::type=true>\n\tconstexpr pair(pair<_U1, _U2>&& __p)\n\t: first(std::forward<_U1>(__p.first)),\n\t  second(std::forward<_U2>(__p.second)) { }\n\n      template<typename _U1, typename _U2, typename\n\t       enable_if<_PCCFP<_U1, _U2>::template\n\t\t\t   _MoveConstructiblePair<_U1, _U2>()\n\t\t\t  && !_PCCFP<_U1, _U2>::template\n\t\t\t   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),\n                         bool>::type=false>\n\texplicit constexpr pair(pair<_U1, _U2>&& __p)\n\t: first(std::forward<_U1>(__p.first)),\n\t  second(std::forward<_U2>(__p.second)) { }\n\n      template<typename... _Args1, typename... _Args2>\n\t_GLIBCXX20_CONSTEXPR\n        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);\n\n      _GLIBCXX20_CONSTEXPR pair&\n      operator=(typename conditional<\n\t\t__and_<is_copy_assignable<_T1>,\n\t\t       is_copy_assignable<_T2>>::value,\n\t\tconst pair&, const __nonesuch&>::type __p)\n      {\n\tfirst = __p.first;\n\tsecond = __p.second;\n\treturn *this;\n      }\n\n      _GLIBCXX20_CONSTEXPR pair&\n      operator=(typename conditional<\n\t\t__and_<is_move_assignable<_T1>,\n\t\t       is_move_assignable<_T2>>::value,\n\t\tpair&&, __nonesuch&&>::type __p)\n      noexcept(__and_<is_nothrow_move_assignable<_T1>,\n\t\t      is_nothrow_move_assignable<_T2>>::value)\n      {\n\tfirst = std::forward<first_type>(__p.first);\n\tsecond = std::forward<second_type>(__p.second);\n\treturn *this;\n      }\n\n      template<typename _U1, typename _U2>\n\t_GLIBCXX20_CONSTEXPR\n\ttypename enable_if<__and_<is_assignable<_T1&, const _U1&>,\n\t\t\t\t  is_assignable<_T2&, const _U2&>>::value,\n\t\t\t   pair&>::type\n\toperator=(const pair<_U1, _U2>& __p)\n\t{\n\t  first = __p.first;\n\t  second = __p.second;\n\t  return *this;\n\t}\n\n      template<typename _U1, typename _U2>\n\t_GLIBCXX20_CONSTEXPR\n\ttypename enable_if<__and_<is_assignable<_T1&, _U1&&>,\n\t\t\t\t  is_assignable<_T2&, _U2&&>>::value,\n\t\t\t   pair&>::type\n\toperator=(pair<_U1, _U2>&& __p)\n\t{\n\t  first = std::forward<_U1>(__p.first);\n\t  second = std::forward<_U2>(__p.second);\n\t  return *this;\n\t}\n\n      /// Swap the first members and then the second members.\n      _GLIBCXX20_CONSTEXPR void\n      swap(pair& __p)\n      noexcept(__and_<__is_nothrow_swappable<_T1>,\n                      __is_nothrow_swappable<_T2>>::value)\n      {\n\tusing std::swap;\n\tswap(first, __p.first);\n\tswap(second, __p.second);\n      }\n\n    private:\n      template<typename... _Args1, size_t... _Indexes1,\n\t       typename... _Args2, size_t... _Indexes2>\n\t_GLIBCXX20_CONSTEXPR\n        pair(tuple<_Args1...>&, tuple<_Args2...>&,\n\t     _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);\n#endif // C++11\n    };\n\n  /// @relates pair @{\n\n#if __cpp_deduction_guides >= 201606\n  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;\n#endif\n\n  /// Two pairs of the same type are equal iff their members are equal.\n  template<typename _T1, typename _T2>\n    inline _GLIBCXX_CONSTEXPR bool\n    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return __x.first == __y.first && __x.second == __y.second; }\n\n#if __cpp_lib_three_way_comparison && __cpp_lib_concepts\n  template<typename _T1, typename _T2>\n    constexpr common_comparison_category_t<__detail::__synth3way_t<_T1>,\n\t\t\t\t\t   __detail::__synth3way_t<_T2>>\n    operator<=>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    {\n      if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)\n\treturn __c;\n      return __detail::__synth3way(__x.second, __y.second);\n    }\n#else\n  /** Defines a lexicographical order for pairs.\n   *\n   * For two pairs of the same type, `P` is ordered before `Q` if\n   * `P.first` is less than `Q.first`, or if `P.first` and `Q.first`\n   * are equivalent (neither is less than the other) and `P.second` is less\n   * than `Q.second`.\n  */\n  template<typename _T1, typename _T2>\n    inline _GLIBCXX_CONSTEXPR bool\n    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return __x.first < __y.first\n\t     || (!(__y.first < __x.first) && __x.second < __y.second); }\n\n  /// Uses @c operator== to find the result.\n  template<typename _T1, typename _T2>\n    inline _GLIBCXX_CONSTEXPR bool\n    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return !(__x == __y); }\n\n  /// Uses @c operator< to find the result.\n  template<typename _T1, typename _T2>\n    inline _GLIBCXX_CONSTEXPR bool\n    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return __y < __x; }\n\n  /// Uses @c operator< to find the result.\n  template<typename _T1, typename _T2>\n    inline _GLIBCXX_CONSTEXPR bool\n    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return !(__y < __x); }\n\n  /// Uses @c operator< to find the result.\n  template<typename _T1, typename _T2>\n    inline _GLIBCXX_CONSTEXPR bool\n    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n    { return !(__x < __y); }\n#endif // !(three_way_comparison && concepts)\n\n#if __cplusplus >= 201103L\n  /** Swap overload for pairs. Calls std::pair::swap().\n   *\n   * @note This std::swap overload is not declared in C++03 mode,\n   * which has performance implications, e.g. see https://gcc.gnu.org/PR38466\n  */\n  template<typename _T1, typename _T2>\n    _GLIBCXX20_CONSTEXPR inline\n#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n    // Constrained free swap overload, see p0185r1\n    typename enable_if<__and_<__is_swappable<_T1>,\n                              __is_swappable<_T2>>::value>::type\n#else\n    void\n#endif\n    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n    noexcept(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n  template<typename _T1, typename _T2>\n    typename enable_if<!__and_<__is_swappable<_T1>,\n\t\t\t       __is_swappable<_T2>>::value>::type\n    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;\n#endif\n#endif // __cplusplus >= 201103L\n\n  /// @} relates pair\n\n  /**\n   *  @brief A convenience wrapper for creating a pair from two objects.\n   *  @param  __x  The first object.\n   *  @param  __y  The second object.\n   *  @return   A newly-constructed pair<> object of the appropriate type.\n   *\n   *  The C++98 standard says the objects are passed by reference-to-const,\n   *  but C++03 says they are passed by value (this was LWG issue #181).\n   *\n   *  Since C++11 they have been passed by forwarding reference and then\n   *  forwarded to the new members of the pair. To create a pair with a\n   *  member of reference type, pass a `reference_wrapper` to this function.\n   */\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 181.  make_pair() unintended behavior\n#if __cplusplus >= 201103L\n  // NB: DR 706.\n  template<typename _T1, typename _T2>\n    constexpr pair<typename __decay_and_strip<_T1>::__type,\n                   typename __decay_and_strip<_T2>::__type>\n    make_pair(_T1&& __x, _T2&& __y)\n    {\n      typedef typename __decay_and_strip<_T1>::__type __ds_type1;\n      typedef typename __decay_and_strip<_T2>::__type __ds_type2;\n      typedef pair<__ds_type1, __ds_type2> \t      __pair_type;\n      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));\n    }\n#else\n  template<typename _T1, typename _T2>\n    inline pair<_T1, _T2>\n    make_pair(_T1 __x, _T2 __y)\n    { return pair<_T1, _T2>(__x, __y); }\n#endif\n\n  /// @}\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif /* _STL_PAIR_H */\n"}],"crc32":1772638958,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]