[{"ops":[{"insert":"// Core algorithmic facilities -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996-1998\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/** @file bits/stl_algobase.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{algorithm}\n */\n\n#ifndef _STL_ALGOBASE_H\n#define _STL_ALGOBASE_H 1\n\n#include <bits/c++config.h>\n#include <bits/functexcept.h>\n#include <bits/cpp_type_traits.h>\n#include <ext/type_traits.h>\n#include <ext/numeric_traits.h>\n#include <bits/stl_pair.h>\n#include <bits/stl_iterator_base_types.h>\n#include <bits/stl_iterator_base_funcs.h>\n#include <bits/stl_iterator.h>\n#include <bits/concept_check.h>\n#include <debug/debug.h>\n#include <bits/move.h> // For std::swap\n#include <bits/predefined_ops.h>\n#if __cplusplus >= 201103L\n# include <type_traits>\n#endif\n#if __cplusplus > 201703L\n# include <compare>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /*\n   * A constexpr wrapper for __builtin_memcmp.\n   * @param __num The number of elements of type _Tp (not bytes).\n   */\n  template<typename _Tp, typename _Up>\n    _GLIBCXX14_CONSTEXPR\n    inline int\n    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)\n    {\n#if __cplusplus >= 201103L\n      static_assert(sizeof(_Tp) == sizeof(_Up), \"can be compared with memcmp\");\n#endif\n#ifdef __cpp_lib_is_constant_evaluated\n      if (std::is_constant_evaluated())\n\t{\n\t  for(; __num > 0; ++__first1, ++__first2, --__num)\n\t    if (*__first1 != *__first2)\n\t      return *__first1 < *__first2 ? -1 : 1;\n\t  return 0;\n\t}\n      else\n#endif\n\treturn __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);\n    }\n\n#if __cplusplus < 201103L\n  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a\n  // nutshell, we are partially implementing the resolution of DR 187,\n  // when it's safe, i.e., the value_types are equal.\n  template<bool _BoolType>\n    struct __iter_swap\n    {\n      template<typename _ForwardIterator1, typename _ForwardIterator2>\n\tstatic void\n\titer_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n\t{\n\t  typedef typename iterator_traits<_ForwardIterator1>::value_type\n\t    _ValueType1;\n\t  _ValueType1 __tmp = *__a;\n\t  *__a = *__b;\n\t  *__b = __tmp;\n\t}\n    };\n\n  template<>\n    struct __iter_swap<true>\n    {\n      template<typename _ForwardIterator1, typename _ForwardIterator2>\n\tstatic void\n\titer_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n\t{\n\t  swap(*__a, *__b);\n\t}\n    };\n#endif // C++03\n\n  /**\n   *  @brief Swaps the contents of two iterators.\n   *  @ingroup mutating_algorithms\n   *  @param  __a  An iterator.\n   *  @param  __b  Another iterator.\n   *  @return   Nothing.\n   *\n   *  This function swaps the values pointed to by two iterators, not the\n   *  iterators themselves.\n  */\n  template<typename _ForwardIterator1, typename _ForwardIterator2>\n    _GLIBCXX20_CONSTEXPR\n    inline void\n    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<\n\t\t\t\t  _ForwardIterator1>)\n      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<\n\t\t\t\t  _ForwardIterator2>)\n\n#if __cplusplus < 201103L\n      typedef typename iterator_traits<_ForwardIterator1>::value_type\n\t_ValueType1;\n      typedef typename iterator_traits<_ForwardIterator2>::value_type\n\t_ValueType2;\n\n      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,\n\t\t\t\t  _ValueType2>)\n      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,\n\t\t\t\t  _ValueType1>)\n\n      typedef typename iterator_traits<_ForwardIterator1>::reference\n\t_ReferenceType1;\n      typedef typename iterator_traits<_ForwardIterator2>::reference\n\t_ReferenceType2;\n      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value\n\t&& __are_same<_ValueType1&, _ReferenceType1>::__value\n\t&& __are_same<_ValueType2&, _ReferenceType2>::__value>::\n\titer_swap(__a, __b);\n#else\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 187. iter_swap underspecified\n      swap(*__a, *__b);\n#endif\n    }\n\n  /**\n   *  @brief Swap the elements of two sequences.\n   *  @ingroup mutating_algorithms\n   *  @param  __first1  A forward iterator.\n   *  @param  __last1   A forward iterator.\n   *  @param  __first2  A forward iterator.\n   *  @return   An iterator equal to @p first2+(last1-first1).\n   *\n   *  Swaps each element in the range @p [first1,last1) with the\n   *  corresponding element in the range @p [first2,(last1-first1)).\n   *  The ranges must not overlap.\n  */\n  template<typename _ForwardIterator1, typename _ForwardIterator2>\n    _GLIBCXX20_CONSTEXPR\n    _ForwardIterator2\n    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n\t\t_ForwardIterator2 __first2)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<\n\t\t\t\t  _ForwardIterator1>)\n      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<\n\t\t\t\t  _ForwardIterator2>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n\n      for (; __first1 != __last1; ++__first1, (void)++__first2)\n\tstd::iter_swap(__first1, __first2);\n      return __first2;\n    }\n\n  /**\n   *  @brief This does what you think it does.\n   *  @ingroup sorting_algorithms\n   *  @param  __a  A thing of arbitrary type.\n   *  @param  __b  Another thing of arbitrary type.\n   *  @return   The lesser of the parameters.\n   *\n   *  This is the simple classic generic implementation.  It will work on\n   *  temporary expressions, since they are only evaluated once, unlike a\n   *  preprocessor macro.\n  */\n  template<typename _Tp>\n    _GLIBCXX14_CONSTEXPR\n    inline const _Tp&\n    min(const _Tp& __a, const _Tp& __b)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)\n      //return __b < __a ? __b : __a;\n      if (__b < __a)\n\treturn __b;\n      return __a;\n    }\n\n  /**\n   *  @brief This does what you think it does.\n   *  @ingroup sorting_algorithms\n   *  @param  __a  A thing of arbitrary type.\n   *  @param  __b  Another thing of arbitrary type.\n   *  @return   The greater of the parameters.\n   *\n   *  This is the simple classic generic implementation.  It will work on\n   *  temporary expressions, since they are only evaluated once, unlike a\n   *  preprocessor macro.\n  */\n  template<typename _Tp>\n    _GLIBCXX14_CONSTEXPR\n    inline const _Tp&\n    max(const _Tp& __a, const _Tp& __b)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)\n      //return  __a < __b ? __b : __a;\n      if (__a < __b)\n\treturn __b;\n      return __a;\n    }\n\n  /**\n   *  @brief This does what you think it does.\n   *  @ingroup sorting_algorithms\n   *  @param  __a  A thing of arbitrary type.\n   *  @param  __b  Another thing of arbitrary type.\n   *  @param  __comp  A @link comparison_functors comparison functor@endlink.\n   *  @return   The lesser of the parameters.\n   *\n   *  This will work on temporary expressions, since they are only evaluated\n   *  once, unlike a preprocessor macro.\n  */\n  template<typename _Tp, typename _Compare>\n    _GLIBCXX14_CONSTEXPR\n    inline const _Tp&\n    min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n    {\n      //return __comp(__b, __a) ? __b : __a;\n      if (__comp(__b, __a))\n\treturn __b;\n      return __a;\n    }\n\n  /**\n   *  @brief This does what you think it does.\n   *  @ingroup sorting_algorithms\n   *  @param  __a  A thing of arbitrary type.\n   *  @param  __b  Another thing of arbitrary type.\n   *  @param  __comp  A @link comparison_functors comparison functor@endlink.\n   *  @return   The greater of the parameters.\n   *\n   *  This will work on temporary expressions, since they are only evaluated\n   *  once, unlike a preprocessor macro.\n  */\n  template<typename _Tp, typename _Compare>\n    _GLIBCXX14_CONSTEXPR\n    inline const _Tp&\n    max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n    {\n      //return __comp(__a, __b) ? __b : __a;\n      if (__comp(__a, __b))\n\treturn __b;\n      return __a;\n    }\n\n  // Fallback implementation of the function in bits/stl_iterator.h used to\n  // remove the __normal_iterator wrapper. See copy, fill, ...\n  template<typename _Iterator>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iterator\n    __niter_base(_Iterator __it)\n    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)\n    { return __it; }\n\n  template<typename _Ite, typename _Seq>\n    _Ite\n    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,\n\t\t std::random_access_iterator_tag>&);\n\n  // Reverse the __niter_base transformation to get a\n  // __normal_iterator back again (this assumes that __normal_iterator\n  // is only used to wrap random access iterators, like pointers).\n  template<typename _From, typename _To>\n    _GLIBCXX20_CONSTEXPR\n    inline _From\n    __niter_wrap(_From __from, _To __res)\n    { return __from + (__res - std::__niter_base(__from)); }\n\n  // No need to wrap, iterator already has the right type.\n  template<typename _Iterator>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iterator\n    __niter_wrap(const _Iterator&, _Iterator __res)\n    { return __res; }\n\n  // All of these auxiliary structs serve two purposes.  (1) Replace\n  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,\n  // because the input and output ranges are permitted to overlap.)\n  // (2) If we're using random access iterators, then write the loop as\n  // a for loop with an explicit count.\n\n  template<bool _IsMove, bool _IsSimple, typename _Category>\n    struct __copy_move\n    {\n      template<typename _II, typename _OI>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _OI\n\t__copy_m(_II __first, _II __last, _OI __result)\n\t{\n\t  for (; __first != __last; ++__result, (void)++__first)\n\t    *__result = *__first;\n\t  return __result;\n\t}\n    };\n\n#if __cplusplus >= 201103L\n  template<typename _Category>\n    struct __copy_move<true, false, _Category>\n    {\n      template<typename _II, typename _OI>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _OI\n\t__copy_m(_II __first, _II __last, _OI __result)\n\t{\n\t  for (; __first != __last; ++__result, (void)++__first)\n\t    *__result = std::move(*__first);\n\t  return __result;\n\t}\n    };\n#endif\n\n  template<>\n    struct __copy_move<false, false, random_access_iterator_tag>\n    {\n      template<typename _II, typename _OI>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _OI\n\t__copy_m(_II __first, _II __last, _OI __result)\n\t{\n\t  typedef typename iterator_traits<_II>::difference_type _Distance;\n\t  for(_Distance __n = __last - __first; __n > 0; --__n)\n\t    {\n\t      *__result = *__first;\n\t      ++__first;\n\t      ++__result;\n\t    }\n\t  return __result;\n\t}\n    };\n\n#if __cplusplus >= 201103L\n  template<>\n    struct __copy_move<true, false, random_access_iterator_tag>\n    {\n      template<typename _II, typename _OI>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _OI\n\t__copy_m(_II __first, _II __last, _OI __result)\n\t{\n\t  typedef typename iterator_traits<_II>::difference_type _Distance;\n\t  for(_Distance __n = __last - __first; __n > 0; --__n)\n\t    {\n\t      *__result = std::move(*__first);\n\t      ++__first;\n\t      ++__result;\n\t    }\n\t  return __result;\n\t}\n    };\n#endif\n\n  template<bool _IsMove>\n    struct __copy_move<_IsMove, true, random_access_iterator_tag>\n    {\n      template<typename _Tp>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _Tp*\n\t__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)\n\t{\n#if __cplusplus >= 201103L\n\t  using __assignable = conditional<_IsMove,\n\t\t\t\t\t   is_move_assignable<_Tp>,\n\t\t\t\t\t   is_copy_assignable<_Tp>>;\n\t  // trivial types can have deleted assignment\n\t  static_assert( __assignable::type::value, \"type is not assignable\" );\n#endif\n\t  const ptrdiff_t _Num = __last - __first;\n\t  if (_Num)\n\t    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);\n\t  return __result + _Num;\n\t}\n    };\n\n_GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n\n  template<typename _Tp, typename _Ref, typename _Ptr>\n    struct _Deque_iterator;\n\n  struct _Bit_iterator;\n\n_GLIBCXX_END_NAMESPACE_CONTAINER\n\n  // Helpers for streambuf iterators (either istream or ostream).\n  // NB: avoid including <iosfwd>, relatively large.\n  template<typename _CharT>\n    struct char_traits;\n\n  template<typename _CharT, typename _Traits>\n    class istreambuf_iterator;\n\n  template<typename _CharT, typename _Traits>\n    class ostreambuf_iterator;\n\n  template<bool _IsMove, typename _CharT>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type\n    __copy_move_a2(_CharT*, _CharT*,\n\t\t   ostreambuf_iterator<_CharT, char_traits<_CharT> >);\n\n  template<bool _IsMove, typename _CharT>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type\n    __copy_move_a2(const _CharT*, const _CharT*,\n\t\t   ostreambuf_iterator<_CharT, char_traits<_CharT> >);\n\n  template<bool _IsMove, typename _CharT>\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n\t\t\t\t    _CharT*>::__type\n    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,\n\t\t   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);\n\n  template<bool _IsMove, typename _CharT>\n    typename __gnu_cxx::__enable_if<\n      __is_char<_CharT>::__value,\n      _GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type\n    __copy_move_a2(\n\tistreambuf_iterator<_CharT, char_traits<_CharT> >,\n\tistreambuf_iterator<_CharT, char_traits<_CharT> >,\n\t_GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*>);\n\n  template<bool _IsMove, typename _II, typename _OI>\n    _GLIBCXX20_CONSTEXPR\n    inline _OI\n    __copy_move_a2(_II __first, _II __last, _OI __result)\n    {\n      typedef typename iterator_traits<_II>::iterator_category _Category;\n#ifdef __cpp_lib_is_constant_evaluated\n      if (std::is_constant_evaluated())\n\treturn std::__copy_move<_IsMove, false, _Category>::\n\t  __copy_m(__first, __last, __result);\n#endif\n      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,\n\t\t\t      _Category>::__copy_m(__first, __last, __result);\n    }\n\n  template<bool _IsMove,\n\t   typename _Tp, typename _Ref, typename _Ptr, typename _OI>\n    _OI\n    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n\t\t   _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n\t\t   _OI);\n\n  template<bool _IsMove,\n\t   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>\n    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>\n    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,\n\t\t   _GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,\n\t\t   _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);\n\n  template<bool _IsMove, typename _II, typename _Tp>\n    typename __gnu_cxx::__enable_if<\n      __is_random_access_iter<_II>::__value,\n      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type\n    __copy_move_a1(_II, _II, _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);\n\n  template<bool _IsMove, typename _II, typename _OI>\n    _GLIBCXX20_CONSTEXPR\n    inline _OI\n    __copy_move_a1(_II __first, _II __last, _OI __result)\n    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }\n\n  template<bool _IsMove, typename _II, typename _OI>\n    _GLIBCXX20_CONSTEXPR\n    inline _OI\n    __copy_move_a(_II __first, _II __last, _OI __result)\n    {\n      return std::__niter_wrap(__result,\n\t\tstd::__copy_move_a1<_IsMove>(std::__niter_base(__first),\n\t\t\t\t\t     std::__niter_base(__last),\n\t\t\t\t\t     std::__niter_base(__result)));\n    }\n\n  template<bool _IsMove,\n\t   typename _Ite, typename _Seq, typename _Cat, typename _OI>\n    _OI\n    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n\t\t  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n\t\t  _OI);\n\n  template<bool _IsMove,\n\t   typename _II, typename _Ite, typename _Seq, typename _Cat>\n    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>\n    __copy_move_a(_II, _II,\n\t\t  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);\n\n  template<bool _IsMove,\n\t   typename _IIte, typename _ISeq, typename _ICat,\n\t   typename _OIte, typename _OSeq, typename _OCat>\n    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>\n    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,\n\t\t  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,\n\t\t  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);\n\n  template<typename _InputIterator, typename _Size, typename _OutputIterator>\n    _GLIBCXX20_CONSTEXPR\n    _OutputIterator\n    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,\n\t       bool)\n    {\n      if (__n > 0)\n\t{\n\t  while (true)\n\t    {\n\t      *__result = *__first;\n\t      ++__result;\n\t      if (--__n > 0)\n\t\t++__first;\n\t      else\n\t\tbreak;\n\t    }\n\t}\n      return __result;\n    }\n\n  template<typename _CharT, typename _Size>\n    typename __gnu_cxx::__enable_if<\n      __is_char<_CharT>::__value, _CharT*>::__type\n    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,\n\t       _Size, _CharT*, bool);\n\n  template<typename _CharT, typename _Size>\n    typename __gnu_cxx::__enable_if<\n      __is_char<_CharT>::__value,\n      _GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type\n    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,\n\t       _GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*>,\n\t       bool);\n\n  /**\n   *  @brief Copies the range [first,last) into result.\n   *  @ingroup mutating_algorithms\n   *  @param  __first  An input iterator.\n   *  @param  __last   An input iterator.\n   *  @param  __result An output iterator.\n   *  @return   result + (last - first)\n   *\n   *  This inline function will boil down to a call to @c memmove whenever\n   *  possible.  Failing that, if random access iterators are passed, then the\n   *  loop count will be known (and therefore a candidate for compiler\n   *  optimizations such as unrolling).  Result may not be contained within\n   *  [first,last); the copy_backward function should be used instead.\n   *\n   *  Note that the end of the output range is permitted to be contained\n   *  within [first,last).\n  */\n  template<typename _II, typename _OI>\n    _GLIBCXX20_CONSTEXPR\n    inline _OI\n    copy(_II __first, _II __last, _OI __result)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_II>)\n      __glibcxx_function_requires(_OutputIteratorConcept<_OI,\n\t    typename iterator_traits<_II>::value_type>)\n      __glibcxx_requires_can_increment_range(__first, __last, __result);\n\n      return std::__copy_move_a<__is_move_iterator<_II>::__value>\n\t     (std::__miter_base(__first), std::__miter_base(__last), __result);\n    }\n\n#if __cplusplus >= 201103L\n  /**\n   *  @brief Moves the range [first,last) into result.\n   *  @ingroup mutating_algorithms\n   *  @param  __first  An input iterator.\n   *  @param  __last   An input iterator.\n   *  @param  __result An output iterator.\n   *  @return   result + (last - first)\n   *\n   *  This inline function will boil down to a call to @c memmove whenever\n   *  possible.  Failing that, if random access iterators are passed, then the\n   *  loop count will be known (and therefore a candidate for compiler\n   *  optimizations such as unrolling).  Result may not be contained within\n   *  [first,last); the move_backward function should be used instead.\n   *\n   *  Note that the end of the output range is permitted to be contained\n   *  within [first,last).\n  */\n  template<typename _II, typename _OI>\n    _GLIBCXX20_CONSTEXPR\n    inline _OI\n    move(_II __first, _II __last, _OI __result)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_II>)\n      __glibcxx_function_requires(_OutputIteratorConcept<_OI,\n\t    typename iterator_traits<_II>::value_type>)\n      __glibcxx_requires_can_increment_range(__first, __last, __result);\n\n      return std::__copy_move_a<true>(std::__miter_base(__first),\n\t\t\t\t      std::__miter_base(__last), __result);\n    }\n\n#define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)\n#else\n#define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)\n#endif\n\n  template<bool _IsMove, bool _IsSimple, typename _Category>\n    struct __copy_move_backward\n    {\n      template<typename _BI1, typename _BI2>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _BI2\n\t__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n\t{\n\t  while (__first != __last)\n\t    *--__result = *--__last;\n\t  return __result;\n\t}\n    };\n\n#if __cplusplus >= 201103L\n  template<typename _Category>\n    struct __copy_move_backward<true, false, _Category>\n    {\n      template<typename _BI1, typename _BI2>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _BI2\n\t__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n\t{\n\t  while (__first != __last)\n\t    *--__result = std::move(*--__last);\n\t  return __result;\n\t}\n    };\n#endif\n\n  template<>\n    struct __copy_move_backward<false, false, random_access_iterator_tag>\n    {\n      template<typename _BI1, typename _BI2>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _BI2\n\t__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n\t{\n\t  typename iterator_traits<_BI1>::difference_type\n\t    __n = __last - __first;\n\t  for (; __n > 0; --__n)\n\t    *--__result = *--__last;\n\t  return __result;\n\t}\n    };\n\n#if __cplusplus >= 201103L\n  template<>\n    struct __copy_move_backward<true, false, random_access_iterator_tag>\n    {\n      template<typename _BI1, typename _BI2>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _BI2\n\t__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n\t{\n\t  typename iterator_traits<_BI1>::difference_type\n\t    __n = __last - __first;\n\t  for (; __n > 0; --__n)\n\t    *--__result = std::move(*--__last);\n\t  return __result;\n\t}\n    };\n#endif\n\n  template<bool _IsMove>\n    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>\n    {\n      template<typename _Tp>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _Tp*\n\t__copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)\n\t{\n#if __cplusplus >= 201103L\n\t  using __assignable = conditional<_IsMove,\n\t\t\t\t\t   is_move_assignable<_Tp>,\n\t\t\t\t\t   is_copy_assignable<_Tp>>;\n\t  // trivial types can have deleted assignment\n\t  static_assert( __assignable::type::value, \"type is not assignable\" );\n#endif\n\t  const ptrdiff_t _Num = __last - __first;\n\t  if (_Num)\n\t    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);\n\t  return __result - _Num;\n\t}\n    };\n\n  template<bool _IsMove, typename _BI1, typename _BI2>\n    _GLIBCXX20_CONSTEXPR\n    inline _BI2\n    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)\n    {\n      typedef typename iterator_traits<_BI1>::iterator_category _Category;\n#ifdef __cpp_lib_is_constant_evaluated\n      if (std::is_constant_evaluated())\n\treturn std::__copy_move_backward<_IsMove, false, _Category>::\n\t  __copy_move_b(__first, __last, __result);\n#endif\n      return std::__copy_move_backward<_IsMove,\n\t\t\t\t       __memcpyable<_BI2, _BI1>::__value,\n\t\t\t\t       _Category>::__copy_move_b(__first,\n\t\t\t\t\t\t\t\t __last,\n\t\t\t\t\t\t\t\t __result);\n    }\n\n  template<bool _IsMove, typename _BI1, typename _BI2>\n    _GLIBCXX20_CONSTEXPR\n    inline _BI2\n    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)\n    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }\n\n  template<bool _IsMove,\n\t   typename _Tp, typename _Ref, typename _Ptr, typename _OI>\n    _OI\n    __copy_move_backward_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n\t\t\t    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n\t\t\t    _OI);\n\n  template<bool _IsMove,\n\t   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>\n    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>\n    __copy_move_backward_a1(\n\t\t\t_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,\n\t\t\t_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,\n\t\t\t_GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);\n\n  template<bool _IsMove, typename _II, typename _Tp>\n    typename __gnu_cxx::__enable_if<\n      __is_random_access_iter<_II>::__value,\n      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type\n    __copy_move_backward_a1(_II, _II,\n\t\t\t    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);\n\n  template<bool _IsMove, typename _II, typename _OI>\n    _GLIBCXX20_CONSTEXPR\n    inline _OI\n    __copy_move_backward_a(_II __first, _II __last, _OI __result)\n    {\n      return std::__niter_wrap(__result,\n\t\tstd::__copy_move_backward_a1<_IsMove>\n\t\t  (std::__niter_base(__first), std::__niter_base(__last),\n\t\t   std::__niter_base(__result)));\n    }\n\n  template<bool _IsMove,\n\t   typename _Ite, typename _Seq, typename _Cat, typename _OI>\n    _OI\n    __copy_move_backward_a(\n\t\tconst ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n\t\t_OI);\n\n  template<bool _IsMove,\n\t   typename _II, typename _Ite, typename _Seq, typename _Cat>\n    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>\n    __copy_move_backward_a(_II, _II,\n\t\tconst ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);\n\n  template<bool _IsMove,\n\t   typename _IIte, typename _ISeq, typename _ICat,\n\t   typename _OIte, typename _OSeq, typename _OCat>\n    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>\n    __copy_move_backward_a(\n\t\tconst ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);\n\n  /**\n   *  @brief Copies the range [first,last) into result.\n   *  @ingroup mutating_algorithms\n   *  @param  __first  A bidirectional iterator.\n   *  @param  __last   A bidirectional iterator.\n   *  @param  __result A bidirectional iterator.\n   *  @return   result - (last - first)\n   *\n   *  The function has the same effect as copy, but starts at the end of the\n   *  range and works its way to the start, returning the start of the result.\n   *  This inline function will boil down to a call to @c memmove whenever\n   *  possible.  Failing that, if random access iterators are passed, then the\n   *  loop count will be known (and therefore a candidate for compiler\n   *  optimizations such as unrolling).\n   *\n   *  Result may not be in the range (first,last].  Use copy instead.  Note\n   *  that the start of the output range may overlap [first,last).\n  */\n  template<typename _BI1, typename _BI2>\n    _GLIBCXX20_CONSTEXPR\n    inline _BI2\n    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)\n      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)\n      __glibcxx_function_requires(_ConvertibleConcept<\n\t    typename iterator_traits<_BI1>::value_type,\n\t    typename iterator_traits<_BI2>::value_type>)\n      __glibcxx_requires_can_decrement_range(__first, __last, __result);\n\n      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>\n\t     (std::__miter_base(__first), std::__miter_base(__last), __result);\n    }\n\n#if __cplusplus >= 201103L\n  /**\n   *  @brief Moves the range [first,last) into result.\n   *  @ingroup mutating_algorithms\n   *  @param  __first  A bidirectional iterator.\n   *  @param  __last   A bidirectional iterator.\n   *  @param  __result A bidirectional iterator.\n   *  @return   result - (last - first)\n   *\n   *  The function has the same effect as move, but starts at the end of the\n   *  range and works its way to the start, returning the start of the result.\n   *  This inline function will boil down to a call to @c memmove whenever\n   *  possible.  Failing that, if random access iterators are passed, then the\n   *  loop count will be known (and therefore a candidate for compiler\n   *  optimizations such as unrolling).\n   *\n   *  Result may not be in the range (first,last].  Use move instead.  Note\n   *  that the start of the output range may overlap [first,last).\n  */\n  template<typename _BI1, typename _BI2>\n    _GLIBCXX20_CONSTEXPR\n    inline _BI2\n    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)\n      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)\n      __glibcxx_function_requires(_ConvertibleConcept<\n\t    typename iterator_traits<_BI1>::value_type,\n\t    typename iterator_traits<_BI2>::value_type>)\n      __glibcxx_requires_can_decrement_range(__first, __last, __result);\n\n      return std::__copy_move_backward_a<true>(std::__miter_base(__first),\n\t\t\t\t\t       std::__miter_base(__last),\n\t\t\t\t\t       __result);\n    }\n\n#define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)\n#else\n#define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)\n#endif\n\n  template<typename _ForwardIterator, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline typename\n    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type\n    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,\n\t      const _Tp& __value)\n    {\n      for (; __first != __last; ++__first)\n\t*__first = __value;\n    }\n\n  template<typename _ForwardIterator, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline typename\n    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type\n    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,\n\t      const _Tp& __value)\n    {\n      const _Tp __tmp = __value;\n      for (; __first != __last; ++__first)\n\t*__first = __tmp;\n    }\n\n  // Specialization: for char types we can use memset.\n  template<typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline typename\n    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type\n    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)\n    {\n      const _Tp __tmp = __c;\n#if __cpp_lib_is_constant_evaluated\n      if (std::is_constant_evaluated())\n\t{\n\t  for (; __first != __last; ++__first)\n\t    *__first = __tmp;\n\t  return;\n\t}\n#endif\n      if (const size_t __len = __last - __first)\n\t__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);\n    }\n\n  template<typename _Ite, typename _Cont, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline void\n    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,\n\t      ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,\n\t      const _Tp& __value)\n    { std::__fill_a1(__first.base(), __last.base(), __value); }\n\n  template<typename _Tp, typename _VTp>\n    void\n    __fill_a1(const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,\n\t      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,\n\t      const _VTp&);\n\n  void\n  __fill_a1(_GLIBCXX_STD_C::_Bit_iterator, _GLIBCXX_STD_C::_Bit_iterator,\n\t    const bool&);\n\n  template<typename _FIte, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline void\n    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)\n    { std::__fill_a1(__first, __last, __value); }\n\n  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>\n    void\n    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n\t     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,\n\t     const _Tp&);\n\n  /**\n   *  @brief Fills the range [first,last) with copies of value.\n   *  @ingroup mutating_algorithms\n   *  @param  __first  A forward iterator.\n   *  @param  __last   A forward iterator.\n   *  @param  __value  A reference-to-const of arbitrary type.\n   *  @return   Nothing.\n   *\n   *  This function fills a range with copies of the same value.  For char\n   *  types filling contiguous areas of memory, this becomes an inline call\n   *  to @c memset or @c wmemset.\n  */\n  template<typename _ForwardIterator, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline void\n    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<\n\t\t\t\t  _ForwardIterator>)\n      __glibcxx_requires_valid_range(__first, __last);\n\n      std::__fill_a(__first, __last, __value);\n    }\n\n  // Used by fill_n, generate_n, etc. to convert _Size to an integral type:\n  inline _GLIBCXX_CONSTEXPR int\n  __size_to_integer(int __n) { return __n; }\n  inline _GLIBCXX_CONSTEXPR unsigned\n  __size_to_integer(unsigned __n) { return __n; }\n  inline _GLIBCXX_CONSTEXPR long\n  __size_to_integer(long __n) { return __n; }\n  inline _GLIBCXX_CONSTEXPR unsigned long\n  __size_to_integer(unsigned long __n) { return __n; }\n  inline _GLIBCXX_CONSTEXPR long long\n  __size_to_integer(long long __n) { return __n; }\n  inline _GLIBCXX_CONSTEXPR unsigned long long\n  __size_to_integer(unsigned long long __n) { return __n; }\n\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0\n  __size_to_integer(__GLIBCXX_TYPE_INT_N_0 __n) { return __n; }\n  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_0\n  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_0 __n) { return __n; }\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_1\n  __size_to_integer(__GLIBCXX_TYPE_INT_N_1 __n) { return __n; }\n  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_1\n  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_1 __n) { return __n; }\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_2\n  __size_to_integer(__GLIBCXX_TYPE_INT_N_2 __n) { return __n; }\n  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_2\n  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_2 __n) { return __n; }\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_3\n  __size_to_integer(__GLIBCXX_TYPE_INT_N_3 __n) { return __n; }\n  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_3\n  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_3 __n) { return __n; }\n#endif\n\n  inline _GLIBCXX_CONSTEXPR long long\n  __size_to_integer(float __n) { return (long long)__n; }\n  inline _GLIBCXX_CONSTEXPR long long\n  __size_to_integer(double __n) { return (long long)__n; }\n  inline _GLIBCXX_CONSTEXPR long long\n  __size_to_integer(long double __n) { return (long long)__n; }\n#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)\n  inline _GLIBCXX_CONSTEXPR long long\n  __size_to_integer(__float128 __n) { return (long long)__n; }\n#endif\n\n  template<typename _OutputIterator, typename _Size, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline typename\n    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type\n    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)\n    {\n      for (; __n > 0; --__n, (void) ++__first)\n\t*__first = __value;\n      return __first;\n    }\n\n  template<typename _OutputIterator, typename _Size, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline typename\n    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type\n    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)\n    {\n      const _Tp __tmp = __value;\n      for (; __n > 0; --__n, (void) ++__first)\n\t*__first = __tmp;\n      return __first;\n    }\n\n  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,\n\t   typename _Tp>\n    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>\n    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,\n\t       _Size __n, const _Tp& __value,\n\t       std::input_iterator_tag);\n\n  template<typename _OutputIterator, typename _Size, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline _OutputIterator\n    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,\n\t       std::output_iterator_tag)\n    {\n#if __cplusplus >= 201103L\n      static_assert(is_integral<_Size>{}, \"fill_n must pass integral size\");\n#endif\n      return __fill_n_a1(__first, __n, __value);\n    }\n\n  template<typename _OutputIterator, typename _Size, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline _OutputIterator\n    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,\n\t       std::input_iterator_tag)\n    {\n#if __cplusplus >= 201103L\n      static_assert(is_integral<_Size>{}, \"fill_n must pass integral size\");\n#endif\n      return __fill_n_a1(__first, __n, __value);\n    }\n\n  template<typename _OutputIterator, typename _Size, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline _OutputIterator\n    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,\n\t       std::random_access_iterator_tag)\n    {\n#if __cplusplus >= 201103L\n      static_assert(is_integral<_Size>{}, \"fill_n must pass integral size\");\n#endif\n      if (__n <= 0)\n\treturn __first;\n\n      __glibcxx_requires_can_increment(__first, __n);\n\n      std::__fill_a(__first, __first + __n, __value);\n      return __first + __n;\n    }\n\n  /**\n   *  @brief Fills the range [first,first+n) with copies of value.\n   *  @ingroup mutating_algorithms\n   *  @param  __first  An output iterator.\n   *  @param  __n      The count of copies to perform.\n   *  @param  __value  A reference-to-const of arbitrary type.\n   *  @return   The iterator at first+n.\n   *\n   *  This function fills a range with copies of the same value.  For char\n   *  types filling contiguous areas of memory, this becomes an inline call\n   *  to @c memset or @c wmemset.\n   *\n   *  If @p __n is negative, the function does nothing.\n  */\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // DR 865. More algorithms that throw away information\n  // DR 426. search_n(), fill_n(), and generate_n() with negative n\n  template<typename _OI, typename _Size, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline _OI\n    fill_n(_OI __first, _Size __n, const _Tp& __value)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)\n\n      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,\n\t\t\t       std::__iterator_category(__first));\n    }\n\n  template<bool _BoolType>\n    struct __equal\n    {\n      template<typename _II1, typename _II2>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic bool\n\tequal(_II1 __first1, _II1 __last1, _II2 __first2)\n\t{\n\t  for (; __first1 != __last1; ++__first1, (void) ++__first2)\n\t    if (!(*__first1 == *__first2))\n\t      return false;\n\t  return true;\n\t}\n    };\n\n  template<>\n    struct __equal<true>\n    {\n      template<typename _Tp>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic bool\n\tequal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)\n\t{\n\t  if (const size_t __len = (__last1 - __first1))\n\t    return !std::__memcmp(__first1, __first2, __len);\n\t  return true;\n\t}\n    };\n\n  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>\n    typename __gnu_cxx::__enable_if<\n      __is_random_access_iter<_II>::__value, bool>::__type\n    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n\t\t _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,\n\t\t _II);\n\n  template<typename _Tp1, typename _Ref1, typename _Ptr1,\n\t   typename _Tp2, typename _Ref2, typename _Ptr2>\n    bool\n    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n\t\t _GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n\t\t _GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);\n\n  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>\n    typename __gnu_cxx::__enable_if<\n      __is_random_access_iter<_II>::__value, bool>::__type\n    __equal_aux1(_II, _II,\n\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>);\n\n  template<typename _II1, typename _II2>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)\n    {\n      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n      const bool __simple = ((__is_integer<_ValueType1>::__value\n\t\t\t      || __is_pointer<_ValueType1>::__value)\n\t\t\t     && __memcmpable<_II1, _II2>::__value);\n      return std::__equal<__simple>::equal(__first1, __last1, __first2);\n    }\n\n  template<typename _II1, typename _II2>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)\n    {\n      return std::__equal_aux1(std::__niter_base(__first1),\n\t\t\t       std::__niter_base(__last1),\n\t\t\t       std::__niter_base(__first2));\n    }\n\n  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>\n    bool\n    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,\n\t\t_II2);\n\n  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>\n    bool\n    __equal_aux(_II1, _II1,\n\t\tconst ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);\n\n  template<typename _II1, typename _Seq1, typename _Cat1,\n\t   typename _II2, typename _Seq2, typename _Cat2>\n    bool\n    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);\n\n  template<typename, typename>\n    struct __lc_rai\n    {\n      template<typename _II1, typename _II2>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _II1\n\t__newlast1(_II1, _II1 __last1, _II2, _II2)\n\t{ return __last1; }\n\n      template<typename _II>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic bool\n\t__cnd2(_II __first, _II __last)\n\t{ return __first != __last; }\n    };\n\n  template<>\n    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>\n    {\n      template<typename _RAI1, typename _RAI2>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic _RAI1\n\t__newlast1(_RAI1 __first1, _RAI1 __last1,\n\t\t   _RAI2 __first2, _RAI2 __last2)\n\t{\n\t  const typename iterator_traits<_RAI1>::difference_type\n\t    __diff1 = __last1 - __first1;\n\t  const typename iterator_traits<_RAI2>::difference_type\n\t    __diff2 = __last2 - __first2;\n\t  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;\n\t}\n\n      template<typename _RAI>\n\tstatic _GLIBCXX20_CONSTEXPR bool\n\t__cnd2(_RAI, _RAI)\n\t{ return true; }\n    };\n\n  template<typename _II1, typename _II2, typename _Compare>\n    _GLIBCXX20_CONSTEXPR\n    bool\n    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,\n\t\t\t\t   _II2 __first2, _II2 __last2,\n\t\t\t\t   _Compare __comp)\n    {\n      typedef typename iterator_traits<_II1>::iterator_category _Category1;\n      typedef typename iterator_traits<_II2>::iterator_category _Category2;\n      typedef std::__lc_rai<_Category1, _Category2> __rai_type;\n\n      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);\n      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);\n\t   ++__first1, (void)++__first2)\n\t{\n\t  if (__comp(__first1, __first2))\n\t    return true;\n\t  if (__comp(__first2, __first1))\n\t    return false;\n\t}\n      return __first1 == __last1 && __first2 != __last2;\n    }\n\n  template<bool _BoolType>\n    struct __lexicographical_compare\n    {\n      template<typename _II1, typename _II2>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic bool\n\t__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n\t{\n\t  using __gnu_cxx::__ops::__iter_less_iter;\n\t  return std::__lexicographical_compare_impl(__first1, __last1,\n\t\t\t\t\t\t     __first2, __last2,\n\t\t\t\t\t\t     __iter_less_iter());\n\t}\n\n      template<typename _II1, typename _II2>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic int\n\t__3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n\t{\n\t  while (__first1 != __last1)\n\t    {\n\t      if (__first2 == __last2)\n\t\treturn +1;\n\t      if (*__first1 < *__first2)\n\t\treturn -1;\n\t      if (*__first2 < *__first1)\n\t\treturn +1;\n\t      ++__first1;\n\t      ++__first2;\n\t    }\n\t  return int(__first2 == __last2) - 1;\n\t}\n    };\n\n  template<>\n    struct __lexicographical_compare<true>\n    {\n      template<typename _Tp, typename _Up>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic bool\n\t__lc(const _Tp* __first1, const _Tp* __last1,\n\t     const _Up* __first2, const _Up* __last2)\n\t{ return __3way(__first1, __last1, __first2, __last2) < 0; }\n\n      template<typename _Tp, typename _Up>\n\t_GLIBCXX20_CONSTEXPR\n\tstatic ptrdiff_t\n\t__3way(const _Tp* __first1, const _Tp* __last1,\n\t       const _Up* __first2, const _Up* __last2)\n\t{\n\t  const size_t __len1 = __last1 - __first1;\n\t  const size_t __len2 = __last2 - __first2;\n\t  if (const size_t __len = std::min(__len1, __len2))\n\t    if (int __result = std::__memcmp(__first1, __first2, __len))\n\t      return __result;\n\t  return ptrdiff_t(__len1 - __len2);\n\t}\n    };\n\n  template<typename _II1, typename _II2>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,\n\t\t\t\t   _II2 __first2, _II2 __last2)\n    {\n      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n      typedef typename iterator_traits<_II2>::value_type _ValueType2;\n      const bool __simple =\n\t(__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value\n\t && __is_pointer<_II1>::__value\n\t && __is_pointer<_II2>::__value\n#if __cplusplus > 201703L && __cpp_lib_concepts\n\t // For C++20 iterator_traits<volatile T*>::value_type is non-volatile\n\t // so __is_byte<T> could be true, but we can't use memcmp with\n\t // volatile data.\n\t && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>>\n\t && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>\n#endif\n\t );\n\n      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,\n\t\t\t\t\t\t\t    __first2, __last2);\n    }\n\n  template<typename _Tp1, typename _Ref1, typename _Ptr1,\n\t   typename _Tp2>\n    bool\n    __lexicographical_compare_aux1(\n\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n\t_Tp2*, _Tp2*);\n\n  template<typename _Tp1,\n\t   typename _Tp2, typename _Ref2, typename _Ptr2>\n    bool\n    __lexicographical_compare_aux1(_Tp1*, _Tp1*,\n\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,\n\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);\n\n  template<typename _Tp1, typename _Ref1, typename _Ptr1,\n\t   typename _Tp2, typename _Ref2, typename _Ptr2>\n    bool\n    __lexicographical_compare_aux1(\n\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,\n\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);\n\n  template<typename _II1, typename _II2>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,\n\t\t\t\t  _II2 __first2, _II2 __last2)\n    {\n      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),\n\t\t\t\t\t\t std::__niter_base(__last1),\n\t\t\t\t\t\t std::__niter_base(__first2),\n\t\t\t\t\t\t std::__niter_base(__last2));\n    }\n\n  template<typename _Iter1, typename _Seq1, typename _Cat1,\n\t   typename _II2>\n    bool\n    __lexicographical_compare_aux(\n\t\tconst ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,\n\t\t_II2, _II2);\n\n  template<typename _II1,\n\t   typename _Iter2, typename _Seq2, typename _Cat2>\n    bool\n    __lexicographical_compare_aux(\n\t\t_II1, _II1,\n\t\tconst ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);\n\n  template<typename _Iter1, typename _Seq1, typename _Cat1,\n\t   typename _Iter2, typename _Seq2, typename _Cat2>\n    bool\n    __lexicographical_compare_aux(\n\t\tconst ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,\n\t\tconst ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);\n\n  template<typename _ForwardIterator, typename _Tp, typename _Compare>\n    _GLIBCXX20_CONSTEXPR\n    _ForwardIterator\n    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,\n\t\t  const _Tp& __val, _Compare __comp)\n    {\n      typedef typename iterator_traits<_ForwardIterator>::difference_type\n\t_DistanceType;\n\n      _DistanceType __len = std::distance(__first, __last);\n\n      while (__len > 0)\n\t{\n\t  _DistanceType __half = __len >> 1;\n\t  _ForwardIterator __middle = __first;\n\t  std::advance(__middle, __half);\n\t  if (__comp(__middle, __val))\n\t    {\n\t      __first = __middle;\n\t      ++__first;\n\t      __len = __len - __half - 1;\n\t    }\n\t  else\n\t    __len = __half;\n\t}\n      return __first;\n    }\n\n  /**\n   *  @brief Finds the first position in which @a val could be inserted\n   *         without changing the ordering.\n   *  @param  __first   An iterator.\n   *  @param  __last    Another iterator.\n   *  @param  __val     The search term.\n   *  @return         An iterator pointing to the first element <em>not less\n   *                  than</em> @a val, or end() if every element is less than\n   *                  @a val.\n   *  @ingroup binary_search_algorithms\n  */\n  template<typename _ForwardIterator, typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline _ForwardIterator\n    lower_bound(_ForwardIterator __first, _ForwardIterator __last,\n\t\tconst _Tp& __val)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n      __glibcxx_function_requires(_LessThanOpConcept<\n\t    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)\n      __glibcxx_requires_partitioned_lower(__first, __last, __val);\n\n      return std::__lower_bound(__first, __last, __val,\n\t\t\t\t__gnu_cxx::__ops::__iter_less_val());\n    }\n\n  /// This is a helper function for the sort routines and for random.tcc.\n  //  Precondition: __n > 0.\n  inline _GLIBCXX_CONSTEXPR int\n  __lg(int __n)\n  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }\n\n  inline _GLIBCXX_CONSTEXPR unsigned\n  __lg(unsigned __n)\n  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }\n\n  inline _GLIBCXX_CONSTEXPR long\n  __lg(long __n)\n  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }\n\n  inline _GLIBCXX_CONSTEXPR unsigned long\n  __lg(unsigned long __n)\n  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }\n\n  inline _GLIBCXX_CONSTEXPR long long\n  __lg(long long __n)\n  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }\n\n  inline _GLIBCXX_CONSTEXPR unsigned long long\n  __lg(unsigned long long __n)\n  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }\n\n_GLIBCXX_BEGIN_NAMESPACE_ALGO\n\n  /**\n   *  @brief Tests a range for element-wise equality.\n   *  @ingroup non_mutating_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @return   A boolean true or false.\n   *\n   *  This compares the elements of two ranges using @c == and returns true or\n   *  false depending on whether all of the corresponding elements of the\n   *  ranges are equal.\n  */\n  template<typename _II1, typename _II2>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    equal(_II1 __first1, _II1 __last1, _II2 __first2)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_II1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_II2>)\n      __glibcxx_function_requires(_EqualOpConcept<\n\t    typename iterator_traits<_II1>::value_type,\n\t    typename iterator_traits<_II2>::value_type>)\n      __glibcxx_requires_can_increment_range(__first1, __last1, __first2);\n\n      return std::__equal_aux(__first1, __last1, __first2);\n    }\n\n  /**\n   *  @brief Tests a range for element-wise equality.\n   *  @ingroup non_mutating_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @param __binary_pred A binary predicate @link functors\n   *                  functor@endlink.\n   *  @return         A boolean true or false.\n   *\n   *  This compares the elements of two ranges using the binary_pred\n   *  parameter, and returns true or\n   *  false depending on whether all of the corresponding elements of the\n   *  ranges are equal.\n  */\n  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    equal(_IIter1 __first1, _IIter1 __last1,\n\t  _IIter2 __first2, _BinaryPredicate __binary_pred)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n\n      for (; __first1 != __last1; ++__first1, (void)++__first2)\n\tif (!bool(__binary_pred(*__first1, *__first2)))\n\t  return false;\n      return true;\n    }\n\n#if __cplusplus >= 201103L\n  // 4-iterator version of std::equal<It1, It2> for use in C++11.\n  template<typename _II1, typename _II2>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n    {\n      using _RATag = random_access_iterator_tag;\n      using _Cat1 = typename iterator_traits<_II1>::iterator_category;\n      using _Cat2 = typename iterator_traits<_II2>::iterator_category;\n      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;\n      if (_RAIters())\n\t{\n\t  auto __d1 = std::distance(__first1, __last1);\n\t  auto __d2 = std::distance(__first2, __last2);\n\t  if (__d1 != __d2)\n\t    return false;\n\t  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2);\n\t}\n\n      for (; __first1 != __last1 && __first2 != __last2;\n\t  ++__first1, (void)++__first2)\n\tif (!(*__first1 == *__first2))\n\t  return false;\n      return __first1 == __last1 && __first2 == __last2;\n    }\n\n  // 4-iterator version of std::equal<It1, It2, BinaryPred> for use in C++11.\n  template<typename _II1, typename _II2, typename _BinaryPredicate>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,\n\t     _BinaryPredicate __binary_pred)\n    {\n      using _RATag = random_access_iterator_tag;\n      using _Cat1 = typename iterator_traits<_II1>::iterator_category;\n      using _Cat2 = typename iterator_traits<_II2>::iterator_category;\n      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;\n      if (_RAIters())\n\t{\n\t  auto __d1 = std::distance(__first1, __last1);\n\t  auto __d2 = std::distance(__first2, __last2);\n\t  if (__d1 != __d2)\n\t    return false;\n\t  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2,\n\t\t\t\t       __binary_pred);\n\t}\n\n      for (; __first1 != __last1 && __first2 != __last2;\n\t  ++__first1, (void)++__first2)\n\tif (!bool(__binary_pred(*__first1, *__first2)))\n\t  return false;\n      return __first1 == __last1 && __first2 == __last2;\n    }\n#endif // C++11\n\n#if __cplusplus > 201103L\n\n#define __cpp_lib_robust_nonmodifying_seq_ops 201304\n\n  /**\n   *  @brief Tests a range for element-wise equality.\n   *  @ingroup non_mutating_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @param  __last2   An input iterator.\n   *  @return   A boolean true or false.\n   *\n   *  This compares the elements of two ranges using @c == and returns true or\n   *  false depending on whether all of the corresponding elements of the\n   *  ranges are equal.\n  */\n  template<typename _II1, typename _II2>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_II1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_II2>)\n      __glibcxx_function_requires(_EqualOpConcept<\n\t    typename iterator_traits<_II1>::value_type,\n\t    typename iterator_traits<_II2>::value_type>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n      __glibcxx_requires_valid_range(__first2, __last2);\n\n      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2);\n    }\n\n  /**\n   *  @brief Tests a range for element-wise equality.\n   *  @ingroup non_mutating_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @param  __last2   An input iterator.\n   *  @param __binary_pred A binary predicate @link functors\n   *                  functor@endlink.\n   *  @return         A boolean true or false.\n   *\n   *  This compares the elements of two ranges using the binary_pred\n   *  parameter, and returns true or\n   *  false depending on whether all of the corresponding elements of the\n   *  ranges are equal.\n  */\n  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    equal(_IIter1 __first1, _IIter1 __last1,\n\t  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n      __glibcxx_requires_valid_range(__first2, __last2);\n\n      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2,\n\t\t\t\t      __binary_pred);\n    }\n#endif // C++14\n\n  /**\n   *  @brief Performs @b dictionary comparison on ranges.\n   *  @ingroup sorting_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @param  __last2   An input iterator.\n   *  @return   A boolean true or false.\n   *\n   *  <em>Returns true if the sequence of elements defined by the range\n   *  [first1,last1) is lexicographically less than the sequence of elements\n   *  defined by the range [first2,last2).  Returns false otherwise.</em>\n   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,\n   *  then this is an inline call to @c memcmp.\n  */\n  template<typename _II1, typename _II2>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    lexicographical_compare(_II1 __first1, _II1 __last1,\n\t\t\t    _II2 __first2, _II2 __last2)\n    {\n#ifdef _GLIBCXX_CONCEPT_CHECKS\n      // concept requirements\n      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n      typedef typename iterator_traits<_II2>::value_type _ValueType2;\n#endif\n      __glibcxx_function_requires(_InputIteratorConcept<_II1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_II2>)\n      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)\n      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n      __glibcxx_requires_valid_range(__first2, __last2);\n\n      return std::__lexicographical_compare_aux(__first1, __last1,\n\t\t\t\t\t\t__first2, __last2);\n    }\n\n  /**\n   *  @brief Performs @b dictionary comparison on ranges.\n   *  @ingroup sorting_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @param  __last2   An input iterator.\n   *  @param  __comp  A @link comparison_functors comparison functor@endlink.\n   *  @return   A boolean true or false.\n   *\n   *  The same as the four-parameter @c lexicographical_compare, but uses the\n   *  comp parameter instead of @c <.\n  */\n  template<typename _II1, typename _II2, typename _Compare>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    lexicographical_compare(_II1 __first1, _II1 __last1,\n\t\t\t    _II2 __first2, _II2 __last2, _Compare __comp)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_II1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_II2>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n      __glibcxx_requires_valid_range(__first2, __last2);\n\n      return std::__lexicographical_compare_impl\n\t(__first1, __last1, __first2, __last2,\n\t __gnu_cxx::__ops::__iter_comp_iter(__comp));\n    }\n\n#if __cpp_lib_three_way_comparison\n  // Iter points to a contiguous range of unsigned narrow character type\n  // or std::byte, suitable for comparison by memcmp.\n  template<typename _Iter>\n    concept __is_byte_iter = contiguous_iterator<_Iter>\n      && __is_memcmp_ordered<iter_value_t<_Iter>>::__value;\n\n  // Return a struct with two members, initialized to the smaller of x and y\n  // (or x if they compare equal) and the result of the comparison x <=> y.\n  template<typename _Tp>\n    constexpr auto\n    __min_cmp(_Tp __x, _Tp __y)\n    {\n      struct _Res {\n\t_Tp _M_min;\n\tdecltype(__x <=> __y) _M_cmp;\n      };\n      auto __c = __x <=> __y;\n      if (__c > 0)\n\treturn _Res{__y, __c};\n      return _Res{__x, __c};\n    }\n\n  /**\n   *  @brief Performs dictionary comparison on ranges.\n   *  @ingroup sorting_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @param  __last2   An input iterator.\n   *  @param  __comp  A @link comparison_functors comparison functor@endlink.\n   *  @return   The comparison category that `__comp(*__first1, *__first2)`\n   *\t\treturns.\n  */\n  template<typename _InputIter1, typename _InputIter2, typename _Comp>\n    constexpr auto\n    lexicographical_compare_three_way(_InputIter1 __first1,\n\t\t\t\t      _InputIter1 __last1,\n\t\t\t\t      _InputIter2 __first2,\n\t\t\t\t      _InputIter2 __last2,\n\t\t\t\t      _Comp __comp)\n    -> decltype(__comp(*__first1, *__first2))\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIter1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIter2>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n      __glibcxx_requires_valid_range(__first2, __last2);\n\n#if __cpp_lib_is_constant_evaluated\n      using _Cat = decltype(__comp(*__first1, *__first2));\n      static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);\n\n      if (!std::is_constant_evaluated())\n\tif constexpr (same_as<_Comp, __detail::_Synth3way>\n\t\t      || same_as<_Comp, compare_three_way>)\n\t  if constexpr (__is_byte_iter<_InputIter1>)\n\t    if constexpr (__is_byte_iter<_InputIter2>)\n\t      {\n\t\tconst auto [__len, __lencmp] = _GLIBCXX_STD_A::\n\t\t  __min_cmp(__last1 - __first1, __last2 - __first2);\n\t\tif (__len)\n\t\t  {\n\t\t    const auto __c\n\t\t      = __builtin_memcmp(&*__first1, &*__first2, __len) <=> 0;\n\t\t    if (__c != 0)\n\t\t      return __c;\n\t\t  }\n\t\treturn __lencmp;\n\t      }\n#endif // is_constant_evaluated\n      while (__first1 != __last1)\n\t{\n\t  if (__first2 == __last2)\n\t    return strong_ordering::greater;\n\t  if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)\n\t    return __cmp;\n\t  ++__first1;\n\t  ++__first2;\n\t}\n      return (__first2 == __last2) <=> true; // See PR 94006\n    }\n\n  template<typename _InputIter1, typename _InputIter2>\n    constexpr auto\n    lexicographical_compare_three_way(_InputIter1 __first1,\n\t\t\t\t      _InputIter1 __last1,\n\t\t\t\t      _InputIter2 __first2,\n\t\t\t\t      _InputIter2 __last2)\n    {\n      return _GLIBCXX_STD_A::\n\tlexicographical_compare_three_way(__first1, __last1, __first2, __last2,\n\t\t\t\t\t  compare_three_way{});\n    }\n#endif // three_way_comparison\n\n  template<typename _InputIterator1, typename _InputIterator2,\n\t   typename _BinaryPredicate>\n    _GLIBCXX20_CONSTEXPR\n    pair<_InputIterator1, _InputIterator2>\n    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n\t       _InputIterator2 __first2, _BinaryPredicate __binary_pred)\n    {\n      while (__first1 != __last1 && __binary_pred(__first1, __first2))\n\t{\n\t  ++__first1;\n\t  ++__first2;\n\t}\n      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n    }\n\n  /**\n   *  @brief Finds the places in ranges which don't match.\n   *  @ingroup non_mutating_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @return   A pair of iterators pointing to the first mismatch.\n   *\n   *  This compares the elements of two ranges using @c == and returns a pair\n   *  of iterators.  The first iterator points into the first range, the\n   *  second iterator points into the second range, and the elements pointed\n   *  to by the iterators are not equal.\n  */\n  template<typename _InputIterator1, typename _InputIterator2>\n    _GLIBCXX20_CONSTEXPR\n    inline pair<_InputIterator1, _InputIterator2>\n    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n\t     _InputIterator2 __first2)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n      __glibcxx_function_requires(_EqualOpConcept<\n\t    typename iterator_traits<_InputIterator1>::value_type,\n\t    typename iterator_traits<_InputIterator2>::value_type>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n\n      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,\n\t\t\t     __gnu_cxx::__ops::__iter_equal_to_iter());\n    }\n\n  /**\n   *  @brief Finds the places in ranges which don't match.\n   *  @ingroup non_mutating_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @param __binary_pred A binary predicate @link functors\n   *         functor@endlink.\n   *  @return   A pair of iterators pointing to the first mismatch.\n   *\n   *  This compares the elements of two ranges using the binary_pred\n   *  parameter, and returns a pair\n   *  of iterators.  The first iterator points into the first range, the\n   *  second iterator points into the second range, and the elements pointed\n   *  to by the iterators are not equal.\n  */\n  template<typename _InputIterator1, typename _InputIterator2,\n\t   typename _BinaryPredicate>\n    _GLIBCXX20_CONSTEXPR\n    inline pair<_InputIterator1, _InputIterator2>\n    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n\t     _InputIterator2 __first2, _BinaryPredicate __binary_pred)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n\n      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,\n\t__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));\n    }\n\n#if __cplusplus > 201103L\n\n  template<typename _InputIterator1, typename _InputIterator2,\n\t   typename _BinaryPredicate>\n    _GLIBCXX20_CONSTEXPR\n    pair<_InputIterator1, _InputIterator2>\n    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n\t       _InputIterator2 __first2, _InputIterator2 __last2,\n\t       _BinaryPredicate __binary_pred)\n    {\n      while (__first1 != __last1 && __first2 != __last2\n\t     && __binary_pred(__first1, __first2))\n\t{\n\t  ++__first1;\n\t  ++__first2;\n\t}\n      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n    }\n\n  /**\n   *  @brief Finds the places in ranges which don't match.\n   *  @ingroup non_mutating_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @param  __last2   An input iterator.\n   *  @return   A pair of iterators pointing to the first mismatch.\n   *\n   *  This compares the elements of two ranges using @c == and returns a pair\n   *  of iterators.  The first iterator points into the first range, the\n   *  second iterator points into the second range, and the elements pointed\n   *  to by the iterators are not equal.\n  */\n  template<typename _InputIterator1, typename _InputIterator2>\n    _GLIBCXX20_CONSTEXPR\n    inline pair<_InputIterator1, _InputIterator2>\n    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n\t     _InputIterator2 __first2, _InputIterator2 __last2)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n      __glibcxx_function_requires(_EqualOpConcept<\n\t    typename iterator_traits<_InputIterator1>::value_type,\n\t    typename iterator_traits<_InputIterator2>::value_type>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n      __glibcxx_requires_valid_range(__first2, __last2);\n\n      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,\n\t\t\t     __gnu_cxx::__ops::__iter_equal_to_iter());\n    }\n\n  /**\n   *  @brief Finds the places in ranges which don't match.\n   *  @ingroup non_mutating_algorithms\n   *  @param  __first1  An input iterator.\n   *  @param  __last1   An input iterator.\n   *  @param  __first2  An input iterator.\n   *  @param  __last2   An input iterator.\n   *  @param __binary_pred A binary predicate @link functors\n   *         functor@endlink.\n   *  @return   A pair of iterators pointing to the first mismatch.\n   *\n   *  This compares the elements of two ranges using the binary_pred\n   *  parameter, and returns a pair\n   *  of iterators.  The first iterator points into the first range, the\n   *  second iterator points into the second range, and the elements pointed\n   *  to by the iterators are not equal.\n  */\n  template<typename _InputIterator1, typename _InputIterator2,\n\t   typename _BinaryPredicate>\n    _GLIBCXX20_CONSTEXPR\n    inline pair<_InputIterator1, _InputIterator2>\n    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n\t     _InputIterator2 __first2, _InputIterator2 __last2,\n\t     _BinaryPredicate __binary_pred)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n      __glibcxx_requires_valid_range(__first2, __last2);\n\n      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,\n\t\t\t     __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));\n    }\n#endif\n\n_GLIBCXX_END_NAMESPACE_ALGO\n\n  /// This is an overload used by find algos for the Input Iterator case.\n  template<typename _InputIterator, typename _Predicate>\n    _GLIBCXX20_CONSTEXPR\n    inline _InputIterator\n    __find_if(_InputIterator __first, _InputIterator __last,\n\t      _Predicate __pred, input_iterator_tag)\n    {\n      while (__first != __last && !__pred(__first))\n\t++__first;\n      return __first;\n    }\n\n  /// This is an overload used by find algos for the RAI case.\n  template<typename _RandomAccessIterator, typename _Predicate>\n    _GLIBCXX20_CONSTEXPR\n    _RandomAccessIterator\n    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,\n\t      _Predicate __pred, random_access_iterator_tag)\n    {\n      typename iterator_traits<_RandomAccessIterator>::difference_type\n\t__trip_count = (__last - __first) >> 2;\n\n      for (; __trip_count > 0; --__trip_count)\n\t{\n\t  if (__pred(__first))\n\t    return __first;\n\t  ++__first;\n\n\t  if (__pred(__first))\n\t    return __first;\n\t  ++__first;\n\n\t  if (__pred(__first))\n\t    return __first;\n\t  ++__first;\n\n\t  if (__pred(__first))\n\t    return __first;\n\t  ++__first;\n\t}\n\n      switch (__last - __first)\n\t{\n\tcase 3:\n\t  if (__pred(__first))\n\t    return __first;\n\t  ++__first;\n\t  // FALLTHRU\n\tcase 2:\n\t  if (__pred(__first))\n\t    return __first;\n\t  ++__first;\n\t  // FALLTHRU\n\tcase 1:\n\t  if (__pred(__first))\n\t    return __first;\n\t  ++__first;\n\t  // FALLTHRU\n\tcase 0:\n\tdefault:\n\t  return __last;\n\t}\n    }\n\n  template<typename _Iterator, typename _Predicate>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iterator\n    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)\n    {\n      return __find_if(__first, __last, __pred,\n\t\t       std::__iterator_category(__first));\n    }\n\n  template<typename _InputIterator, typename _Predicate>\n    _GLIBCXX20_CONSTEXPR\n    typename iterator_traits<_InputIterator>::difference_type\n    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n    {\n      typename iterator_traits<_InputIterator>::difference_type __n = 0;\n      for (; __first != __last; ++__first)\n\tif (__pred(__first))\n\t  ++__n;\n      return __n;\n    }\n\n#if __cplusplus >= 201103L\n  template<typename _ForwardIterator1, typename _ForwardIterator2,\n\t   typename _BinaryPredicate>\n    _GLIBCXX20_CONSTEXPR\n    bool\n    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n\t\t     _ForwardIterator2 __first2, _BinaryPredicate __pred)\n    {\n      // Efficiently compare identical prefixes:  O(N) if sequences\n      // have the same elements in the same order.\n      for (; __first1 != __last1; ++__first1, (void)++__first2)\n\tif (!__pred(__first1, __first2))\n\t  break;\n\n      if (__first1 == __last1)\n\treturn true;\n\n      // Establish __last2 assuming equal ranges by iterating over the\n      // rest of the list.\n      _ForwardIterator2 __last2 = __first2;\n      std::advance(__last2, std::distance(__first1, __last1));\n      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)\n\t{\n\t  if (__scan != std::__find_if(__first1, __scan,\n\t\t\t  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))\n\t    continue; // We've seen this one before.\n\n\t  auto __matches\n\t    = std::__count_if(__first2, __last2,\n\t\t\t__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));\n\t  if (0 == __matches ||\n\t      std::__count_if(__scan, __last1,\n\t\t\t__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))\n\t      != __matches)\n\t    return false;\n\t}\n      return true;\n    }\n\n  /**\n   *  @brief  Checks whether a permutation of the second sequence is equal\n   *          to the first sequence.\n   *  @ingroup non_mutating_algorithms\n   *  @param  __first1  Start of first range.\n   *  @param  __last1   End of first range.\n   *  @param  __first2  Start of second range.\n   *  @return true if there exists a permutation of the elements in the range\n   *          [__first2, __first2 + (__last1 - __first1)), beginning with\n   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)\n   *          returns true; otherwise, returns false.\n  */\n  template<typename _ForwardIterator1, typename _ForwardIterator2>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n\t\t   _ForwardIterator2 __first2)\n    {\n      // concept requirements\n      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)\n      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)\n      __glibcxx_function_requires(_EqualOpConcept<\n\t\ttypename iterator_traits<_ForwardIterator1>::value_type,\n\t\ttypename iterator_traits<_ForwardIterator2>::value_type>)\n      __glibcxx_requires_valid_range(__first1, __last1);\n\n      return std::__is_permutation(__first1, __last1, __first2,\n\t\t\t\t   __gnu_cxx::__ops::__iter_equal_to_iter());\n    }\n#endif // C++11\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n// NB: This file is included within many other C++ includes, as a way\n// of getting the base algorithms. So, make sure that parallel bits\n// come in too if requested.\n#ifdef _GLIBCXX_PARALLEL\n# include <parallel/algobase.h>\n#endif\n\n#endif\n"}],"crc32":3204635405,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]