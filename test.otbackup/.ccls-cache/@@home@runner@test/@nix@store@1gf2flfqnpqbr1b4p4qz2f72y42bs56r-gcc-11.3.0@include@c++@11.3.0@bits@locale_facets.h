[{"ops":[{"insert":"// Locale support -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/locale_facets.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{locale}\n */\n\n//\n// ISO C++ 14882: 22.1  Locales\n//\n\n#ifndef _LOCALE_FACETS_H\n#define _LOCALE_FACETS_H 1\n\n#pragma GCC system_header\n\n#include <cwctype>\t// For wctype_t\n#include <cctype>\n#include <bits/ctype_base.h>\n#include <iosfwd>\n#include <bits/ios_base.h>  // For ios_base, ios_base::iostate\n#include <streambuf>\n#include <bits/cpp_type_traits.h>\n#include <ext/type_traits.h>\n#include <ext/numeric_traits.h>\n#include <bits/streambuf_iterator.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n// Number of standard facets (for narrow characters only)\n#define  _GLIBCXX_NUM_FACETS 14\n\n// Number of duplicated facets for cxx11 ABI\n#define  _GLIBCXX_NUM_CXX11_FACETS (_GLIBCXX_USE_DUAL_ABI ? 8 : 0)\n\n// codecvt<char16_t> and codecvt<char32_t>\n#ifdef _GLIBCXX_USE_CHAR8_T\n# define _GLIBCXX_NUM_UNICODE_FACETS 4\n#else\n# define _GLIBCXX_NUM_UNICODE_FACETS 2\n#endif\n\n// Facets duplicated for alt128 long double format\n// num_get, num_put, money_get, money_put (+ cxx11 money_get, money_put)\n#define _GLIBCXX_NUM_LBDL_ALT128_FACETS (4 + (_GLIBCXX_USE_DUAL_ABI ? 2 : 0))\n\n  // Convert string to numeric value of type _Tp and store results.\n  // NB: This is specialized for all required types, there is no\n  // generic definition.\n  template<typename _Tp>\n    void\n    __convert_to_v(const char*, _Tp&, ios_base::iostate&,\n\t\t   const __c_locale&) throw();\n\n  // Explicit specializations for required types.\n  template<>\n    void\n    __convert_to_v(const char*, float&, ios_base::iostate&,\n\t\t   const __c_locale&) throw();\n\n  template<>\n    void\n    __convert_to_v(const char*, double&, ios_base::iostate&,\n\t\t   const __c_locale&) throw();\n\n  template<>\n    void\n    __convert_to_v(const char*, long double&, ios_base::iostate&,\n\t\t   const __c_locale&) throw();\n\n  // NB: __pad is a struct, rather than a function, so it can be\n  // partially-specialized.\n  template<typename _CharT, typename _Traits>\n    struct __pad\n    {\n      static void\n      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,\n\t     const _CharT* __olds, streamsize __newlen, streamsize __oldlen);\n    };\n\n  // Used by both numeric and monetary facets.\n  // Inserts \"group separator\" characters into an array of characters.\n  // It's recursive, one iteration per group.  It moves the characters\n  // in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".  Call this\n  // only with __gsize != 0.\n  template<typename _CharT>\n    _CharT*\n    __add_grouping(_CharT* __s, _CharT __sep,\n\t\t   const char* __gbeg, size_t __gsize,\n\t\t   const _CharT* __first, const _CharT* __last);\n\n  // This template permits specializing facet output code for\n  // ostreambuf_iterator.  For ostreambuf_iterator, sputn is\n  // significantly more efficient than incrementing iterators.\n  template<typename _CharT>\n    inline\n    ostreambuf_iterator<_CharT>\n    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)\n    {\n      __s._M_put(__ws, __len);\n      return __s;\n    }\n\n  // This is the unspecialized form of the template.\n  template<typename _CharT, typename _OutIter>\n    inline\n    _OutIter\n    __write(_OutIter __s, const _CharT* __ws, int __len)\n    {\n      for (int __j = 0; __j < __len; __j++, ++__s)\n\t*__s = __ws[__j];\n      return __s;\n    }\n\n\n  // 22.2.1.1  Template class ctype\n  // Include host and configuration specific ctype enums for ctype_base.\n\n  /**\n   *  @brief  Common base for ctype facet\n   *\n   *  This template class provides implementations of the public functions\n   *  that forward to the protected virtual functions.\n   *\n   *  This template also provides abstract stubs for the protected virtual\n   *  functions.\n  */\n  template<typename _CharT>\n    class __ctype_abstract_base : public locale::facet, public ctype_base\n    {\n    public:\n      // Types:\n      /// Typedef for the template parameter\n      typedef _CharT char_type;\n\n      /**\n       *  @brief  Test char_type classification.\n       *\n       *  This function finds a mask M for @a __c and compares it to\n       *  mask @a __m.  It does so by returning the value of\n       *  ctype<char_type>::do_is().\n       *\n       *  @param __c  The char_type to compare the mask of.\n       *  @param __m  The mask to compare against.\n       *  @return  (M & __m) != 0.\n      */\n      bool\n      is(mask __m, char_type __c) const\n      { return this->do_is(__m, __c); }\n\n      /**\n       *  @brief  Return a mask array.\n       *\n       *  This function finds the mask for each char_type in the range [lo,hi)\n       *  and successively writes it to vec.  vec must have as many elements\n       *  as the char array.  It does so by returning the value of\n       *  ctype<char_type>::do_is().\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __vec  Pointer to an array of mask storage.\n       *  @return  @a __hi.\n      */\n      const char_type*\n      is(const char_type *__lo, const char_type *__hi, mask *__vec) const\n      { return this->do_is(__lo, __hi, __vec); }\n\n      /**\n       *  @brief  Find char_type matching a mask\n       *\n       *  This function searches for and returns the first char_type c in\n       *  [lo,hi) for which is(m,c) is true.  It does so by returning\n       *  ctype<char_type>::do_scan_is().\n       *\n       *  @param __m  The mask to compare against.\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  Pointer to matching char_type if found, else @a __hi.\n      */\n      const char_type*\n      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const\n      { return this->do_scan_is(__m, __lo, __hi); }\n\n      /**\n       *  @brief  Find char_type not matching a mask\n       *\n       *  This function searches for and returns the first char_type c in\n       *  [lo,hi) for which is(m,c) is false.  It does so by returning\n       *  ctype<char_type>::do_scan_not().\n       *\n       *  @param __m  The mask to compare against.\n       *  @param __lo  Pointer to first char in range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  Pointer to non-matching char if found, else @a __hi.\n      */\n      const char_type*\n      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const\n      { return this->do_scan_not(__m, __lo, __hi); }\n\n      /**\n       *  @brief  Convert to uppercase.\n       *\n       *  This function converts the argument to uppercase if possible.\n       *  If not possible (for example, '2'), returns the argument.  It does\n       *  so by returning ctype<char_type>::do_toupper().\n       *\n       *  @param __c  The char_type to convert.\n       *  @return  The uppercase char_type if convertible, else @a __c.\n      */\n      char_type\n      toupper(char_type __c) const\n      { return this->do_toupper(__c); }\n\n      /**\n       *  @brief  Convert array to uppercase.\n       *\n       *  This function converts each char_type in the range [lo,hi) to\n       *  uppercase if possible.  Other elements remain untouched.  It does so\n       *  by returning ctype<char_type>:: do_toupper(lo, hi).\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      const char_type*\n      toupper(char_type *__lo, const char_type* __hi) const\n      { return this->do_toupper(__lo, __hi); }\n\n      /**\n       *  @brief  Convert to lowercase.\n       *\n       *  This function converts the argument to lowercase if possible.  If\n       *  not possible (for example, '2'), returns the argument.  It does so\n       *  by returning ctype<char_type>::do_tolower(c).\n       *\n       *  @param __c  The char_type to convert.\n       *  @return  The lowercase char_type if convertible, else @a __c.\n      */\n      char_type\n      tolower(char_type __c) const\n      { return this->do_tolower(__c); }\n\n      /**\n       *  @brief  Convert array to lowercase.\n       *\n       *  This function converts each char_type in the range [__lo,__hi) to\n       *  lowercase if possible.  Other elements remain untouched.  It does so\n       *  by returning ctype<char_type>:: do_tolower(__lo, __hi).\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      const char_type*\n      tolower(char_type* __lo, const char_type* __hi) const\n      { return this->do_tolower(__lo, __hi); }\n\n      /**\n       *  @brief  Widen char to char_type\n       *\n       *  This function converts the char argument to char_type using the\n       *  simplest reasonable transformation.  It does so by returning\n       *  ctype<char_type>::do_widen(c).\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The char to convert.\n       *  @return  The converted char_type.\n      */\n      char_type\n      widen(char __c) const\n      { return this->do_widen(__c); }\n\n      /**\n       *  @brief  Widen array to char_type\n       *\n       *  This function converts each char in the input to char_type using the\n       *  simplest reasonable transformation.  It does so by returning\n       *  ctype<char_type>::do_widen(c).\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      const char*\n      widen(const char* __lo, const char* __hi, char_type* __to) const\n      { return this->do_widen(__lo, __hi, __to); }\n\n      /**\n       *  @brief  Narrow char_type to char\n       *\n       *  This function converts the char_type to char using the simplest\n       *  reasonable transformation.  If the conversion fails, dfault is\n       *  returned instead.  It does so by returning\n       *  ctype<char_type>::do_narrow(__c).\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The char_type to convert.\n       *  @param __dfault  Char to return if conversion fails.\n       *  @return  The converted char.\n      */\n      char\n      narrow(char_type __c, char __dfault) const\n      { return this->do_narrow(__c, __dfault); }\n\n      /**\n       *  @brief  Narrow array to char array\n       *\n       *  This function converts each char_type in the input to char using the\n       *  simplest reasonable transformation and writes the results to the\n       *  destination array.  For any char_type in the input that cannot be\n       *  converted, @a dfault is used instead.  It does so by returning\n       *  ctype<char_type>::do_narrow(__lo, __hi, __dfault, __to).\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __dfault  Char to use if conversion fails.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      const char_type*\n      narrow(const char_type* __lo, const char_type* __hi,\n\t      char __dfault, char* __to) const\n      { return this->do_narrow(__lo, __hi, __dfault, __to); }\n\n    protected:\n      explicit\n      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }\n\n      virtual\n      ~__ctype_abstract_base() { }\n\n      /**\n       *  @brief  Test char_type classification.\n       *\n       *  This function finds a mask M for @a c and compares it to mask @a m.\n       *\n       *  do_is() is a hook for a derived facet to change the behavior of\n       *  classifying.  do_is() must always return the same result for the\n       *  same input.\n       *\n       *  @param __c  The char_type to find the mask of.\n       *  @param __m  The mask to compare against.\n       *  @return  (M & __m) != 0.\n      */\n      virtual bool\n      do_is(mask __m, char_type __c) const = 0;\n\n      /**\n       *  @brief  Return a mask array.\n       *\n       *  This function finds the mask for each char_type in the range [lo,hi)\n       *  and successively writes it to vec.  vec must have as many elements\n       *  as the input.\n       *\n       *  do_is() is a hook for a derived facet to change the behavior of\n       *  classifying.  do_is() must always return the same result for the\n       *  same input.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __vec  Pointer to an array of mask storage.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_is(const char_type* __lo, const char_type* __hi,\n\t    mask* __vec) const = 0;\n\n      /**\n       *  @brief  Find char_type matching mask\n       *\n       *  This function searches for and returns the first char_type c in\n       *  [__lo,__hi) for which is(__m,c) is true.\n       *\n       *  do_scan_is() is a hook for a derived facet to change the behavior of\n       *  match searching.  do_is() must always return the same result for the\n       *  same input.\n       *\n       *  @param __m  The mask to compare against.\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  Pointer to a matching char_type if found, else @a __hi.\n      */\n      virtual const char_type*\n      do_scan_is(mask __m, const char_type* __lo,\n\t\t const char_type* __hi) const = 0;\n\n      /**\n       *  @brief  Find char_type not matching mask\n       *\n       *  This function searches for and returns a pointer to the first\n       *  char_type c of [lo,hi) for which is(m,c) is false.\n       *\n       *  do_scan_is() is a hook for a derived facet to change the behavior of\n       *  match searching.  do_is() must always return the same result for the\n       *  same input.\n       *\n       *  @param __m  The mask to compare against.\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  Pointer to a non-matching char_type if found, else @a __hi.\n      */\n      virtual const char_type*\n      do_scan_not(mask __m, const char_type* __lo,\n\t\t  const char_type* __hi) const = 0;\n\n      /**\n       *  @brief  Convert to uppercase.\n       *\n       *  This virtual function converts the char_type argument to uppercase\n       *  if possible.  If not possible (for example, '2'), returns the\n       *  argument.\n       *\n       *  do_toupper() is a hook for a derived facet to change the behavior of\n       *  uppercasing.  do_toupper() must always return the same result for\n       *  the same input.\n       *\n       *  @param __c  The char_type to convert.\n       *  @return  The uppercase char_type if convertible, else @a __c.\n      */\n      virtual char_type\n      do_toupper(char_type __c) const = 0;\n\n      /**\n       *  @brief  Convert array to uppercase.\n       *\n       *  This virtual function converts each char_type in the range [__lo,__hi)\n       *  to uppercase if possible.  Other elements remain untouched.\n       *\n       *  do_toupper() is a hook for a derived facet to change the behavior of\n       *  uppercasing.  do_toupper() must always return the same result for\n       *  the same input.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const = 0;\n\n      /**\n       *  @brief  Convert to lowercase.\n       *\n       *  This virtual function converts the argument to lowercase if\n       *  possible.  If not possible (for example, '2'), returns the argument.\n       *\n       *  do_tolower() is a hook for a derived facet to change the behavior of\n       *  lowercasing.  do_tolower() must always return the same result for\n       *  the same input.\n       *\n       *  @param __c  The char_type to convert.\n       *  @return  The lowercase char_type if convertible, else @a __c.\n      */\n      virtual char_type\n      do_tolower(char_type __c) const = 0;\n\n      /**\n       *  @brief  Convert array to lowercase.\n       *\n       *  This virtual function converts each char_type in the range [__lo,__hi)\n       *  to lowercase if possible.  Other elements remain untouched.\n       *\n       *  do_tolower() is a hook for a derived facet to change the behavior of\n       *  lowercasing.  do_tolower() must always return the same result for\n       *  the same input.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const = 0;\n\n      /**\n       *  @brief  Widen char\n       *\n       *  This virtual function converts the char to char_type using the\n       *  simplest reasonable transformation.\n       *\n       *  do_widen() is a hook for a derived facet to change the behavior of\n       *  widening.  do_widen() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The char to convert.\n       *  @return  The converted char_type\n      */\n      virtual char_type\n      do_widen(char __c) const = 0;\n\n      /**\n       *  @brief  Widen char array\n       *\n       *  This function converts each char in the input to char_type using the\n       *  simplest reasonable transformation.\n       *\n       *  do_widen() is a hook for a derived facet to change the behavior of\n       *  widening.  do_widen() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to start range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      virtual const char*\n      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;\n\n      /**\n       *  @brief  Narrow char_type to char\n       *\n       *  This virtual function converts the argument to char using the\n       *  simplest reasonable transformation.  If the conversion fails, dfault\n       *  is returned instead.\n       *\n       *  do_narrow() is a hook for a derived facet to change the behavior of\n       *  narrowing.  do_narrow() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The char_type to convert.\n       *  @param __dfault  Char to return if conversion fails.\n       *  @return  The converted char.\n      */\n      virtual char\n      do_narrow(char_type __c, char __dfault) const = 0;\n\n      /**\n       *  @brief  Narrow char_type array to char\n       *\n       *  This virtual function converts each char_type in the range\n       *  [__lo,__hi) to char using the simplest reasonable\n       *  transformation and writes the results to the destination\n       *  array.  For any element in the input that cannot be\n       *  converted, @a __dfault is used instead.\n       *\n       *  do_narrow() is a hook for a derived facet to change the behavior of\n       *  narrowing.  do_narrow() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __dfault  Char to use if conversion fails.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi,\n\t\tchar __dfault, char* __to) const = 0;\n    };\n\n  /**\n   *  @brief  Primary class template ctype facet.\n   *  @ingroup locales\n   *\n   *  This template class defines classification and conversion functions for\n   *  character sets.  It wraps cctype functionality.  Ctype gets used by\n   *  streams for many I/O operations.\n   *\n   *  This template provides the protected virtual functions the developer\n   *  will have to replace in a derived class or specialization to make a\n   *  working facet.  The public functions that access them are defined in\n   *  __ctype_abstract_base, to allow for implementation flexibility.  See\n   *  ctype<wchar_t> for an example.  The functions are documented in\n   *  __ctype_abstract_base.\n   *\n   *  Note: implementations are provided for all the protected virtual\n   *  functions, but will likely not be useful.\n  */\n  template<typename _CharT>\n    class ctype : public __ctype_abstract_base<_CharT>\n    {\n    public:\n      // Types:\n      typedef _CharT\t\t\tchar_type;\n      typedef typename __ctype_abstract_base<_CharT>::mask mask;\n\n      /// The facet id for ctype<char_type>\n      static locale::id\t\t\tid;\n\n      explicit\n      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }\n\n   protected:\n      virtual\n      ~ctype();\n\n      virtual bool\n      do_is(mask __m, char_type __c) const;\n\n      virtual const char_type*\n      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;\n\n      virtual const char_type*\n      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;\n\n      virtual const char_type*\n      do_scan_not(mask __m, const char_type* __lo,\n\t\t  const char_type* __hi) const;\n\n      virtual char_type\n      do_toupper(char_type __c) const;\n\n      virtual const char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const;\n\n      virtual char_type\n      do_tolower(char_type __c) const;\n\n      virtual const char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const;\n\n      virtual char_type\n      do_widen(char __c) const;\n\n      virtual const char*\n      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;\n\n      virtual char\n      do_narrow(char_type, char __dfault) const;\n\n      virtual const char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi,\n\t\tchar __dfault, char* __to) const;\n    };\n\n  template<typename _CharT>\n    locale::id ctype<_CharT>::id;\n\n  /**\n   *  @brief  The ctype<char> specialization.\n   *  @ingroup locales\n   *\n   *  This class defines classification and conversion functions for\n   *  the char type.  It gets used by char streams for many I/O\n   *  operations.  The char specialization provides a number of\n   *  optimizations as well.\n  */\n  template<>\n    class ctype<char> : public locale::facet, public ctype_base\n    {\n    public:\n      // Types:\n      /// Typedef for the template parameter char.\n      typedef char\t\tchar_type;\n\n    protected:\n      // Data Members:\n      __c_locale\t\t_M_c_locale_ctype;\n      bool\t\t\t_M_del;\n      __to_type\t\t\t_M_toupper;\n      __to_type\t\t\t_M_tolower;\n      const mask*\t\t_M_table;\n      mutable char\t\t_M_widen_ok;\n      mutable char\t\t_M_widen[1 + static_cast<unsigned char>(-1)];\n      mutable char\t\t_M_narrow[1 + static_cast<unsigned char>(-1)];\n      mutable char\t\t_M_narrow_ok;\t// 0 uninitialized, 1 init,\n\t\t\t\t\t\t// 2 memcpy can't be used\n\n    public:\n      /// The facet id for ctype<char>\n      static locale::id        id;\n      /// The size of the mask table.  It is SCHAR_MAX + 1.\n      static const size_t      table_size = 1 + static_cast<unsigned char>(-1);\n\n      /**\n       *  @brief  Constructor performs initialization.\n       *\n       *  This is the constructor provided by the standard.\n       *\n       *  @param __table If non-zero, table is used as the per-char mask.\n       *               Else classic_table() is used.\n       *  @param __del   If true, passes ownership of table to this facet.\n       *  @param __refs  Passed to the base facet class.\n      */\n      explicit\n      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);\n\n      /**\n       *  @brief  Constructor performs static initialization.\n       *\n       *  This constructor is used to construct the initial C locale facet.\n       *\n       *  @param __cloc  Handle to C locale data.\n       *  @param __table If non-zero, table is used as the per-char mask.\n       *  @param __del   If true, passes ownership of table to this facet.\n       *  @param __refs  Passed to the base facet class.\n      */\n      explicit\n      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,\n\t    size_t __refs = 0);\n\n      /**\n       *  @brief  Test char classification.\n       *\n       *  This function compares the mask table[c] to @a __m.\n       *\n       *  @param __c  The char to compare the mask of.\n       *  @param __m  The mask to compare against.\n       *  @return  True if __m & table[__c] is true, false otherwise.\n      */\n      inline bool\n      is(mask __m, char __c) const;\n\n      /**\n       *  @brief  Return a mask array.\n       *\n       *  This function finds the mask for each char in the range [lo, hi) and\n       *  successively writes it to vec.  vec must have as many elements as\n       *  the char array.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __vec  Pointer to an array of mask storage.\n       *  @return  @a __hi.\n      */\n      inline const char*\n      is(const char* __lo, const char* __hi, mask* __vec) const;\n\n      /**\n       *  @brief  Find char matching a mask\n       *\n       *  This function searches for and returns the first char in [lo,hi) for\n       *  which is(m,char) is true.\n       *\n       *  @param __m  The mask to compare against.\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  Pointer to a matching char if found, else @a __hi.\n      */\n      inline const char*\n      scan_is(mask __m, const char* __lo, const char* __hi) const;\n\n      /**\n       *  @brief  Find char not matching a mask\n       *\n       *  This function searches for and returns a pointer to the first char\n       *  in [__lo,__hi) for which is(m,char) is false.\n       *\n       *  @param __m  The mask to compare against.\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  Pointer to a non-matching char if found, else @a __hi.\n      */\n      inline const char*\n      scan_not(mask __m, const char* __lo, const char* __hi) const;\n\n      /**\n       *  @brief  Convert to uppercase.\n       *\n       *  This function converts the char argument to uppercase if possible.\n       *  If not possible (for example, '2'), returns the argument.\n       *\n       *  toupper() acts as if it returns ctype<char>::do_toupper(c).\n       *  do_toupper() must always return the same result for the same input.\n       *\n       *  @param __c  The char to convert.\n       *  @return  The uppercase char if convertible, else @a __c.\n      */\n      char_type\n      toupper(char_type __c) const\n      { return this->do_toupper(__c); }\n\n      /**\n       *  @brief  Convert array to uppercase.\n       *\n       *  This function converts each char in the range [__lo,__hi) to uppercase\n       *  if possible.  Other chars remain untouched.\n       *\n       *  toupper() acts as if it returns ctype<char>:: do_toupper(__lo, __hi).\n       *  do_toupper() must always return the same result for the same input.\n       *\n       *  @param __lo  Pointer to first char in range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      const char_type*\n      toupper(char_type *__lo, const char_type* __hi) const\n      { return this->do_toupper(__lo, __hi); }\n\n      /**\n       *  @brief  Convert to lowercase.\n       *\n       *  This function converts the char argument to lowercase if possible.\n       *  If not possible (for example, '2'), returns the argument.\n       *\n       *  tolower() acts as if it returns ctype<char>::do_tolower(__c).\n       *  do_tolower() must always return the same result for the same input.\n       *\n       *  @param __c  The char to convert.\n       *  @return  The lowercase char if convertible, else @a __c.\n      */\n      char_type\n      tolower(char_type __c) const\n      { return this->do_tolower(__c); }\n\n      /**\n       *  @brief  Convert array to lowercase.\n       *\n       *  This function converts each char in the range [lo,hi) to lowercase\n       *  if possible.  Other chars remain untouched.\n       *\n       *  tolower() acts as if it returns ctype<char>:: do_tolower(__lo, __hi).\n       *  do_tolower() must always return the same result for the same input.\n       *\n       *  @param __lo  Pointer to first char in range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      const char_type*\n      tolower(char_type* __lo, const char_type* __hi) const\n      { return this->do_tolower(__lo, __hi); }\n\n      /**\n       *  @brief  Widen char\n       *\n       *  This function converts the char to char_type using the simplest\n       *  reasonable transformation.  For an underived ctype<char> facet, the\n       *  argument will be returned unchanged.\n       *\n       *  This function works as if it returns ctype<char>::do_widen(c).\n       *  do_widen() must always return the same result for the same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The char to convert.\n       *  @return  The converted character.\n      */\n      char_type\n      widen(char __c) const\n      {\n\tif (_M_widen_ok)\n\t  return _M_widen[static_cast<unsigned char>(__c)];\n\tthis->_M_widen_init();\n\treturn this->do_widen(__c);\n      }\n\n      /**\n       *  @brief  Widen char array\n       *\n       *  This function converts each char in the input to char using the\n       *  simplest reasonable transformation.  For an underived ctype<char>\n       *  facet, the argument will be copied unchanged.\n       *\n       *  This function works as if it returns ctype<char>::do_widen(c).\n       *  do_widen() must always return the same result for the same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to first char in range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      const char*\n      widen(const char* __lo, const char* __hi, char_type* __to) const\n      {\n\tif (_M_widen_ok == 1)\n\t  {\n\t    if (__builtin_expect(__hi != __lo, true))\n\t      __builtin_memcpy(__to, __lo, __hi - __lo);\n\t    return __hi;\n\t  }\n\tif (!_M_widen_ok)\n\t  _M_widen_init();\n\treturn this->do_widen(__lo, __hi, __to);\n      }\n\n      /**\n       *  @brief  Narrow char\n       *\n       *  This function converts the char to char using the simplest\n       *  reasonable transformation.  If the conversion fails, dfault is\n       *  returned instead.  For an underived ctype<char> facet, @a c\n       *  will be returned unchanged.\n       *\n       *  This function works as if it returns ctype<char>::do_narrow(c).\n       *  do_narrow() must always return the same result for the same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The char to convert.\n       *  @param __dfault  Char to return if conversion fails.\n       *  @return  The converted character.\n      */\n      char\n      narrow(char_type __c, char __dfault) const\n      {\n\tif (_M_narrow[static_cast<unsigned char>(__c)])\n\t  return _M_narrow[static_cast<unsigned char>(__c)];\n\tconst char __t = do_narrow(__c, __dfault);\n\tif (__t != __dfault)\n\t  _M_narrow[static_cast<unsigned char>(__c)] = __t;\n\treturn __t;\n      }\n\n      /**\n       *  @brief  Narrow char array\n       *\n       *  This function converts each char in the input to char using the\n       *  simplest reasonable transformation and writes the results to the\n       *  destination array.  For any char in the input that cannot be\n       *  converted, @a dfault is used instead.  For an underived ctype<char>\n       *  facet, the argument will be copied unchanged.\n       *\n       *  This function works as if it returns ctype<char>::do_narrow(lo, hi,\n       *  dfault, to).  do_narrow() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __dfault  Char to use if conversion fails.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      const char_type*\n      narrow(const char_type* __lo, const char_type* __hi,\n\t     char __dfault, char* __to) const\n      {\n\tif (__builtin_expect(_M_narrow_ok == 1, true))\n\t  {\n\t    if (__builtin_expect(__hi != __lo, true))\n\t      __builtin_memcpy(__to, __lo, __hi - __lo);\n\t    return __hi;\n\t  }\n\tif (!_M_narrow_ok)\n\t  _M_narrow_init();\n\treturn this->do_narrow(__lo, __hi, __dfault, __to);\n      }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR 695. ctype<char>::classic_table() not accessible.\n      /// Returns a pointer to the mask table provided to the constructor, or\n      /// the default from classic_table() if none was provided.\n      const mask*\n      table() const throw()\n      { return _M_table; }\n\n      /// Returns a pointer to the C locale mask table.\n      static const mask*\n      classic_table() throw();\n    protected:\n\n      /**\n       *  @brief  Destructor.\n       *\n       *  This function deletes table() if @a del was true in the\n       *  constructor.\n      */\n      virtual\n      ~ctype();\n\n      /**\n       *  @brief  Convert to uppercase.\n       *\n       *  This virtual function converts the char argument to uppercase if\n       *  possible.  If not possible (for example, '2'), returns the argument.\n       *\n       *  do_toupper() is a hook for a derived facet to change the behavior of\n       *  uppercasing.  do_toupper() must always return the same result for\n       *  the same input.\n       *\n       *  @param __c  The char to convert.\n       *  @return  The uppercase char if convertible, else @a __c.\n      */\n      virtual char_type\n      do_toupper(char_type __c) const;\n\n      /**\n       *  @brief  Convert array to uppercase.\n       *\n       *  This virtual function converts each char in the range [lo,hi) to\n       *  uppercase if possible.  Other chars remain untouched.\n       *\n       *  do_toupper() is a hook for a derived facet to change the behavior of\n       *  uppercasing.  do_toupper() must always return the same result for\n       *  the same input.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const;\n\n      /**\n       *  @brief  Convert to lowercase.\n       *\n       *  This virtual function converts the char argument to lowercase if\n       *  possible.  If not possible (for example, '2'), returns the argument.\n       *\n       *  do_tolower() is a hook for a derived facet to change the behavior of\n       *  lowercasing.  do_tolower() must always return the same result for\n       *  the same input.\n       *\n       *  @param __c  The char to convert.\n       *  @return  The lowercase char if convertible, else @a __c.\n      */\n      virtual char_type\n      do_tolower(char_type __c) const;\n\n      /**\n       *  @brief  Convert array to lowercase.\n       *\n       *  This virtual function converts each char in the range [lo,hi) to\n       *  lowercase if possible.  Other chars remain untouched.\n       *\n       *  do_tolower() is a hook for a derived facet to change the behavior of\n       *  lowercasing.  do_tolower() must always return the same result for\n       *  the same input.\n       *\n       *  @param __lo  Pointer to first char in range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const;\n\n      /**\n       *  @brief  Widen char\n       *\n       *  This virtual function converts the char to char using the simplest\n       *  reasonable transformation.  For an underived ctype<char> facet, the\n       *  argument will be returned unchanged.\n       *\n       *  do_widen() is a hook for a derived facet to change the behavior of\n       *  widening.  do_widen() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The char to convert.\n       *  @return  The converted character.\n      */\n      virtual char_type\n      do_widen(char __c) const\n      { return __c; }\n\n      /**\n       *  @brief  Widen char array\n       *\n       *  This function converts each char in the range [lo,hi) to char using\n       *  the simplest reasonable transformation.  For an underived\n       *  ctype<char> facet, the argument will be copied unchanged.\n       *\n       *  do_widen() is a hook for a derived facet to change the behavior of\n       *  widening.  do_widen() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      virtual const char*\n      do_widen(const char* __lo, const char* __hi, char_type* __to) const\n      {\n\tif (__builtin_expect(__hi != __lo, true))\n\t  __builtin_memcpy(__to, __lo, __hi - __lo);\n\treturn __hi;\n      }\n\n      /**\n       *  @brief  Narrow char\n       *\n       *  This virtual function converts the char to char using the simplest\n       *  reasonable transformation.  If the conversion fails, dfault is\n       *  returned instead.  For an underived ctype<char> facet, @a c will be\n       *  returned unchanged.\n       *\n       *  do_narrow() is a hook for a derived facet to change the behavior of\n       *  narrowing.  do_narrow() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The char to convert.\n       *  @param __dfault  Char to return if conversion fails.\n       *  @return  The converted char.\n      */\n      virtual char\n      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const\n      { return __c; }\n\n      /**\n       *  @brief  Narrow char array to char array\n       *\n       *  This virtual function converts each char in the range [lo,hi) to\n       *  char using the simplest reasonable transformation and writes the\n       *  results to the destination array.  For any char in the input that\n       *  cannot be converted, @a dfault is used instead.  For an underived\n       *  ctype<char> facet, the argument will be copied unchanged.\n       *\n       *  do_narrow() is a hook for a derived facet to change the behavior of\n       *  narrowing.  do_narrow() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __dfault  Char to use if conversion fails.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi,\n\t\tchar __dfault __attribute__((__unused__)), char* __to) const\n      {\n\tif (__builtin_expect(__hi != __lo, true))\n\t  __builtin_memcpy(__to, __lo, __hi - __lo);\n\treturn __hi;\n      }\n\n    private:\n      void _M_narrow_init() const;\n      void _M_widen_init() const;\n    };\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  /**\n   *  @brief  The ctype<wchar_t> specialization.\n   *  @ingroup locales\n   *\n   *  This class defines classification and conversion functions for the\n   *  wchar_t type.  It gets used by wchar_t streams for many I/O operations.\n   *  The wchar_t specialization provides a number of optimizations as well.\n   *\n   *  ctype<wchar_t> inherits its public methods from\n   *  __ctype_abstract_base<wchar_t>.\n  */\n  template<>\n    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>\n    {\n    public:\n      // Types:\n      /// Typedef for the template parameter wchar_t.\n      typedef wchar_t\t\tchar_type;\n      typedef wctype_t\t\t__wmask_type;\n\n    protected:\n      __c_locale\t\t_M_c_locale_ctype;\n\n      // Pre-computed narrowed and widened chars.\n      bool                      _M_narrow_ok;\n      char                      _M_narrow[128];\n      wint_t                    _M_widen[1 + static_cast<unsigned char>(-1)];\n\n      // Pre-computed elements for do_is.\n      mask                      _M_bit[16];\n      __wmask_type              _M_wmask[16];\n\n    public:\n      // Data Members:\n      /// The facet id for ctype<wchar_t>\n      static locale::id\t\tid;\n\n      /**\n       *  @brief  Constructor performs initialization.\n       *\n       *  This is the constructor provided by the standard.\n       *\n       *  @param __refs  Passed to the base facet class.\n      */\n      explicit\n      ctype(size_t __refs = 0);\n\n      /**\n       *  @brief  Constructor performs static initialization.\n       *\n       *  This constructor is used to construct the initial C locale facet.\n       *\n       *  @param __cloc  Handle to C locale data.\n       *  @param __refs  Passed to the base facet class.\n      */\n      explicit\n      ctype(__c_locale __cloc, size_t __refs = 0);\n\n    protected:\n      __wmask_type\n      _M_convert_to_wmask(const mask __m) const throw();\n\n      /// Destructor\n      virtual\n      ~ctype();\n\n      /**\n       *  @brief  Test wchar_t classification.\n       *\n       *  This function finds a mask M for @a c and compares it to mask @a m.\n       *\n       *  do_is() is a hook for a derived facet to change the behavior of\n       *  classifying.  do_is() must always return the same result for the\n       *  same input.\n       *\n       *  @param __c  The wchar_t to find the mask of.\n       *  @param __m  The mask to compare against.\n       *  @return  (M & __m) != 0.\n      */\n      virtual bool\n      do_is(mask __m, char_type __c) const;\n\n      /**\n       *  @brief  Return a mask array.\n       *\n       *  This function finds the mask for each wchar_t in the range [lo,hi)\n       *  and successively writes it to vec.  vec must have as many elements\n       *  as the input.\n       *\n       *  do_is() is a hook for a derived facet to change the behavior of\n       *  classifying.  do_is() must always return the same result for the\n       *  same input.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __vec  Pointer to an array of mask storage.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;\n\n      /**\n       *  @brief  Find wchar_t matching mask\n       *\n       *  This function searches for and returns the first wchar_t c in\n       *  [__lo,__hi) for which is(__m,c) is true.\n       *\n       *  do_scan_is() is a hook for a derived facet to change the behavior of\n       *  match searching.  do_is() must always return the same result for the\n       *  same input.\n       *\n       *  @param __m  The mask to compare against.\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  Pointer to a matching wchar_t if found, else @a __hi.\n      */\n      virtual const char_type*\n      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;\n\n      /**\n       *  @brief  Find wchar_t not matching mask\n       *\n       *  This function searches for and returns a pointer to the first\n       *  wchar_t c of [__lo,__hi) for which is(__m,c) is false.\n       *\n       *  do_scan_is() is a hook for a derived facet to change the behavior of\n       *  match searching.  do_is() must always return the same result for the\n       *  same input.\n       *\n       *  @param __m  The mask to compare against.\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  Pointer to a non-matching wchar_t if found, else @a __hi.\n      */\n      virtual const char_type*\n      do_scan_not(mask __m, const char_type* __lo,\n\t\t  const char_type* __hi) const;\n\n      /**\n       *  @brief  Convert to uppercase.\n       *\n       *  This virtual function converts the wchar_t argument to uppercase if\n       *  possible.  If not possible (for example, '2'), returns the argument.\n       *\n       *  do_toupper() is a hook for a derived facet to change the behavior of\n       *  uppercasing.  do_toupper() must always return the same result for\n       *  the same input.\n       *\n       *  @param __c  The wchar_t to convert.\n       *  @return  The uppercase wchar_t if convertible, else @a __c.\n      */\n      virtual char_type\n      do_toupper(char_type __c) const;\n\n      /**\n       *  @brief  Convert array to uppercase.\n       *\n       *  This virtual function converts each wchar_t in the range [lo,hi) to\n       *  uppercase if possible.  Other elements remain untouched.\n       *\n       *  do_toupper() is a hook for a derived facet to change the behavior of\n       *  uppercasing.  do_toupper() must always return the same result for\n       *  the same input.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_toupper(char_type* __lo, const char_type* __hi) const;\n\n      /**\n       *  @brief  Convert to lowercase.\n       *\n       *  This virtual function converts the argument to lowercase if\n       *  possible.  If not possible (for example, '2'), returns the argument.\n       *\n       *  do_tolower() is a hook for a derived facet to change the behavior of\n       *  lowercasing.  do_tolower() must always return the same result for\n       *  the same input.\n       *\n       *  @param __c  The wchar_t to convert.\n       *  @return  The lowercase wchar_t if convertible, else @a __c.\n      */\n      virtual char_type\n      do_tolower(char_type __c) const;\n\n      /**\n       *  @brief  Convert array to lowercase.\n       *\n       *  This virtual function converts each wchar_t in the range [lo,hi) to\n       *  lowercase if possible.  Other elements remain untouched.\n       *\n       *  do_tolower() is a hook for a derived facet to change the behavior of\n       *  lowercasing.  do_tolower() must always return the same result for\n       *  the same input.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_tolower(char_type* __lo, const char_type* __hi) const;\n\n      /**\n       *  @brief  Widen char to wchar_t\n       *\n       *  This virtual function converts the char to wchar_t using the\n       *  simplest reasonable transformation.  For an underived ctype<wchar_t>\n       *  facet, the argument will be cast to wchar_t.\n       *\n       *  do_widen() is a hook for a derived facet to change the behavior of\n       *  widening.  do_widen() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The char to convert.\n       *  @return  The converted wchar_t.\n      */\n      virtual char_type\n      do_widen(char __c) const;\n\n      /**\n       *  @brief  Widen char array to wchar_t array\n       *\n       *  This function converts each char in the input to wchar_t using the\n       *  simplest reasonable transformation.  For an underived ctype<wchar_t>\n       *  facet, the argument will be copied, casting each element to wchar_t.\n       *\n       *  do_widen() is a hook for a derived facet to change the behavior of\n       *  widening.  do_widen() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to start range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      virtual const char*\n      do_widen(const char* __lo, const char* __hi, char_type* __to) const;\n\n      /**\n       *  @brief  Narrow wchar_t to char\n       *\n       *  This virtual function converts the argument to char using\n       *  the simplest reasonable transformation.  If the conversion\n       *  fails, dfault is returned instead.  For an underived\n       *  ctype<wchar_t> facet, @a c will be cast to char and\n       *  returned.\n       *\n       *  do_narrow() is a hook for a derived facet to change the\n       *  behavior of narrowing.  do_narrow() must always return the\n       *  same result for the same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __c  The wchar_t to convert.\n       *  @param __dfault  Char to return if conversion fails.\n       *  @return  The converted char.\n      */\n      virtual char\n      do_narrow(char_type __c, char __dfault) const;\n\n      /**\n       *  @brief  Narrow wchar_t array to char array\n       *\n       *  This virtual function converts each wchar_t in the range [lo,hi) to\n       *  char using the simplest reasonable transformation and writes the\n       *  results to the destination array.  For any wchar_t in the input that\n       *  cannot be converted, @a dfault is used instead.  For an underived\n       *  ctype<wchar_t> facet, the argument will be copied, casting each\n       *  element to char.\n       *\n       *  do_narrow() is a hook for a derived facet to change the behavior of\n       *  narrowing.  do_narrow() must always return the same result for the\n       *  same input.\n       *\n       *  Note: this is not what you want for codepage conversions.  See\n       *  codecvt for that.\n       *\n       *  @param __lo  Pointer to start of range.\n       *  @param __hi  Pointer to end of range.\n       *  @param __dfault  Char to use if conversion fails.\n       *  @param __to  Pointer to the destination array.\n       *  @return  @a __hi.\n      */\n      virtual const char_type*\n      do_narrow(const char_type* __lo, const char_type* __hi,\n\t\tchar __dfault, char* __to) const;\n\n      // For use at construction time only.\n      void\n      _M_initialize_ctype() throw();\n    };\n#endif //_GLIBCXX_USE_WCHAR_T\n\n  /// class ctype_byname [22.2.1.2].\n  template<typename _CharT>\n    class ctype_byname : public ctype<_CharT>\n    {\n    public:\n      typedef typename ctype<_CharT>::mask  mask;\n\n      explicit\n      ctype_byname(const char* __s, size_t __refs = 0);\n\n#if __cplusplus >= 201103L\n      explicit\n      ctype_byname(const string& __s, size_t __refs = 0)\n      : ctype_byname(__s.c_str(), __refs) { }\n#endif\n\n    protected:\n      virtual\n      ~ctype_byname() { }\n    };\n\n  /// 22.2.1.4  Class ctype_byname specializations.\n  template<>\n    class ctype_byname<char> : public ctype<char>\n    {\n    public:\n      explicit\n      ctype_byname(const char* __s, size_t __refs = 0);\n\n#if __cplusplus >= 201103L\n      explicit\n      ctype_byname(const string& __s, size_t __refs = 0);\n#endif\n\n    protected:\n      virtual\n      ~ctype_byname();\n    };\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  template<>\n    class ctype_byname<wchar_t> : public ctype<wchar_t>\n    {\n    public:\n      explicit\n      ctype_byname(const char* __s, size_t __refs = 0);\n\n#if __cplusplus >= 201103L\n      explicit\n      ctype_byname(const string& __s, size_t __refs = 0);\n#endif\n\n    protected:\n      virtual\n      ~ctype_byname();\n    };\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n// Include host and configuration specific ctype inlines.\n#include <bits/ctype_inline.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // 22.2.2  The numeric category.\n  class __num_base\n  {\n  public:\n    // NB: Code depends on the order of _S_atoms_out elements.\n    // Below are the indices into _S_atoms_out.\n    enum\n      {\n\t_S_ominus,\n\t_S_oplus,\n\t_S_ox,\n\t_S_oX,\n\t_S_odigits,\n\t_S_odigits_end = _S_odigits + 16,\n\t_S_oudigits = _S_odigits_end,\n\t_S_oudigits_end = _S_oudigits + 16,\n\t_S_oe = _S_odigits + 14,  // For scientific notation, 'e'\n\t_S_oE = _S_oudigits + 14, // For scientific notation, 'E'\n\t_S_oend = _S_oudigits_end\n      };\n\n    // A list of valid numeric literals for output.  This array\n    // contains chars that will be passed through the current locale's\n    // ctype<_CharT>.widen() and then used to render numbers.\n    // For the standard \"C\" locale, this is\n    // \"-+xX0123456789abcdef0123456789ABCDEF\".\n    static const char* _S_atoms_out;\n\n    // String literal of acceptable (narrow) input, for num_get.\n    // \"-+xX0123456789abcdefABCDEF\"\n    static const char* _S_atoms_in;\n\n    enum\n    {\n      _S_iminus,\n      _S_iplus,\n      _S_ix,\n      _S_iX,\n      _S_izero,\n      _S_ie = _S_izero + 14,\n      _S_iE = _S_izero + 20,\n      _S_iend = 26\n    };\n\n    // num_put\n    // Construct and return valid scanf format for floating point types.\n    static void\n    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();\n  };\n\n  template<typename _CharT>\n    struct __numpunct_cache : public locale::facet\n    {\n      const char*\t\t\t_M_grouping;\n      size_t                            _M_grouping_size;\n      bool\t\t\t\t_M_use_grouping;\n      const _CharT*\t\t\t_M_truename;\n      size_t                            _M_truename_size;\n      const _CharT*\t\t\t_M_falsename;\n      size_t                            _M_falsename_size;\n      _CharT\t\t\t\t_M_decimal_point;\n      _CharT\t\t\t\t_M_thousands_sep;\n\n      // A list of valid numeric literals for output: in the standard\n      // \"C\" locale, this is \"-+xX0123456789abcdef0123456789ABCDEF\".\n      // This array contains the chars after having been passed\n      // through the current locale's ctype<_CharT>.widen().\n      _CharT\t\t\t\t_M_atoms_out[__num_base::_S_oend];\n\n      // A list of valid numeric literals for input: in the standard\n      // \"C\" locale, this is \"-+xX0123456789abcdefABCDEF\"\n      // This array contains the chars after having been passed\n      // through the current locale's ctype<_CharT>.widen().\n      _CharT\t\t\t\t_M_atoms_in[__num_base::_S_iend];\n\n      bool\t\t\t\t_M_allocated;\n\n      __numpunct_cache(size_t __refs = 0)\n      : facet(__refs), _M_grouping(0), _M_grouping_size(0),\n\t_M_use_grouping(false),\n\t_M_truename(0), _M_truename_size(0), _M_falsename(0),\n\t_M_falsename_size(0), _M_decimal_point(_CharT()),\n\t_M_thousands_sep(_CharT()), _M_allocated(false)\n\t{ }\n\n      ~__numpunct_cache();\n\n      void\n      _M_cache(const locale& __loc);\n\n    private:\n      __numpunct_cache&\n      operator=(const __numpunct_cache&);\n\n      explicit\n      __numpunct_cache(const __numpunct_cache&);\n    };\n\n  template<typename _CharT>\n    __numpunct_cache<_CharT>::~__numpunct_cache()\n    {\n      if (_M_allocated)\n\t{\n\t  delete [] _M_grouping;\n\t  delete [] _M_truename;\n\t  delete [] _M_falsename;\n\t}\n    }\n\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n\n  /**\n   *  @brief  Primary class template numpunct.\n   *  @ingroup locales\n   *\n   *  This facet stores several pieces of information related to printing and\n   *  scanning numbers, such as the decimal point character.  It takes a\n   *  template parameter specifying the char type.  The numpunct facet is\n   *  used by streams for many I/O operations involving numbers.\n   *\n   *  The numpunct template uses protected virtual functions to provide the\n   *  actual results.  The public accessors forward the call to the virtual\n   *  functions.  These virtual functions are hooks for developers to\n   *  implement the behavior they require from a numpunct facet.\n  */\n  template<typename _CharT>\n    class numpunct : public locale::facet\n    {\n    public:\n      // Types:\n      ///@{\n      /// Public typedefs\n      typedef _CharT\t\t\tchar_type;\n      typedef basic_string<_CharT>\tstring_type;\n      ///@}\n      typedef __numpunct_cache<_CharT>  __cache_type;\n\n    protected:\n      __cache_type*\t\t\t_M_data;\n\n    public:\n      /// Numpunct facet id.\n      static locale::id\t\t\tid;\n\n      /**\n       *  @brief  Numpunct constructor.\n       *\n       *  @param  __refs  Refcount to pass to the base class.\n       */\n      explicit\n      numpunct(size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M_initialize_numpunct(); }\n\n      /**\n       *  @brief  Internal constructor.  Not for general use.\n       *\n       *  This is a constructor for use by the library itself to set up the\n       *  predefined locale facets.\n       *\n       *  @param  __cache  __numpunct_cache object.\n       *  @param  __refs  Refcount to pass to the base class.\n       */\n      explicit\n      numpunct(__cache_type* __cache, size_t __refs = 0)\n      : facet(__refs), _M_data(__cache)\n      { _M_initialize_numpunct(); }\n\n      /**\n       *  @brief  Internal constructor.  Not for general use.\n       *\n       *  This is a constructor for use by the library itself to set up new\n       *  locales.\n       *\n       *  @param  __cloc  The C locale.\n       *  @param  __refs  Refcount to pass to the base class.\n       */\n      explicit\n      numpunct(__c_locale __cloc, size_t __refs = 0)\n      : facet(__refs), _M_data(0)\n      { _M_initialize_numpunct(__cloc); }\n\n      /**\n       *  @brief  Return decimal point character.\n       *\n       *  This function returns a char_type to use as a decimal point.  It\n       *  does so by returning returning\n       *  numpunct<char_type>::do_decimal_point().\n       *\n       *  @return  @a char_type representing a decimal point.\n      */\n      char_type\n      decimal_point() const\n      { return this->do_decimal_point(); }\n\n      /**\n       *  @brief  Return thousands separator character.\n       *\n       *  This function returns a char_type to use as a thousands\n       *  separator.  It does so by returning returning\n       *  numpunct<char_type>::do_thousands_sep().\n       *\n       *  @return  char_type representing a thousands separator.\n      */\n      char_type\n      thousands_sep() const\n      { return this->do_thousands_sep(); }\n\n      /**\n       *  @brief  Return grouping specification.\n       *\n       *  This function returns a string representing groupings for the\n       *  integer part of a number.  Groupings indicate where thousands\n       *  separators should be inserted in the integer part of a number.\n       *\n       *  Each char in the return string is interpret as an integer\n       *  rather than a character.  These numbers represent the number\n       *  of digits in a group.  The first char in the string\n       *  represents the number of digits in the least significant\n       *  group.  If a char is negative, it indicates an unlimited\n       *  number of digits for the group.  If more chars from the\n       *  string are required to group a number, the last char is used\n       *  repeatedly.\n       *\n       *  For example, if the grouping() returns \"\\003\\002\" and is\n       *  applied to the number 123456789, this corresponds to\n       *  12,34,56,789.  Note that if the string was \"32\", this would\n       *  put more than 50 digits into the least significant group if\n       *  the character set is ASCII.\n       *\n       *  The string is returned by calling\n       *  numpunct<char_type>::do_grouping().\n       *\n       *  @return  string representing grouping specification.\n      */\n      string\n      grouping() const\n      { return this->do_grouping(); }\n\n      /**\n       *  @brief  Return string representation of bool true.\n       *\n       *  This function returns a string_type containing the text\n       *  representation for true bool variables.  It does so by calling\n       *  numpunct<char_type>::do_truename().\n       *\n       *  @return  string_type representing printed form of true.\n      */\n      string_type\n      truename() const\n      { return this->do_truename(); }\n\n      /**\n       *  @brief  Return string representation of bool false.\n       *\n       *  This function returns a string_type containing the text\n       *  representation for false bool variables.  It does so by calling\n       *  numpunct<char_type>::do_falsename().\n       *\n       *  @return  string_type representing printed form of false.\n      */\n      string_type\n      falsename() const\n      { return this->do_falsename(); }\n\n    protected:\n      /// Destructor.\n      virtual\n      ~numpunct();\n\n      /**\n       *  @brief  Return decimal point character.\n       *\n       *  Returns a char_type to use as a decimal point.  This function is a\n       *  hook for derived classes to change the value returned.\n       *\n       *  @return  @a char_type representing a decimal point.\n      */\n      virtual char_type\n      do_decimal_point() const\n      { return _M_data->_M_decimal_point; }\n\n      /**\n       *  @brief  Return thousands separator character.\n       *\n       *  Returns a char_type to use as a thousands separator.  This function\n       *  is a hook for derived classes to change the value returned.\n       *\n       *  @return  @a char_type representing a thousands separator.\n      */\n      virtual char_type\n      do_thousands_sep() const\n      { return _M_data->_M_thousands_sep; }\n\n      /**\n       *  @brief  Return grouping specification.\n       *\n       *  Returns a string representing groupings for the integer part of a\n       *  number.  This function is a hook for derived classes to change the\n       *  value returned.  @see grouping() for details.\n       *\n       *  @return  String representing grouping specification.\n      */\n      virtual string\n      do_grouping() const\n      { return _M_data->_M_grouping; }\n\n      /**\n       *  @brief  Return string representation of bool true.\n       *\n       *  Returns a string_type containing the text representation for true\n       *  bool variables.  This function is a hook for derived classes to\n       *  change the value returned.\n       *\n       *  @return  string_type representing printed form of true.\n      */\n      virtual string_type\n      do_truename() const\n      { return _M_data->_M_truename; }\n\n      /**\n       *  @brief  Return string representation of bool false.\n       *\n       *  Returns a string_type containing the text representation for false\n       *  bool variables.  This function is a hook for derived classes to\n       *  change the value returned.\n       *\n       *  @return  string_type representing printed form of false.\n      */\n      virtual string_type\n      do_falsename() const\n      { return _M_data->_M_falsename; }\n\n      // For use at construction time only.\n      void\n      _M_initialize_numpunct(__c_locale __cloc = 0);\n    };\n\n  template<typename _CharT>\n    locale::id numpunct<_CharT>::id;\n\n  template<>\n    numpunct<char>::~numpunct();\n\n  template<>\n    void\n    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  template<>\n    numpunct<wchar_t>::~numpunct();\n\n  template<>\n    void\n    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);\n#endif\n\n  /// class numpunct_byname [22.2.3.2].\n  template<typename _CharT>\n    class numpunct_byname : public numpunct<_CharT>\n    {\n    public:\n      typedef _CharT\t\t\tchar_type;\n      typedef basic_string<_CharT>\tstring_type;\n\n      explicit\n      numpunct_byname(const char* __s, size_t __refs = 0)\n      : numpunct<_CharT>(__refs)\n      {\n\tif (__builtin_strcmp(__s, \"C\") != 0\n\t    && __builtin_strcmp(__s, \"POSIX\") != 0)\n\t  {\n\t    __c_locale __tmp;\n\t    this->_S_create_c_locale(__tmp, __s);\n\t    this->_M_initialize_numpunct(__tmp);\n\t    this->_S_destroy_c_locale(__tmp);\n\t  }\n      }\n\n#if __cplusplus >= 201103L\n      explicit\n      numpunct_byname(const string& __s, size_t __refs = 0)\n      : numpunct_byname(__s.c_str(), __refs) { }\n#endif\n\n    protected:\n      virtual\n      ~numpunct_byname() { }\n    };\n\n_GLIBCXX_END_NAMESPACE_CXX11\n\n_GLIBCXX_BEGIN_NAMESPACE_LDBL\n\n  /**\n   *  @brief  Primary class template num_get.\n   *  @ingroup locales\n   *\n   *  This facet encapsulates the code to parse and return a number\n   *  from a string.  It is used by the istream numeric extraction\n   *  operators.\n   *\n   *  The num_get template uses protected virtual functions to provide the\n   *  actual results.  The public accessors forward the call to the virtual\n   *  functions.  These virtual functions are hooks for developers to\n   *  implement the behavior they require from the num_get facet.\n  */\n  template<typename _CharT, typename _InIter>\n    class num_get : public locale::facet\n    {\n    public:\n      // Types:\n      ///@{\n      /// Public typedefs\n      typedef _CharT\t\t\tchar_type;\n      typedef _InIter\t\t\titer_type;\n      ///@}\n\n      /// Numpunct facet id.\n      static locale::id\t\t\tid;\n\n      /**\n       *  @brief  Constructor performs initialization.\n       *\n       *  This is the constructor provided by the standard.\n       *\n       *  @param __refs  Passed to the base facet class.\n      */\n      explicit\n      num_get(size_t __refs = 0) : facet(__refs) { }\n\n      /**\n       *  @brief  Numeric parsing.\n       *\n       *  Parses the input stream into the bool @a v.  It does so by calling\n       *  num_get::do_get().\n       *\n       *  If ios_base::boolalpha is set, attempts to read\n       *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets\n       *  @a v to true or false if successful.  Sets err to\n       *  ios_base::failbit if reading the string fails.  Sets err to\n       *  ios_base::eofbit if the stream is emptied.\n       *\n       *  If ios_base::boolalpha is not set, proceeds as with reading a long,\n       *  except if the value is 1, sets @a v to true, if the value is 0, sets\n       *  @a v to false, and otherwise set err to ios_base::failbit.\n       *\n       *  @param  __in  Start of input stream.\n       *  @param  __end  End of input stream.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __err  Error flags to set.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after reading.\n      */\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, bool& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      ///@{\n      /**\n       *  @brief  Numeric parsing.\n       *\n       *  Parses the input stream into the integral variable @a v.  It does so\n       *  by calling num_get::do_get().\n       *\n       *  Parsing is affected by the flag settings in @a io.\n       *\n       *  The basic parse is affected by the value of io.flags() &\n       *  ios_base::basefield.  If equal to ios_base::oct, parses like the\n       *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X\n       *  specifier.  Else if basefield equal to 0, parses like the %i\n       *  specifier.  Otherwise, parses like %d for signed and %u for unsigned\n       *  types.  The matching type length modifier is also used.\n       *\n       *  Digit grouping is interpreted according to\n       *  numpunct::grouping() and numpunct::thousands_sep().  If the\n       *  pattern of digit groups isn't consistent, sets err to\n       *  ios_base::failbit.\n       *\n       *  If parsing the string yields a valid value for @a v, @a v is set.\n       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.\n       *  Sets err to ios_base::eofbit if the stream is emptied.\n       *\n       *  @param  __in  Start of input stream.\n       *  @param  __end  End of input stream.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __err  Error flags to set.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after reading.\n      */\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, long& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, unsigned short& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, unsigned int& __v)   const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, unsigned long& __v)  const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n#ifdef _GLIBCXX_USE_LONG_LONG\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, long long& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, unsigned long long& __v)  const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n#endif\n      ///@}\n\n      ///@{\n      /**\n       *  @brief  Numeric parsing.\n       *\n       *  Parses the input stream into the integral variable @a v.  It does so\n       *  by calling num_get::do_get().\n       *\n       *  The input characters are parsed like the scanf %g specifier.  The\n       *  matching type length modifier is also used.\n       *\n       *  The decimal point character used is numpunct::decimal_point().\n       *  Digit grouping is interpreted according to\n       *  numpunct::grouping() and numpunct::thousands_sep().  If the\n       *  pattern of digit groups isn't consistent, sets err to\n       *  ios_base::failbit.\n       *\n       *  If parsing the string yields a valid value for @a v, @a v is set.\n       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.\n       *  Sets err to ios_base::eofbit if the stream is emptied.\n       *\n       *  @param  __in  Start of input stream.\n       *  @param  __end  End of input stream.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __err  Error flags to set.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after reading.\n      */\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, float& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, double& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, long double& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n      ///@}\n\n      /**\n       *  @brief  Numeric parsing.\n       *\n       *  Parses the input stream into the pointer variable @a v.  It does so\n       *  by calling num_get::do_get().\n       *\n       *  The input characters are parsed like the scanf %p specifier.\n       *\n       *  Digit grouping is interpreted according to\n       *  numpunct::grouping() and numpunct::thousands_sep().  If the\n       *  pattern of digit groups isn't consistent, sets err to\n       *  ios_base::failbit.\n       *\n       *  Note that the digit grouping effect for pointers is a bit ambiguous\n       *  in the standard and shouldn't be relied on.  See DR 344.\n       *\n       *  If parsing the string yields a valid value for @a v, @a v is set.\n       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.\n       *  Sets err to ios_base::eofbit if the stream is emptied.\n       *\n       *  @param  __in  Start of input stream.\n       *  @param  __end  End of input stream.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __err  Error flags to set.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after reading.\n      */\n      iter_type\n      get(iter_type __in, iter_type __end, ios_base& __io,\n\t  ios_base::iostate& __err, void*& __v) const\n      { return this->do_get(__in, __end, __io, __err, __v); }\n\n    protected:\n      /// Destructor.\n      virtual ~num_get() { }\n\n      _GLIBCXX_DEFAULT_ABI_TAG\n      iter_type\n      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,\n\t\t       string&) const;\n\n      template<typename _ValueT>\n\t_GLIBCXX_DEFAULT_ABI_TAG\n\titer_type\n\t_M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,\n\t\t       _ValueT&) const;\n\n      template<typename _CharT2>\n      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type\n\t_M_find(const _CharT2*, size_t __len, _CharT2 __c) const\n\t{\n\t  int __ret = -1;\n\t  if (__len <= 10)\n\t    {\n\t      if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))\n\t\t__ret = __c - _CharT2('0');\n\t    }\n\t  else\n\t    {\n\t      if (__c >= _CharT2('0') && __c <= _CharT2('9'))\n\t\t__ret = __c - _CharT2('0');\n\t      else if (__c >= _CharT2('a') && __c <= _CharT2('f'))\n\t\t__ret = 10 + (__c - _CharT2('a'));\n\t      else if (__c >= _CharT2('A') && __c <= _CharT2('F'))\n\t\t__ret = 10 + (__c - _CharT2('A'));\n\t    }\n\t  return __ret;\n\t}\n\n      template<typename _CharT2>\n      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,\n\t\t\t\t      int>::__type\n\t_M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const\n\t{\n\t  int __ret = -1;\n\t  const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);\n\t  if (__q)\n\t    {\n\t      __ret = __q - __zero;\n\t      if (__ret > 15)\n\t\t__ret -= 6;\n\t    }\n\t  return __ret;\n\t}\n\n      ///@{\n      /**\n       *  @brief  Numeric parsing.\n       *\n       *  Parses the input stream into the variable @a v.  This function is a\n       *  hook for derived classes to change the value returned.  @see get()\n       *  for more details.\n       *\n       *  @param  __beg  Start of input stream.\n       *  @param  __end  End of input stream.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __err  Error flags to set.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after reading.\n      */\n      virtual iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;\n\n      virtual iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n\t     ios_base::iostate& __err, long& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n      virtual iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n\t     ios_base::iostate& __err, unsigned short& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n      virtual iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n\t     ios_base::iostate& __err, unsigned int& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n      virtual iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n\t     ios_base::iostate& __err, unsigned long& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n#ifdef _GLIBCXX_USE_LONG_LONG\n      virtual iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n\t     ios_base::iostate& __err, long long& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n\n      virtual iter_type\n      do_get(iter_type __beg, iter_type __end, ios_base& __io,\n\t     ios_base::iostate& __err, unsigned long long& __v) const\n      { return _M_extract_int(__beg, __end, __io, __err, __v); }\n#endif\n\n      virtual iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;\n\n      virtual iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,\n\t     double&) const;\n\n      // XXX GLIBCXX_ABI Deprecated\n#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n      // For __gnu_cxx_ldbl128::num_get and __gnu_cxx_ieee128::num_get\n      // this entry in the vtable is for a 64-bit \"long double\" with the\n      // same format as double. This keeps the vtable layout consistent\n      // with std::num_get (visible when -mlong-double-64 is used).\n      virtual iter_type\n      __do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,\n\t       double&) const;\n#else\n      virtual iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,\n\t     long double&) const;\n#endif\n\n      virtual iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;\n\n      // XXX GLIBCXX_ABI Deprecated\n#if defined _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT \\\n      && defined __LONG_DOUBLE_IEEE128__\n      // For __gnu_cxx_ieee128::num_get this entry in the vtable is for\n      // the non-IEEE 128-bit \"long double\" (aka \"double double\"). This\n      // is consistent with __gnu_cxx_ldbl128::num_get (-mabi=ibmlongdouble)\n      virtual iter_type\n      __do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,\n\t       __ibm128&) const;\n#endif\n\n      // XXX GLIBCXX_ABI Deprecated\n#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n      // For __gnu_cxx_ldbl128::num_get and __gnu_cxx_ieee128::num_get\n      // this entry in the vtable is for the 128-bit \"long double\" type.\n      virtual iter_type\n      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,\n\t     long double&) const;\n#endif\n      ///@}\n    };\n\n  template<typename _CharT, typename _InIter>\n    locale::id num_get<_CharT, _InIter>::id;\n\n\n  /**\n   *  @brief  Primary class template num_put.\n   *  @ingroup locales\n   *\n   *  This facet encapsulates the code to convert a number to a string.  It is\n   *  used by the ostream numeric insertion operators.\n   *\n   *  The num_put template uses protected virtual functions to provide the\n   *  actual results.  The public accessors forward the call to the virtual\n   *  functions.  These virtual functions are hooks for developers to\n   *  implement the behavior they require from the num_put facet.\n  */\n  template<typename _CharT, typename _OutIter>\n    class num_put : public locale::facet\n    {\n    public:\n      // Types:\n      ///@{\n      /// Public typedefs\n      typedef _CharT\t\tchar_type;\n      typedef _OutIter\t\titer_type;\n      ///@}\n\n      /// Numpunct facet id.\n      static locale::id\t\tid;\n\n      /**\n       *  @brief  Constructor performs initialization.\n       *\n       *  This is the constructor provided by the standard.\n       *\n       *  @param __refs  Passed to the base facet class.\n      */\n      explicit\n      num_put(size_t __refs = 0) : facet(__refs) { }\n\n      /**\n       *  @brief  Numeric formatting.\n       *\n       *  Formats the boolean @a v and inserts it into a stream.  It does so\n       *  by calling num_put::do_put().\n       *\n       *  If ios_base::boolalpha is set, writes ctype<CharT>::truename() or\n       *  ctype<CharT>::falsename().  Otherwise formats @a v as an int.\n       *\n       *  @param  __s  Stream to write to.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __fill  Char_type to use for filling.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after writing.\n      */\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n      ///@{\n      /**\n       *  @brief  Numeric formatting.\n       *\n       *  Formats the integral value @a v and inserts it into a\n       *  stream.  It does so by calling num_put::do_put().\n       *\n       *  Formatting is affected by the flag settings in @a io.\n       *\n       *  The basic format is affected by the value of io.flags() &\n       *  ios_base::basefield.  If equal to ios_base::oct, formats like the\n       *  printf %o specifier.  Else if equal to ios_base::hex, formats like\n       *  %x or %X with ios_base::uppercase unset or set respectively.\n       *  Otherwise, formats like %d, %ld, %lld for signed and %u, %lu, %llu\n       *  for unsigned values.  Note that if both oct and hex are set, neither\n       *  will take effect.\n       *\n       *  If ios_base::showpos is set, '+' is output before positive values.\n       *  If ios_base::showbase is set, '0' precedes octal values (except 0)\n       *  and '0[xX]' precedes hex values.\n       *\n       *  The decimal point character used is numpunct::decimal_point().\n       *  Thousands separators are inserted according to\n       *  numpunct::grouping() and numpunct::thousands_sep().\n       *\n       *  If io.width() is non-zero, enough @a fill characters are inserted to\n       *  make the result at least that wide.  If\n       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is\n       *  padded at the end.  If ios_base::internal, then padding occurs\n       *  immediately after either a '+' or '-' or after '0x' or '0X'.\n       *  Otherwise, padding occurs at the beginning.\n       *\n       *  @param  __s  Stream to write to.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __fill  Char_type to use for filling.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after writing.\n      */\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill,\n\t  unsigned long __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n#ifdef _GLIBCXX_USE_LONG_LONG\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill,\n\t  unsigned long long __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n#endif\n      ///@}\n\n      ///@{\n      /**\n       *  @brief  Numeric formatting.\n       *\n       *  Formats the floating point value @a v and inserts it into a stream.\n       *  It does so by calling num_put::do_put().\n       *\n       *  Formatting is affected by the flag settings in @a io.\n       *\n       *  The basic format is affected by the value of io.flags() &\n       *  ios_base::floatfield.  If equal to ios_base::fixed, formats like the\n       *  printf %f specifier.  Else if equal to ios_base::scientific, formats\n       *  like %e or %E with ios_base::uppercase unset or set respectively.\n       *  Otherwise, formats like %g or %G depending on uppercase.  Note that\n       *  if both fixed and scientific are set, the effect will also be like\n       *  %g or %G.\n       *\n       *  The output precision is given by io.precision().  This precision is\n       *  capped at numeric_limits::digits10 + 2 (different for double and\n       *  long double).  The default precision is 6.\n       *\n       *  If ios_base::showpos is set, '+' is output before positive values.\n       *  If ios_base::showpoint is set, a decimal point will always be\n       *  output.\n       *\n       *  The decimal point character used is numpunct::decimal_point().\n       *  Thousands separators are inserted according to\n       *  numpunct::grouping() and numpunct::thousands_sep().\n       *\n       *  If io.width() is non-zero, enough @a fill characters are inserted to\n       *  make the result at least that wide.  If\n       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is\n       *  padded at the end.  If ios_base::internal, then padding occurs\n       *  immediately after either a '+' or '-' or after '0x' or '0X'.\n       *  Otherwise, padding occurs at the beginning.\n       *\n       *  @param  __s  Stream to write to.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __fill  Char_type to use for filling.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after writing.\n      */\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill,\n\t  long double __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n      ///@}\n\n      /**\n       *  @brief  Numeric formatting.\n       *\n       *  Formats the pointer value @a v and inserts it into a stream.  It\n       *  does so by calling num_put::do_put().\n       *\n       *  This function formats @a v as an unsigned long with ios_base::hex\n       *  and ios_base::showbase set.\n       *\n       *  @param  __s  Stream to write to.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __fill  Char_type to use for filling.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after writing.\n      */\n      iter_type\n      put(iter_type __s, ios_base& __io, char_type __fill,\n\t  const void* __v) const\n      { return this->do_put(__s, __io, __fill, __v); }\n\n    protected:\n      template<typename _ValueT>\n\titer_type\n\t_M_insert_float(iter_type, ios_base& __io, char_type __fill,\n\t\t\tchar __mod, _ValueT __v) const;\n\n      void\n      _M_group_float(const char* __grouping, size_t __grouping_size,\n\t\t     char_type __sep, const char_type* __p, char_type* __new,\n\t\t     char_type* __cs, int& __len) const;\n\n      template<typename _ValueT>\n\titer_type\n\t_M_insert_int(iter_type, ios_base& __io, char_type __fill,\n\t\t      _ValueT __v) const;\n\n      void\n      _M_group_int(const char* __grouping, size_t __grouping_size,\n\t\t   char_type __sep, ios_base& __io, char_type* __new,\n\t\t   char_type* __cs, int& __len) const;\n\n      void\n      _M_pad(char_type __fill, streamsize __w, ios_base& __io,\n\t     char_type* __new, const char_type* __cs, int& __len) const;\n\n      /// Destructor.\n      virtual\n      ~num_put() { }\n\n      ///@{\n      /**\n       *  @brief  Numeric formatting.\n       *\n       *  These functions do the work of formatting numeric values and\n       *  inserting them into a stream. This function is a hook for derived\n       *  classes to change the value returned.\n       *\n       *  @param  __s  Stream to write to.\n       *  @param  __io  Source of locale and flags.\n       *  @param  __fill  Char_type to use for filling.\n       *  @param  __v  Value to format and insert.\n       *  @return  Iterator after writing.\n      */\n      virtual iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;\n\n      virtual iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n      { return _M_insert_int(__s, __io, __fill, __v); }\n\n      virtual iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill,\n\t     unsigned long __v) const\n      { return _M_insert_int(__s, __io, __fill, __v); }\n\n#ifdef _GLIBCXX_USE_LONG_LONG\n      virtual iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill,\n\t     long long __v) const\n      { return _M_insert_int(__s, __io, __fill, __v); }\n\n      virtual iter_type\n      do_put(iter_type __s, ios_base& __io, char_type __fill,\n\t     unsigned long long __v) const\n      { return _M_insert_int(__s, __io, __fill, __v); }\n#endif\n\n      virtual iter_type\n      do_put(iter_type, ios_base&, char_type, double) const;\n\n      // XXX GLIBCXX_ABI Deprecated\n#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n      virtual iter_type\n      __do_put(iter_type, ios_base&, char_type, double) const;\n#else\n      virtual iter_type\n      do_put(iter_type, ios_base&, char_type, long double) const;\n#endif\n\n      virtual iter_type\n      do_put(iter_type, ios_base&, char_type, const void*) const;\n\n      // XXX GLIBCXX_ABI Deprecated\n#if defined _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT \\\n      && defined __LONG_DOUBLE_IEEE128__\n      virtual iter_type\n      __do_put(iter_type, ios_base&, char_type, __ibm128) const;\n#endif\n\n      // XXX GLIBCXX_ABI Deprecated\n#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n      virtual iter_type\n      do_put(iter_type, ios_base&, char_type, long double) const;\n#endif\n      ///@}\n    };\n\n  template <typename _CharT, typename _OutIter>\n    locale::id num_put<_CharT, _OutIter>::id;\n\n_GLIBCXX_END_NAMESPACE_LDBL\n\n  // Subclause convenience interfaces, inlines.\n  // NB: These are inline because, when used in a loop, some compilers\n  // can hoist the body out of the loop; then it's just as fast as the\n  // C is*() function.\n\n  /// Convenience interface to ctype.is(ctype_base::space, __c).\n  template<typename _CharT>\n    inline bool\n    isspace(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::print, __c).\n  template<typename _CharT>\n    inline bool\n    isprint(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::cntrl, __c).\n  template<typename _CharT>\n    inline bool\n    iscntrl(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::upper, __c).\n  template<typename _CharT>\n    inline bool\n    isupper(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::lower, __c).\n  template<typename _CharT>\n    inline bool\n    islower(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::alpha, __c).\n  template<typename _CharT>\n    inline bool\n    isalpha(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::digit, __c).\n  template<typename _CharT>\n    inline bool\n    isdigit(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::punct, __c).\n  template<typename _CharT>\n    inline bool\n    ispunct(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::xdigit, __c).\n  template<typename _CharT>\n    inline bool\n    isxdigit(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::alnum, __c).\n  template<typename _CharT>\n    inline bool\n    isalnum(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }\n\n  /// Convenience interface to ctype.is(ctype_base::graph, __c).\n  template<typename _CharT>\n    inline bool\n    isgraph(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }\n\n#if __cplusplus >= 201103L\n  /// Convenience interface to ctype.is(ctype_base::blank, __c).\n  template<typename _CharT>\n    inline bool\n    isblank(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }\n#endif\n\n  /// Convenience interface to ctype.toupper(__c).\n  template<typename _CharT>\n    inline _CharT\n    toupper(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }\n\n  /// Convenience interface to ctype.tolower(__c).\n  template<typename _CharT>\n    inline _CharT\n    tolower(_CharT __c, const locale& __loc)\n    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n# include <bits/locale_facets.tcc>\n\n#endif\n"}],"crc32":819778555,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]