[{"ops":[{"insert":"/* Macros to control TS 18661-3 glibc features where the same\n   definitions are appropriate for all platforms.\n   Copyright (C) 2017-2022 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n#ifndef _BITS_FLOATN_COMMON_H\n#define _BITS_FLOATN_COMMON_H\n\n#include <features.h>\n#include <bits/long-double.h>\n\n/* This header should be included at the bottom of each bits/floatn.h.\n   It defines the following macros for each _FloatN and _FloatNx type,\n   where the same definitions, or definitions based only on the macros\n   in bits/floatn.h, are appropriate for all glibc configurations.  */\n\n/* Defined to 1 if the current compiler invocation provides a\n   floating-point type with the right format for this type, and this\n   glibc includes corresponding *fN or *fNx interfaces for it.  */\n#define __HAVE_FLOAT16 0\n#define __HAVE_FLOAT32 1\n#define __HAVE_FLOAT64 1\n#define __HAVE_FLOAT32X 1\n#define __HAVE_FLOAT128X 0\n\n/* Defined to 1 if the corresponding __HAVE_<type> macro is 1 and the\n   type is the first with its format in the sequence of (the default\n   choices for) float, double, long double, _Float16, _Float32,\n   _Float64, _Float128, _Float32x, _Float64x, _Float128x for this\n   glibc; that is, if functions present once per floating-point format\n   rather than once per type are present for this type.\n\n   All configurations supported by glibc have _Float32 the same format\n   as float, _Float64 and _Float32x the same format as double, the\n   _Float64x the same format as either long double or _Float128.  No\n   configurations support _Float128x or, as of GCC 7, have compiler\n   support for a type meeting the requirements for _Float128x.  */\n#define __HAVE_DISTINCT_FLOAT16 __HAVE_FLOAT16\n#define __HAVE_DISTINCT_FLOAT32 0\n#define __HAVE_DISTINCT_FLOAT64 0\n#define __HAVE_DISTINCT_FLOAT32X 0\n#define __HAVE_DISTINCT_FLOAT64X 0\n#define __HAVE_DISTINCT_FLOAT128X __HAVE_FLOAT128X\n\n/* Defined to 1 if the corresponding _FloatN type is not binary compatible\n   with the corresponding ISO C type in the current compilation unit as\n   opposed to __HAVE_DISTINCT_FLOATN, which indicates the default types built\n   in glibc.  */\n#define __HAVE_FLOAT128_UNLIKE_LDBL (__HAVE_DISTINCT_FLOAT128\t\\\n\t\t\t\t     && __LDBL_MANT_DIG__ != 113)\n\n/* Defined to 1 if any _FloatN or _FloatNx types that are not\n   ABI-distinct are however distinct types at the C language level (so\n   for the purposes of __builtin_types_compatible_p and _Generic).  */\n#if __GNUC_PREREQ (7, 0) && !defined __cplusplus\n# define __HAVE_FLOATN_NOT_TYPEDEF 1\n#else\n# define __HAVE_FLOATN_NOT_TYPEDEF 0\n#endif\n\n#ifndef __ASSEMBLER__\n\n/* Defined to concatenate the literal suffix to be used with _FloatN\n   or _FloatNx types, if __HAVE_<type> is 1.  The corresponding\n   literal suffixes exist since GCC 7, for C only.  */\n# if __HAVE_FLOAT16\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n/* No corresponding suffix available for this type.  */\n#   define __f16(x) ((_Float16) x##f)\n#  else\n#   define __f16(x) x##f16\n#  endif\n# endif\n\n# if __HAVE_FLOAT32\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   define __f32(x) x##f\n#  else\n#   define __f32(x) x##f32\n#  endif\n# endif\n\n# if __HAVE_FLOAT64\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   ifdef __NO_LONG_DOUBLE_MATH\n#    define __f64(x) x##l\n#   else\n#    define __f64(x) x\n#   endif\n#  else\n#   define __f64(x) x##f64\n#  endif\n# endif\n\n# if __HAVE_FLOAT32X\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   define __f32x(x) x\n#  else\n#   define __f32x(x) x##f32x\n#  endif\n# endif\n\n# if __HAVE_FLOAT64X\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   if __HAVE_FLOAT64X_LONG_DOUBLE\n#    define __f64x(x) x##l\n#   else\n#    define __f64x(x) __f128 (x)\n#   endif\n#  else\n#   define __f64x(x) x##f64x\n#  endif\n# endif\n\n# if __HAVE_FLOAT128X\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   error \"_Float128X supported but no constant suffix\"\n#  else\n#   define __f128x(x) x##f128x\n#  endif\n# endif\n\n/* Defined to a complex type if __HAVE_<type> is 1.  */\n# if __HAVE_FLOAT16\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\ntypedef _Complex float __cfloat16 __attribute__ ((__mode__ (__HC__)));\n#   define __CFLOAT16 __cfloat16\n#  else\n#   define __CFLOAT16 _Complex _Float16\n#  endif\n# endif\n\n# if __HAVE_FLOAT32\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   define __CFLOAT32 _Complex float\n#  else\n#   define __CFLOAT32 _Complex _Float32\n#  endif\n# endif\n\n# if __HAVE_FLOAT64\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   ifdef __NO_LONG_DOUBLE_MATH\n#    define __CFLOAT64 _Complex long double\n#   else\n#    define __CFLOAT64 _Complex double\n#   endif\n#  else\n#   define __CFLOAT64 _Complex _Float64\n#  endif\n# endif\n\n# if __HAVE_FLOAT32X\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   define __CFLOAT32X _Complex double\n#  else\n#   define __CFLOAT32X _Complex _Float32x\n#  endif\n# endif\n\n# if __HAVE_FLOAT64X\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   if __HAVE_FLOAT64X_LONG_DOUBLE\n#    define __CFLOAT64X _Complex long double\n#   else\n#    define __CFLOAT64X __CFLOAT128\n#   endif\n#  else\n#   define __CFLOAT64X _Complex _Float64x\n#  endif\n# endif\n\n# if __HAVE_FLOAT128X\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   error \"_Float128X supported but no complex type\"\n#  else\n#   define __CFLOAT128X _Complex _Float128x\n#  endif\n# endif\n\n/* The remaining of this file provides support for older compilers.  */\n# if __HAVE_FLOAT16\n\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\ntypedef float _Float16 __attribute__ ((__mode__ (__HF__)));\n#  endif\n\n#  if !__GNUC_PREREQ (7, 0)\n#   define __builtin_huge_valf16() ((_Float16) __builtin_huge_val ())\n#   define __builtin_inff16() ((_Float16) __builtin_inf ())\n#   define __builtin_nanf16(x) ((_Float16) __builtin_nan (x))\n#   define __builtin_nansf16(x) ((_Float16) __builtin_nans (x))\n#  endif\n\n# endif\n\n# if __HAVE_FLOAT32\n\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\ntypedef float _Float32;\n#  endif\n\n#  if !__GNUC_PREREQ (7, 0)\n#   define __builtin_huge_valf32() (__builtin_huge_valf ())\n#   define __builtin_inff32() (__builtin_inff ())\n#   define __builtin_nanf32(x) (__builtin_nanf (x))\n#   define __builtin_nansf32(x) (__builtin_nansf (x))\n#  endif\n\n# endif\n\n# if __HAVE_FLOAT64\n\n/* If double, long double and _Float64 all have the same set of\n   values, TS 18661-3 requires the usual arithmetic conversions on\n   long double and _Float64 to produce _Float64.  For this to be the\n   case when building with a compiler without a distinct _Float64\n   type, _Float64 must be a typedef for long double, not for\n   double.  */\n\n#  ifdef __NO_LONG_DOUBLE_MATH\n\n#   if !__GNUC_PREREQ (7, 0) || defined __cplusplus\ntypedef long double _Float64;\n#   endif\n\n#   if !__GNUC_PREREQ (7, 0)\n#    define __builtin_huge_valf64() (__builtin_huge_vall ())\n#    define __builtin_inff64() (__builtin_infl ())\n#    define __builtin_nanf64(x) (__builtin_nanl (x))\n#    define __builtin_nansf64(x) (__builtin_nansl (x))\n#   endif\n\n#  else\n\n#   if !__GNUC_PREREQ (7, 0) || defined __cplusplus\ntypedef double _Float64;\n#   endif\n\n#   if !__GNUC_PREREQ (7, 0)\n#    define __builtin_huge_valf64() (__builtin_huge_val ())\n#    define __builtin_inff64() (__builtin_inf ())\n#    define __builtin_nanf64(x) (__builtin_nan (x))\n#    define __builtin_nansf64(x) (__builtin_nans (x))\n#   endif\n\n#  endif\n\n# endif\n\n# if __HAVE_FLOAT32X\n\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\ntypedef double _Float32x;\n#  endif\n\n#  if !__GNUC_PREREQ (7, 0)\n#   define __builtin_huge_valf32x() (__builtin_huge_val ())\n#   define __builtin_inff32x() (__builtin_inf ())\n#   define __builtin_nanf32x(x) (__builtin_nan (x))\n#   define __builtin_nansf32x(x) (__builtin_nans (x))\n#  endif\n\n# endif\n\n# if __HAVE_FLOAT64X\n\n#  if __HAVE_FLOAT64X_LONG_DOUBLE\n\n#   if !__GNUC_PREREQ (7, 0) || defined __cplusplus\ntypedef long double _Float64x;\n#   endif\n\n#   if !__GNUC_PREREQ (7, 0)\n#    define __builtin_huge_valf64x() (__builtin_huge_vall ())\n#    define __builtin_inff64x() (__builtin_infl ())\n#    define __builtin_nanf64x(x) (__builtin_nanl (x))\n#    define __builtin_nansf64x(x) (__builtin_nansl (x))\n#   endif\n\n#  else\n\n#   if !__GNUC_PREREQ (7, 0) || defined __cplusplus\ntypedef _Float128 _Float64x;\n#   endif\n\n#   if !__GNUC_PREREQ (7, 0)\n#    define __builtin_huge_valf64x() (__builtin_huge_valf128 ())\n#    define __builtin_inff64x() (__builtin_inff128 ())\n#    define __builtin_nanf64x(x) (__builtin_nanf128 (x))\n#    define __builtin_nansf64x(x) (__builtin_nansf128 (x))\n#   endif\n\n#  endif\n\n# endif\n\n# if __HAVE_FLOAT128X\n\n#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n#   error \"_Float128x supported but no type\"\n#  endif\n\n#  if !__GNUC_PREREQ (7, 0)\n#   define __builtin_huge_valf128x() ((_Float128x) __builtin_huge_val ())\n#   define __builtin_inff128x() ((_Float128x) __builtin_inf ())\n#   define __builtin_nanf128x(x) ((_Float128x) __builtin_nan (x))\n#   define __builtin_nansf128x(x) ((_Float128x) __builtin_nans (x))\n#  endif\n\n# endif\n\n#endif /* !__ASSEMBLER__.  */\n\n#endif /* _BITS_FLOATN_COMMON_H */\n"}],"crc32":1161602910,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]