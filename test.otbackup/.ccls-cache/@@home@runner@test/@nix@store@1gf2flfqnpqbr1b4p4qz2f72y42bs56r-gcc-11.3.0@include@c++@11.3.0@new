[{"ops":[{"insert":"// The -*- C++ -*- dynamic memory management header.\n\n// Copyright (C) 1994-2021 Free Software Foundation, Inc.\n\n// This file is part of GCC.\n//\n// GCC is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation; either version 3, or (at your option)\n// any later version.\n// \n// GCC is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// \n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file new\n *  This is a Standard C++ Library header.\n *\n *  The header @c new defines several functions to manage dynamic memory and\n *  handling memory allocation errors; see\n *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/dynamic_memory.html\n *  for more.\n */\n\n#ifndef _NEW\n#define _NEW\n\n#pragma GCC system_header\n\n#include <bits/c++config.h>\n#include <bits/exception.h>\n\n#pragma GCC visibility push(default)\n\nextern \"C++\" {\n\nnamespace std \n{\n  /**\n   *  @brief  Exception possibly thrown by @c new.\n   *  @ingroup exceptions\n   *\n   *  @c bad_alloc (or classes derived from it) is used to report allocation\n   *  errors from the throwing forms of @c new.  */\n  class bad_alloc : public exception\n  {\n  public:\n    bad_alloc() throw() { }\n\n#if __cplusplus >= 201103L\n    bad_alloc(const bad_alloc&) = default;\n    bad_alloc& operator=(const bad_alloc&) = default;\n#endif\n\n    // This declaration is not useless:\n    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118\n    virtual ~bad_alloc() throw();\n\n    // See comment in eh_exception.cc.\n    virtual const char* what() const throw();\n  };\n\n#if __cplusplus >= 201103L\n  class bad_array_new_length : public bad_alloc\n  {\n  public:\n    bad_array_new_length() throw() { }\n\n    // This declaration is not useless:\n    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118\n    virtual ~bad_array_new_length() throw();\n\n    // See comment in eh_exception.cc.\n    virtual const char* what() const throw();\n  };\n#endif\n\n#if __cpp_aligned_new\n  enum class align_val_t: size_t {};\n#endif\n\n  struct nothrow_t\n  {\n#if __cplusplus >= 201103L\n    explicit nothrow_t() = default;\n#endif\n  };\n\n  extern const nothrow_t nothrow;\n\n  /** If you write your own error handler to be called by @c new, it must\n   *  be of this type.  */\n  typedef void (*new_handler)();\n\n  /// Takes a replacement handler as the argument, returns the\n  /// previous handler.\n  new_handler set_new_handler(new_handler) throw();\n\n#if __cplusplus >= 201103L\n  /// Return the current new handler.\n  new_handler get_new_handler() noexcept;\n#endif\n} // namespace std\n\n//@{\n/** These are replaceable signatures:\n *  - normal single new and delete (no arguments, throw @c bad_alloc on error)\n *  - normal array new and delete (same)\n *  - @c nothrow single new and delete (take a @c nothrow argument, return\n *    @c NULL on error)\n *  - @c nothrow array new and delete (same)\n *\n *  Placement new and delete signatures (take a memory address argument,\n *  does nothing) may not be replaced by a user's program.\n*/\n_GLIBCXX_NODISCARD void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)\n  __attribute__((__externally_visible__));\n_GLIBCXX_NODISCARD void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)\n  __attribute__((__externally_visible__));\nvoid operator delete(void*) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__));\nvoid operator delete[](void*) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__));\n#if __cpp_sized_deallocation\nvoid operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__));\nvoid operator delete[](void*, std::size_t) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__));\n#endif\n_GLIBCXX_NODISCARD void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));\n_GLIBCXX_NODISCARD void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));\nvoid operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__));\nvoid operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__));\n#if __cpp_aligned_new\n_GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t)\n  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));\n_GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)\n  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));\nvoid operator delete(void*, std::align_val_t)\n  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\nvoid operator delete(void*, std::align_val_t, const std::nothrow_t&)\n  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n_GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t)\n  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));\n_GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)\n  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));\nvoid operator delete[](void*, std::align_val_t)\n  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\nvoid operator delete[](void*, std::align_val_t, const std::nothrow_t&)\n  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n#if __cpp_sized_deallocation\nvoid operator delete(void*, std::size_t, std::align_val_t)\n  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\nvoid operator delete[](void*, std::size_t, std::align_val_t)\n  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n#endif // __cpp_sized_deallocation\n#endif // __cpp_aligned_new\n\n// Default placement versions of operator new.\n_GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT\n{ return __p; }\n_GLIBCXX_NODISCARD inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT\n{ return __p; }\n\n// Default placement versions of operator delete.\ninline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }\ninline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }\n//@}\n} // extern \"C++\"\n\n#if __cplusplus >= 201703L\n#ifdef _GLIBCXX_HAVE_BUILTIN_LAUNDER\nnamespace std\n{\n#define __cpp_lib_launder 201606\n  /// Pointer optimization barrier [ptr.launder]\n  template<typename _Tp>\n    [[nodiscard]] constexpr _Tp*\n    launder(_Tp* __p) noexcept\n    { return __builtin_launder(__p); }\n\n  // The program is ill-formed if T is a function type or\n  // (possibly cv-qualified) void.\n\n  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>\n    void launder(_Ret (*)(_Args...) _GLIBCXX_NOEXCEPT_QUAL) = delete;\n  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>\n    void launder(_Ret (*)(_Args......) _GLIBCXX_NOEXCEPT_QUAL) = delete;\n\n  void launder(void*) = delete;\n  void launder(const void*) = delete;\n  void launder(volatile void*) = delete;\n  void launder(const volatile void*) = delete;\n}\n#endif // _GLIBCXX_HAVE_BUILTIN_LAUNDER\n#endif // C++17\n\n#if __cplusplus > 201703L\nnamespace std\n{\n  /// Tag type used to declare a class-specific operator delete that can\n  /// invoke the destructor before deallocating the memory.\n  struct destroying_delete_t\n  {\n    explicit destroying_delete_t() = default;\n  };\n  /// Tag variable of type destroying_delete_t.\n  inline constexpr destroying_delete_t destroying_delete{};\n}\n// Only define the feature test macro if the compiler supports the feature:\n#if __cpp_impl_destroying_delete\n# define __cpp_lib_destroying_delete 201806L\n#endif\n#endif // C++20\n\n#pragma GCC visibility pop\n\n#endif\n"}],"crc32":1983836958,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]