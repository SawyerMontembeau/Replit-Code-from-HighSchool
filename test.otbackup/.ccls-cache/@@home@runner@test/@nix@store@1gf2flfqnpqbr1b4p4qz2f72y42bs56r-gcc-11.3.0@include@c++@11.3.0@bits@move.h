[{"ops":[{"insert":"// Move, forward and identity for C++11 + swap -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/move.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{utility}\n */\n\n#ifndef _MOVE_H\n#define _MOVE_H 1\n\n#include <bits/c++config.h>\n#if __cplusplus < 201103L\n# include <bits/concept_check.h>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // Used, in C++03 mode too, by allocators, etc.\n  /**\n   *  @brief Same as C++11 std::addressof\n   *  @ingroup utilities\n   */\n  template<typename _Tp>\n    inline _GLIBCXX_CONSTEXPR _Tp*\n    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT\n    { return __builtin_addressof(__r); }\n\n#if __cplusplus >= 201103L\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#include <type_traits> // Brings in std::declval too.\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @addtogroup utilities\n   *  @{\n   */\n\n  /**\n   *  @brief  Forward an lvalue.\n   *  @return The parameter cast to the specified type.\n   *\n   *  This function is used to implement \"perfect forwarding\".\n   */\n  template<typename _Tp>\n    _GLIBCXX_NODISCARD\n    constexpr _Tp&&\n    forward(typename std::remove_reference<_Tp>::type& __t) noexcept\n    { return static_cast<_Tp&&>(__t); }\n\n  /**\n   *  @brief  Forward an rvalue.\n   *  @return The parameter cast to the specified type.\n   *\n   *  This function is used to implement \"perfect forwarding\".\n   */\n  template<typename _Tp>\n    _GLIBCXX_NODISCARD\n    constexpr _Tp&&\n    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept\n    {\n      static_assert(!std::is_lvalue_reference<_Tp>::value,\n\t  \"std::forward must not be used to convert an rvalue to an lvalue\");\n      return static_cast<_Tp&&>(__t);\n    }\n\n  /**\n   *  @brief  Convert a value to an rvalue.\n   *  @param  __t  A thing of arbitrary type.\n   *  @return The parameter cast to an rvalue-reference to allow moving it.\n  */\n  template<typename _Tp>\n    _GLIBCXX_NODISCARD\n    constexpr typename std::remove_reference<_Tp>::type&&\n    move(_Tp&& __t) noexcept\n    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }\n\n\n  template<typename _Tp>\n    struct __move_if_noexcept_cond\n    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,\n                    is_copy_constructible<_Tp>>::type { };\n\n  /**\n   *  @brief  Conditionally convert a value to an rvalue.\n   *  @param  __x  A thing of arbitrary type.\n   *  @return The parameter, possibly cast to an rvalue-reference.\n   *\n   *  Same as std::move unless the type's move constructor could throw and the\n   *  type is copyable, in which case an lvalue-reference is returned instead.\n   */\n  template<typename _Tp>\n    _GLIBCXX_NODISCARD\n    constexpr typename\n    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type\n    move_if_noexcept(_Tp& __x) noexcept\n    { return std::move(__x); }\n\n  // declval, from type_traits.\n\n#if __cplusplus > 201402L\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2296. std::addressof should be constexpr\n# define __cpp_lib_addressof_constexpr 201603\n#endif\n  /**\n   *  @brief Returns the actual address of the object or function\n   *         referenced by r, even in the presence of an overloaded\n   *         operator&.\n   *  @param  __r  Reference to an object or function.\n   *  @return   The actual address.\n  */\n  template<typename _Tp>\n    _GLIBCXX_NODISCARD\n    inline _GLIBCXX17_CONSTEXPR _Tp*\n    addressof(_Tp& __r) noexcept\n    { return std::__addressof(__r); }\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2598. addressof works on temporaries\n  template<typename _Tp>\n    const _Tp* addressof(const _Tp&&) = delete;\n\n  // C++11 version of std::exchange for internal use.\n  template <typename _Tp, typename _Up = _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline _Tp\n    __exchange(_Tp& __obj, _Up&& __new_val)\n    {\n      _Tp __old_val = std::move(__obj);\n      __obj = std::forward<_Up>(__new_val);\n      return __old_val;\n    }\n\n  /// @} group utilities\n\n#define _GLIBCXX_FWDREF(_Tp) _Tp&&\n#define _GLIBCXX_MOVE(__val) std::move(__val)\n#define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)\n#else\n#define _GLIBCXX_FWDREF(_Tp) const _Tp&\n#define _GLIBCXX_MOVE(__val) (__val)\n#define _GLIBCXX_FORWARD(_Tp, __val) (__val)\n#endif\n\n  /**\n   *  @addtogroup utilities\n   *  @{\n   */\n\n  /**\n   *  @brief Swaps two values.\n   *  @param  __a  A thing of arbitrary type.\n   *  @param  __b  Another thing of arbitrary type.\n   *  @return   Nothing.\n  */\n  template<typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline\n#if __cplusplus >= 201103L\n    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,\n\t\t\t      is_move_constructible<_Tp>,\n\t\t\t      is_move_assignable<_Tp>>::value>::type\n#else\n    void\n#endif\n    swap(_Tp& __a, _Tp& __b)\n    _GLIBCXX_NOEXCEPT_IF(__and_<is_nothrow_move_constructible<_Tp>,\n\t\t\t\tis_nothrow_move_assignable<_Tp>>::value)\n    {\n#if __cplusplus < 201103L\n      // concept requirements\n      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)\n#endif\n      _Tp __tmp = _GLIBCXX_MOVE(__a);\n      __a = _GLIBCXX_MOVE(__b);\n      __b = _GLIBCXX_MOVE(__tmp);\n    }\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // DR 809. std::swap should be overloaded for array types.\n  /// Swap the contents of two arrays.\n  template<typename _Tp, size_t _Nm>\n    _GLIBCXX20_CONSTEXPR\n    inline\n#if __cplusplus >= 201103L\n    typename enable_if<__is_swappable<_Tp>::value>::type\n#else\n    void\n#endif\n    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])\n    _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Tp>::value)\n    {\n      for (size_t __n = 0; __n < _Nm; ++__n)\n\tswap(__a[__n], __b[__n]);\n    }\n\n  /// @} group utilities\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif /* _MOVE_H */\n"}],"crc32":3620849882,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]