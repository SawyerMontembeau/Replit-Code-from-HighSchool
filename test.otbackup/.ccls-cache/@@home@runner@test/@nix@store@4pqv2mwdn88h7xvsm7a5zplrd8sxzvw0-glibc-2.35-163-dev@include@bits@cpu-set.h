[{"ops":[{"insert":"/* Definition of the cpu_set_t structure used by the POSIX 1003.1b-1993\n   scheduling interface.\n   Copyright (C) 1996-2022 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n#ifndef _BITS_CPU_SET_H\n#define _BITS_CPU_SET_H 1\n\n#ifndef _SCHED_H\n# error \"Never include <bits/cpu-set.h> directly; use <sched.h> instead.\"\n#endif\n\n/* Size definition for CPU sets.  */\n#define __CPU_SETSIZE\t1024\n#define __NCPUBITS\t(8 * sizeof (__cpu_mask))\n\n/* Type for array elements in 'cpu_set_t'.  */\ntypedef __CPU_MASK_TYPE __cpu_mask;\n\n/* Basic access functions.  */\n#define __CPUELT(cpu)\t((cpu) / __NCPUBITS)\n#define __CPUMASK(cpu)\t((__cpu_mask) 1 << ((cpu) % __NCPUBITS))\n\n/* Data structure to describe CPU mask.  */\ntypedef struct\n{\n  __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];\n} cpu_set_t;\n\n/* Access functions for CPU masks.  */\n#if __GNUC_PREREQ (2, 91)\n# define __CPU_ZERO_S(setsize, cpusetp) \\\n  do __builtin_memset (cpusetp, '\\0', setsize); while (0)\n#else\n# define __CPU_ZERO_S(setsize, cpusetp) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    size_t __i;\t\t\t\t\t\t\t\t      \\\n    size_t __imax = (setsize) / sizeof (__cpu_mask);\t\t\t      \\\n    __cpu_mask *__bits = (cpusetp)->__bits;\t\t\t\t      \\\n    for (__i = 0; __i < __imax; ++__i)\t\t\t\t\t      \\\n      __bits[__i] = 0;\t\t\t\t\t\t\t      \\\n  } while (0)\n#endif\n#define __CPU_SET_S(cpu, setsize, cpusetp) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ size_t __cpu = (cpu);\t\t\t\t\t\t      \\\n      __cpu / 8 < (setsize)\t\t\t\t\t\t      \\\n      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]\t\t      \\\n\t |= __CPUMASK (__cpu))\t\t\t\t\t\t      \\\n      : 0; }))\n#define __CPU_CLR_S(cpu, setsize, cpusetp) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ size_t __cpu = (cpu);\t\t\t\t\t\t      \\\n      __cpu / 8 < (setsize)\t\t\t\t\t\t      \\\n      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]\t\t      \\\n\t &= ~__CPUMASK (__cpu))\t\t\t\t\t\t      \\\n      : 0; }))\n#define __CPU_ISSET_S(cpu, setsize, cpusetp) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ size_t __cpu = (cpu);\t\t\t\t\t\t      \\\n      __cpu / 8 < (setsize)\t\t\t\t\t\t      \\\n      ? ((((const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]\t      \\\n\t  & __CPUMASK (__cpu))) != 0\t\t\t\t\t      \\\n      : 0; }))\n\n#define __CPU_COUNT_S(setsize, cpusetp) \\\n  __sched_cpucount (setsize, cpusetp)\n\n#if __GNUC_PREREQ (2, 91)\n# define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \\\n  (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)\n#else\n# define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ const __cpu_mask *__arr1 = (cpusetp1)->__bits;\t\t\t      \\\n      const __cpu_mask *__arr2 = (cpusetp2)->__bits;\t\t\t      \\\n      size_t __imax = (setsize) / sizeof (__cpu_mask);\t\t\t      \\\n      size_t __i;\t\t\t\t\t\t\t      \\\n      for (__i = 0; __i < __imax; ++__i)\t\t\t\t      \\\n\tif (__arr1[__i] != __arr2[__i])\t\t\t\t\t      \\\n\t  break;\t\t\t\t\t\t\t      \\\n      __i == __imax; }))\n#endif\n\n#define __CPU_OP_S(setsize, destset, srcset1, srcset2, op) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ cpu_set_t *__dest = (destset);\t\t\t\t\t      \\\n      const __cpu_mask *__arr1 = (srcset1)->__bits;\t\t\t      \\\n      const __cpu_mask *__arr2 = (srcset2)->__bits;\t\t\t      \\\n      size_t __imax = (setsize) / sizeof (__cpu_mask);\t\t\t      \\\n      size_t __i;\t\t\t\t\t\t\t      \\\n      for (__i = 0; __i < __imax; ++__i)\t\t\t\t      \\\n\t((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i];    \\\n      __dest; }))\n\n#define __CPU_ALLOC_SIZE(count) \\\n  ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))\n#define __CPU_ALLOC(count) __sched_cpualloc (count)\n#define __CPU_FREE(cpuset) __sched_cpufree (cpuset)\n\n__BEGIN_DECLS\n\nextern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)\n     __THROW;\nextern cpu_set_t *__sched_cpualloc (size_t __count) __THROW __wur;\nextern void __sched_cpufree (cpu_set_t *__set) __THROW;\n\n__END_DECLS\n\n#endif /* bits/cpu-set.h */\n"}],"crc32":4050078163,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]