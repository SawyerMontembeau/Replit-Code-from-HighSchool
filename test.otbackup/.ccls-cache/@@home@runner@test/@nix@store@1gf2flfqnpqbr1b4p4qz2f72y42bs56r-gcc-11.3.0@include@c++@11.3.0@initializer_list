[{"ops":[{"insert":"// std::initializer_list support -*- C++ -*-\n\n// Copyright (C) 2008-2021 Free Software Foundation, Inc.\n//\n// This file is part of GCC.\n//\n// GCC is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation; either version 3, or (at your option)\n// any later version.\n//\n// GCC is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file initializer_list\n *  This is a Standard C++ Library header.\n */\n\n#ifndef _INITIALIZER_LIST\n#define _INITIALIZER_LIST\n\n#pragma GCC system_header\n\n#if __cplusplus < 201103L\n# include <bits/c++0x_warning.h>\n#else // C++0x\n\n#pragma GCC visibility push(default)\n\n#include <bits/c++config.h>\n\nnamespace std\n{\n  /// initializer_list\n  template<class _E>\n    class initializer_list\n    {\n    public:\n      typedef _E \t\tvalue_type;\n      typedef const _E& \treference;\n      typedef const _E& \tconst_reference;\n      typedef size_t \t\tsize_type;\n      typedef const _E* \titerator;\n      typedef const _E* \tconst_iterator;\n\n    private:\n      iterator\t\t\t_M_array;\n      size_type\t\t\t_M_len;\n\n      // The compiler can call a private constructor.\n      constexpr initializer_list(const_iterator __a, size_type __l)\n      : _M_array(__a), _M_len(__l) { }\n\n    public:\n      constexpr initializer_list() noexcept\n      : _M_array(0), _M_len(0) { }\n\n      // Number of elements.\n      constexpr size_type\n      size() const noexcept { return _M_len; }\n\n      // First element.\n      constexpr const_iterator\n      begin() const noexcept { return _M_array; }\n\n      // One past the last element.\n      constexpr const_iterator\n      end() const noexcept { return begin() + size(); }\n    };\n\n  /**\n   *  @brief  Return an iterator pointing to the first element of\n   *          the initializer_list.\n   *  @param  __ils  Initializer list.\n   *  @relates initializer_list\n   */\n  template<class _Tp>\n    constexpr const _Tp*\n    begin(initializer_list<_Tp> __ils) noexcept\n    { return __ils.begin(); }\n\n  /**\n   *  @brief  Return an iterator pointing to one past the last element\n   *          of the initializer_list.\n   *  @param  __ils  Initializer list.\n   *  @relates initializer_list\n   */\n  template<class _Tp>\n    constexpr const _Tp*\n    end(initializer_list<_Tp> __ils) noexcept\n    { return __ils.end(); }\n}\n\n#pragma GCC visibility pop\n\n#endif // C++11\n\n#endif // _INITIALIZER_LIST\n"}],"crc32":13178026,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]