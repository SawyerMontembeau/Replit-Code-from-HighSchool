[{"ops":[{"insert":"// Locale support -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/locale_classes.tcc\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{locale}\n */\n\n//\n// ISO C++ 14882: 22.1  Locales\n//\n\n#ifndef _LOCALE_CLASSES_TCC\n#define _LOCALE_CLASSES_TCC 1\n\n#pragma GCC system_header\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template<typename _Facet>\n    locale::\n    locale(const locale& __other, _Facet* __f)\n    {\n      _M_impl = new _Impl(*__other._M_impl, 1);\n\n      __try\n\t{ _M_impl->_M_install_facet(&_Facet::id, __f); }\n      __catch(...)\n\t{\n\t  _M_impl->_M_remove_reference();\n\t  __throw_exception_again;\n\t}\n      delete [] _M_impl->_M_names[0];\n      _M_impl->_M_names[0] = 0;   // Unnamed.\n    }\n\n  template<typename _Facet>\n    locale\n    locale::\n    combine(const locale& __other) const\n    {\n      _Impl* __tmp = new _Impl(*_M_impl, 1);\n      __try\n\t{\n\t  __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);\n\t}\n      __catch(...)\n\t{\n\t  __tmp->_M_remove_reference();\n\t  __throw_exception_again;\n\t}\n      return locale(__tmp);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    bool\n    locale::\n    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __s2) const\n    {\n      typedef std::collate<_CharT> __collate_type;\n      const __collate_type& __collate = use_facet<__collate_type>(*this);\n      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),\n\t\t\t\t__s2.data(), __s2.data() + __s2.length()) < 0);\n    }\n\n  /**\n   *  @brief  Test for the presence of a facet.\n   *  @ingroup locales\n   *\n   *  has_facet tests the locale argument for the presence of the facet type\n   *  provided as the template parameter.  Facets derived from the facet\n   *  parameter will also return true.\n   *\n   *  @tparam  _Facet  The facet type to test the presence of.\n   *  @param  __loc  The locale to test.\n   *  @return  true if @p __loc contains a facet of type _Facet, else false.\n  */\n  template<typename _Facet>\n    bool\n    has_facet(const locale& __loc) throw()\n    {\n      const size_t __i = _Facet::id._M_id();\n      const locale::facet** __facets = __loc._M_impl->_M_facets;\n      return (__i < __loc._M_impl->_M_facets_size\n#if __cpp_rtti\n\t      && dynamic_cast<const _Facet*>(__facets[__i]));\n#else\n              && static_cast<const _Facet*>(__facets[__i]));\n#endif\n    }\n\n  /**\n   *  @brief  Return a facet.\n   *  @ingroup locales\n   *\n   *  use_facet looks for and returns a reference to a facet of type Facet\n   *  where Facet is the template parameter.  If has_facet(locale) is true,\n   *  there is a suitable facet to return.  It throws std::bad_cast if the\n   *  locale doesn't contain a facet of type Facet.\n   *\n   *  @tparam  _Facet  The facet type to access.\n   *  @param  __loc  The locale to use.\n   *  @return  Reference to facet of type Facet.\n   *  @throw  std::bad_cast if @p __loc doesn't contain a facet of type _Facet.\n  */\n  template<typename _Facet>\n    const _Facet&\n    use_facet(const locale& __loc)\n    {\n      const size_t __i = _Facet::id._M_id();\n      const locale::facet** __facets = __loc._M_impl->_M_facets;\n      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])\n        __throw_bad_cast();\n#if __cpp_rtti\n      return dynamic_cast<const _Facet&>(*__facets[__i]);\n#else\n      return static_cast<const _Facet&>(*__facets[__i]);\n#endif\n    }\n\n\n  // Generic version does nothing.\n  template<typename _CharT>\n    int\n    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()\n    { return 0; }\n\n  // Generic version does nothing.\n  template<typename _CharT>\n    size_t\n    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()\n    { return 0; }\n\n  template<typename _CharT>\n    int\n    collate<_CharT>::\n    do_compare(const _CharT* __lo1, const _CharT* __hi1,\n\t       const _CharT* __lo2, const _CharT* __hi2) const\n    {\n      // strcoll assumes zero-terminated strings so we make a copy\n      // and then put a zero at the end.\n      const string_type __one(__lo1, __hi1);\n      const string_type __two(__lo2, __hi2);\n\n      const _CharT* __p = __one.c_str();\n      const _CharT* __pend = __one.data() + __one.length();\n      const _CharT* __q = __two.c_str();\n      const _CharT* __qend = __two.data() + __two.length();\n\n      // strcoll stops when it sees a nul character so we break\n      // the strings into zero-terminated substrings and pass those\n      // to strcoll.\n      for (;;)\n\t{\n\t  const int __res = _M_compare(__p, __q);\n\t  if (__res)\n\t    return __res;\n\n\t  __p += char_traits<_CharT>::length(__p);\n\t  __q += char_traits<_CharT>::length(__q);\n\t  if (__p == __pend && __q == __qend)\n\t    return 0;\n\t  else if (__p == __pend)\n\t    return -1;\n\t  else if (__q == __qend)\n\t    return 1;\n\n\t  __p++;\n\t  __q++;\n\t}\n    }\n\n  template<typename _CharT>\n    typename collate<_CharT>::string_type\n    collate<_CharT>::\n    do_transform(const _CharT* __lo, const _CharT* __hi) const\n    {\n      string_type __ret;\n\n      // strxfrm assumes zero-terminated strings so we make a copy\n      const string_type __str(__lo, __hi);\n\n      const _CharT* __p = __str.c_str();\n      const _CharT* __pend = __str.data() + __str.length();\n\n      size_t __len = (__hi - __lo) * 2;\n\n      _CharT* __c = new _CharT[__len];\n\n      __try\n\t{\n\t  // strxfrm stops when it sees a nul character so we break\n\t  // the string into zero-terminated substrings and pass those\n\t  // to strxfrm.\n\t  for (;;)\n\t    {\n\t      // First try a buffer perhaps big enough.\n\t      size_t __res = _M_transform(__c, __p, __len);\n\t      // If the buffer was not large enough, try again with the\n\t      // correct size.\n\t      if (__res >= __len)\n\t\t{\n\t\t  __len = __res + 1;\n\t\t  delete [] __c, __c = 0;\n\t\t  __c = new _CharT[__len];\n\t\t  __res = _M_transform(__c, __p, __len);\n\t\t}\n\n\t      __ret.append(__c, __res);\n\t      __p += char_traits<_CharT>::length(__p);\n\t      if (__p == __pend)\n\t\tbreak;\n\n\t      __p++;\n\t      __ret.push_back(_CharT());\n\t    }\n\t}\n      __catch(...)\n\t{\n\t  delete [] __c;\n\t  __throw_exception_again;\n\t}\n\n      delete [] __c;\n\n      return __ret;\n    }\n\n  template<typename _CharT>\n    long\n    collate<_CharT>::\n    do_hash(const _CharT* __lo, const _CharT* __hi) const\n    {\n      unsigned long __val = 0;\n      for (; __lo < __hi; ++__lo)\n\t__val =\n\t  *__lo + ((__val << 7)\n\t\t   | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::\n\t\t\t\t__digits - 7)));\n      return static_cast<long>(__val);\n    }\n\n  // Inhibit implicit instantiations for required instantiations,\n  // which are defined via explicit instantiations elsewhere.\n#if _GLIBCXX_EXTERN_TEMPLATE\n  extern template class collate<char>;\n  extern template class collate_byname<char>;\n\n  extern template\n    const collate<char>&\n    use_facet<collate<char> >(const locale&);\n\n  extern template\n    bool\n    has_facet<collate<char> >(const locale&);\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  extern template class collate<wchar_t>;\n  extern template class collate_byname<wchar_t>;\n\n  extern template\n    const collate<wchar_t>&\n    use_facet<collate<wchar_t> >(const locale&);\n\n  extern template\n    bool\n    has_facet<collate<wchar_t> >(const locale&);\n#endif\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif\n"}],"crc32":1129953948,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]