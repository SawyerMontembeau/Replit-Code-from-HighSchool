[{"ops":[{"insert":"// Locale support -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/locale_classes.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{locale}\n */\n\n//\n// ISO C++ 14882: 22.1  Locales\n//\n\n#ifndef _LOCALE_CLASSES_H\n#define _LOCALE_CLASSES_H 1\n\n#pragma GCC system_header\n\n#include <bits/localefwd.h>\n#include <string>\n#include <ext/atomicity.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // 22.1.1 Class locale\n  /**\n   *  @brief  Container class for localization functionality.\n   *  @ingroup locales\n   *\n   *  The locale class is first a class wrapper for C library locales.  It is\n   *  also an extensible container for user-defined localization.  A locale is\n   *  a collection of facets that implement various localization features such\n   *  as money, time, and number printing.\n   *\n   *  Constructing C++ locales does not change the C library locale.\n   *\n   *  This library supports efficient construction and copying of locales\n   *  through a reference counting implementation of the locale class.\n  */\n  class locale\n  {\n  public:\n    // Types:\n    /// Definition of locale::category.\n    typedef int\tcategory;\n\n    // Forward decls and friends:\n    class facet;\n    class id;\n    class _Impl;\n\n    friend class facet;\n    friend class _Impl;\n\n    template<typename _Facet>\n      friend bool\n      has_facet(const locale&) throw();\n\n    template<typename _Facet>\n      friend const _Facet&\n      use_facet(const locale&);\n\n    template<typename _Cache>\n      friend struct __use_cache;\n\n    ///@{\n    /**\n     *  @brief  Category values.\n     *\n     *  The standard category values are none, ctype, numeric, collate, time,\n     *  monetary, and messages.  They form a bitmask that supports union and\n     *  intersection.  The category all is the union of these values.\n     *\n     *  NB: Order must match _S_facet_categories definition in locale.cc\n    */\n    static const category none\t\t= 0;\n    static const category ctype\t\t= 1L << 0;\n    static const category numeric\t= 1L << 1;\n    static const category collate\t= 1L << 2;\n    static const category time\t\t= 1L << 3;\n    static const category monetary\t= 1L << 4;\n    static const category messages\t= 1L << 5;\n    static const category all\t\t= (ctype | numeric | collate |\n\t\t\t\t\t   time  | monetary | messages);\n    ///@}\n\n    // Construct/copy/destroy:\n\n    /**\n     *  @brief  Default constructor.\n     *\n     *  Constructs a copy of the global locale.  If no locale has been\n     *  explicitly set, this is the C locale.\n    */\n    locale() throw();\n\n    /**\n     *  @brief  Copy constructor.\n     *\n     *  Constructs a copy of @a other.\n     *\n     *  @param  __other  The locale to copy.\n    */\n    locale(const locale& __other) throw();\n\n    /**\n     *  @brief  Named locale constructor.\n     *\n     *  Constructs a copy of the named C library locale.\n     *\n     *  @param  __s  Name of the locale to construct.\n     *  @throw  std::runtime_error if __s is null or an undefined locale.\n    */\n    explicit\n    locale(const char* __s);\n\n    /**\n     *  @brief  Construct locale with facets from another locale.\n     *\n     *  Constructs a copy of the locale @a base.  The facets specified by @a\n     *  cat are replaced with those from the locale named by @a s.  If base is\n     *  named, this locale instance will also be named.\n     *\n     *  @param  __base  The locale to copy.\n     *  @param  __s  Name of the locale to use facets from.\n     *  @param  __cat  Set of categories defining the facets to use from __s.\n     *  @throw  std::runtime_error if __s is null or an undefined locale.\n    */\n    locale(const locale& __base, const char* __s, category __cat);\n\n#if __cplusplus >= 201103L\n    /**\n     *  @brief  Named locale constructor.\n     *\n     *  Constructs a copy of the named C library locale.\n     *\n     *  @param  __s  Name of the locale to construct.\n     *  @throw  std::runtime_error if __s is an undefined locale.\n    */\n    explicit\n    locale(const std::string& __s) : locale(__s.c_str()) { }\n\n    /**\n     *  @brief  Construct locale with facets from another locale.\n     *\n     *  Constructs a copy of the locale @a base.  The facets specified by @a\n     *  cat are replaced with those from the locale named by @a s.  If base is\n     *  named, this locale instance will also be named.\n     *\n     *  @param  __base  The locale to copy.\n     *  @param  __s  Name of the locale to use facets from.\n     *  @param  __cat  Set of categories defining the facets to use from __s.\n     *  @throw  std::runtime_error if __s is an undefined locale.\n    */\n    locale(const locale& __base, const std::string& __s, category __cat)\n    : locale(__base, __s.c_str(), __cat) { }\n#endif\n\n    /**\n     *  @brief  Construct locale with facets from another locale.\n     *\n     *  Constructs a copy of the locale @a base.  The facets specified by @a\n     *  cat are replaced with those from the locale @a add.  If @a base and @a\n     *  add are named, this locale instance will also be named.\n     *\n     *  @param  __base  The locale to copy.\n     *  @param  __add  The locale to use facets from.\n     *  @param  __cat  Set of categories defining the facets to use from add.\n    */\n    locale(const locale& __base, const locale& __add, category __cat);\n\n    /**\n     *  @brief  Construct locale with another facet.\n     *\n     *  Constructs a copy of the locale @a __other.  The facet @a __f\n     *  is added to @a __other, replacing an existing facet of type\n     *  Facet if there is one.  If @a __f is null, this locale is a\n     *  copy of @a __other.\n     *\n     *  @param  __other  The locale to copy.\n     *  @param  __f  The facet to add in.\n    */\n    template<typename _Facet>\n      locale(const locale& __other, _Facet* __f);\n\n    /// Locale destructor.\n    ~locale() throw();\n\n    /**\n     *  @brief  Assignment operator.\n     *\n     *  Set this locale to be a copy of @a other.\n     *\n     *  @param  __other  The locale to copy.\n     *  @return  A reference to this locale.\n    */\n    const locale&\n    operator=(const locale& __other) throw();\n\n    /**\n     *  @brief  Construct locale with another facet.\n     *\n     *  Constructs and returns a new copy of this locale.  Adds or replaces an\n     *  existing facet of type Facet from the locale @a other into the new\n     *  locale.\n     *\n     *  @tparam  _Facet  The facet type to copy from other\n     *  @param  __other  The locale to copy from.\n     *  @return  Newly constructed locale.\n     *  @throw  std::runtime_error if __other has no facet of type _Facet.\n    */\n    template<typename _Facet>\n      locale\n      combine(const locale& __other) const;\n\n    // Locale operations:\n    /**\n     *  @brief  Return locale name.\n     *  @return  Locale name or \"*\" if unnamed.\n    */\n    _GLIBCXX_DEFAULT_ABI_TAG\n    string\n    name() const;\n\n    /**\n     *  @brief  Locale equality.\n     *\n     *  @param  __other  The locale to compare against.\n     *  @return  True if other and this refer to the same locale instance, are\n     *\t\t copies, or have the same name.  False otherwise.\n    */\n    bool\n    operator==(const locale& __other) const throw();\n\n#if __cpp_impl_three_way_comparison < 201907L\n    /**\n     *  @brief  Locale inequality.\n     *\n     *  @param  __other  The locale to compare against.\n     *  @return  ! (*this == __other)\n    */\n    bool\n    operator!=(const locale& __other) const throw()\n    { return !(this->operator==(__other)); }\n#endif\n\n    /**\n     *  @brief  Compare two strings according to collate.\n     *\n     *  Template operator to compare two strings using the compare function of\n     *  the collate facet in this locale.  One use is to provide the locale to\n     *  the sort function.  For example, a vector v of strings could be sorted\n     *  according to locale loc by doing:\n     *  @code\n     *  std::sort(v.begin(), v.end(), loc);\n     *  @endcode\n     *\n     *  @param  __s1  First string to compare.\n     *  @param  __s2  Second string to compare.\n     *  @return  True if collate<_Char> facet compares __s1 < __s2, else false.\n    */\n    template<typename _Char, typename _Traits, typename _Alloc>\n      bool\n      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,\n\t\t const basic_string<_Char, _Traits, _Alloc>& __s2) const;\n\n    // Global locale objects:\n    /**\n     *  @brief  Set global locale\n     *\n     *  This function sets the global locale to the argument and returns a\n     *  copy of the previous global locale.  If the argument has a name, it\n     *  will also call std::setlocale(LC_ALL, loc.name()).\n     *\n     *  @param  __loc  The new locale to make global.\n     *  @return  Copy of the old global locale.\n    */\n    static locale\n    global(const locale& __loc);\n\n    /**\n     *  @brief  Return reference to the C locale.\n    */\n    static const locale&\n    classic();\n\n  private:\n    // The (shared) implementation\n    _Impl*\t\t_M_impl;\n\n    // The \"C\" reference locale\n    static _Impl*       _S_classic;\n\n    // Current global locale\n    static _Impl*\t_S_global;\n\n    // Names of underlying locale categories.\n    // NB: locale::global() has to know how to modify all the\n    // underlying categories, not just the ones required by the C++\n    // standard.\n    static const char* const* const _S_categories;\n\n    // Number of standard categories. For C++, these categories are\n    // collate, ctype, monetary, numeric, time, and messages. These\n    // directly correspond to ISO C99 macros LC_COLLATE, LC_CTYPE,\n    // LC_MONETARY, LC_NUMERIC, and LC_TIME. In addition, POSIX (IEEE\n    // 1003.1-2001) specifies LC_MESSAGES.\n    // In addition to the standard categories, the underlying\n    // operating system is allowed to define extra LC_*\n    // macros. For GNU systems, the following are also valid:\n    // LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT,\n    // and LC_IDENTIFICATION.\n    enum { _S_categories_size = 6 + _GLIBCXX_NUM_CATEGORIES };\n\n#ifdef __GTHREADS\n    static __gthread_once_t _S_once;\n#endif\n\n    explicit\n    locale(_Impl*) throw();\n\n    static void\n    _S_initialize();\n\n    static void\n    _S_initialize_once() throw();\n\n    static category\n    _S_normalize_category(category);\n\n    void\n    _M_coalesce(const locale& __base, const locale& __add, category __cat);\n\n#if _GLIBCXX_USE_CXX11_ABI\n    static const id* const _S_twinned_facets[];\n#endif\n  };\n\n\n  // 22.1.1.1.2  Class locale::facet\n  /**\n   *  @brief  Localization functionality base class.\n   *  @ingroup locales\n   *\n   *  The facet class is the base class for a localization feature, such as\n   *  money, time, and number printing.  It provides common support for facets\n   *  and reference management.\n   *\n   *  Facets may not be copied or assigned.\n  */\n  class locale::facet\n  {\n  private:\n    friend class locale;\n    friend class locale::_Impl;\n\n    mutable _Atomic_word\t\t_M_refcount;\n\n    // Contains data from the underlying \"C\" library for the classic locale.\n    static __c_locale                   _S_c_locale;\n\n    // String literal for the name of the classic locale.\n    static const char\t\t\t_S_c_name[2];\n\n#ifdef __GTHREADS\n    static __gthread_once_t\t\t_S_once;\n#endif\n\n    static void\n    _S_initialize_once();\n\n  protected:\n    /**\n     *  @brief  Facet constructor.\n     *\n     *  This is the constructor provided by the standard.  If refs is 0, the\n     *  facet is destroyed when the last referencing locale is destroyed.\n     *  Otherwise the facet will never be destroyed.\n     *\n     *  @param __refs  The initial value for reference count.\n    */\n    explicit\n    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)\n    { }\n\n    /// Facet destructor.\n    virtual\n    ~facet();\n\n    static void\n    _S_create_c_locale(__c_locale& __cloc, const char* __s,\n\t\t       __c_locale __old = 0);\n\n    static __c_locale\n    _S_clone_c_locale(__c_locale& __cloc) throw();\n\n    static void\n    _S_destroy_c_locale(__c_locale& __cloc);\n\n    static __c_locale\n    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);\n\n    // Returns data from the underlying \"C\" library data for the\n    // classic locale.\n    static __c_locale\n    _S_get_c_locale();\n\n    _GLIBCXX_CONST static const char*\n    _S_get_c_name() throw();\n\n#if __cplusplus < 201103L\n  private:\n    facet(const facet&);  // Not defined.\n\n    facet&\n    operator=(const facet&);  // Not defined.\n#else\n    facet(const facet&) = delete;\n\n    facet&\n    operator=(const facet&) = delete;\n#endif\n\n  private:\n    void\n    _M_add_reference() const throw()\n    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n    void\n    _M_remove_reference() const throw()\n    {\n      // Be race-detector-friendly.  For more info see bits/c++config.\n      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_refcount);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)\n\t{\n          _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_refcount);\n\t  __try\n\t    { delete this; }\n\t  __catch(...)\n\t    { }\n\t}\n    }\n\n    const facet* _M_sso_shim(const id*) const;\n    const facet* _M_cow_shim(const id*) const;\n\n  protected:\n    class __shim; // For internal use only.\n  };\n\n\n  // 22.1.1.1.3 Class locale::id\n  /**\n   *  @brief  Facet ID class.\n   *  @ingroup locales\n   *\n   *  The ID class provides facets with an index used to identify them.\n   *  Every facet class must define a public static member locale::id, or be\n   *  derived from a facet that provides this member, otherwise the facet\n   *  cannot be used in a locale.  The locale::id ensures that each class\n   *  type gets a unique identifier.\n  */\n  class locale::id\n  {\n  private:\n    friend class locale;\n    friend class locale::_Impl;\n\n    template<typename _Facet>\n      friend const _Facet&\n      use_facet(const locale&);\n\n    template<typename _Facet>\n      friend bool\n      has_facet(const locale&) throw();\n\n    // NB: There is no accessor for _M_index because it may be used\n    // before the constructor is run; the effect of calling a member\n    // function (even an inline) would be undefined.\n    mutable size_t\t\t_M_index;\n\n    // Last id number assigned.\n    static _Atomic_word\t\t_S_refcount;\n\n    void\n    operator=(const id&);  // Not defined.\n\n    id(const id&);  // Not defined.\n\n  public:\n    // NB: This class is always a static data member, and thus can be\n    // counted on to be zero-initialized.\n    /// Constructor.\n    id() { }\n\n    size_t\n    _M_id() const throw();\n  };\n\n\n  // Implementation object for locale.\n  class locale::_Impl\n  {\n  public:\n    // Friends.\n    friend class locale;\n    friend class locale::facet;\n\n    template<typename _Facet>\n      friend bool\n      has_facet(const locale&) throw();\n\n    template<typename _Facet>\n      friend const _Facet&\n      use_facet(const locale&);\n\n    template<typename _Cache>\n      friend struct __use_cache;\n\n  private:\n    // Data Members.\n    _Atomic_word\t\t\t_M_refcount;\n    const facet**\t\t\t_M_facets;\n    size_t\t\t\t\t_M_facets_size;\n    const facet**\t\t\t_M_caches;\n    char**\t\t\t\t_M_names;\n    static const locale::id* const\t_S_id_ctype[];\n    static const locale::id* const\t_S_id_numeric[];\n    static const locale::id* const\t_S_id_collate[];\n    static const locale::id* const\t_S_id_time[];\n    static const locale::id* const\t_S_id_monetary[];\n    static const locale::id* const\t_S_id_messages[];\n    static const locale::id* const* const _S_facet_categories[];\n\n    void\n    _M_add_reference() throw()\n    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n    void\n    _M_remove_reference() throw()\n    {\n      // Be race-detector-friendly.  For more info see bits/c++config.\n      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_refcount);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)\n\t{\n          _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_refcount);\n\t  __try\n\t    { delete this; }\n\t  __catch(...)\n\t    { }\n\t}\n    }\n\n    _Impl(const _Impl&, size_t);\n    _Impl(const char*, size_t);\n    _Impl(size_t) throw();\n\n   ~_Impl() throw();\n\n    _Impl(const _Impl&);  // Not defined.\n\n    void\n    operator=(const _Impl&);  // Not defined.\n\n    bool\n    _M_check_same_name()\n    {\n      bool __ret = true;\n      if (_M_names[1])\n\t// We must actually compare all the _M_names: can be all equal!\n\tfor (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)\n\t  __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;\n      return __ret;\n    }\n\n    void\n    _M_replace_categories(const _Impl*, category);\n\n    void\n    _M_replace_category(const _Impl*, const locale::id* const*);\n\n    void\n    _M_replace_facet(const _Impl*, const locale::id*);\n\n    void\n    _M_install_facet(const locale::id*, const facet*);\n\n    template<typename _Facet>\n      void\n      _M_init_facet(_Facet* __facet)\n      { _M_install_facet(&_Facet::id, __facet); }\n\n    template<typename _Facet>\n      void\n      _M_init_facet_unchecked(_Facet* __facet)\n      {\n\t__facet->_M_add_reference();\n\t_M_facets[_Facet::id._M_id()] = __facet;\n      }\n\n    void\n    _M_install_cache(const facet*, size_t);\n\n    void _M_init_extra(facet**);\n    void _M_init_extra(void*, void*, const char*, const char*);\n\n#ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n    void _M_init_extra_ldbl128(bool);\n#endif\n  };\n\n\n  /**\n   *  @brief  Facet for localized string comparison.\n   *\n   *  This facet encapsulates the code to compare strings in a localized\n   *  manner.\n   *\n   *  The collate template uses protected virtual functions to provide\n   *  the actual results.  The public accessors forward the call to\n   *  the virtual functions.  These virtual functions are hooks for\n   *  developers to implement the behavior they require from the\n   *  collate facet.\n  */\n  template<typename _CharT>\n    class _GLIBCXX_NAMESPACE_CXX11 collate : public locale::facet\n    {\n    public:\n      // Types:\n      ///@{\n      /// Public typedefs\n      typedef _CharT\t\t\tchar_type;\n      typedef basic_string<_CharT>\tstring_type;\n      ///@}\n\n    protected:\n      // Underlying \"C\" library locale information saved from\n      // initialization, needed by collate_byname as well.\n      __c_locale\t\t\t_M_c_locale_collate;\n\n    public:\n      /// Numpunct facet id.\n      static locale::id\t\t\tid;\n\n      /**\n       *  @brief  Constructor performs initialization.\n       *\n       *  This is the constructor provided by the standard.\n       *\n       *  @param __refs  Passed to the base facet class.\n      */\n      explicit\n      collate(size_t __refs = 0)\n      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())\n      { }\n\n      /**\n       *  @brief  Internal constructor. Not for general use.\n       *\n       *  This is a constructor for use by the library itself to set up new\n       *  locales.\n       *\n       *  @param __cloc  The C locale.\n       *  @param __refs  Passed to the base facet class.\n      */\n      explicit\n      collate(__c_locale __cloc, size_t __refs = 0)\n      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))\n      { }\n\n      /**\n       *  @brief  Compare two strings.\n       *\n       *  This function compares two strings and returns the result by calling\n       *  collate::do_compare().\n       *\n       *  @param __lo1  Start of string 1.\n       *  @param __hi1  End of string 1.\n       *  @param __lo2  Start of string 2.\n       *  @param __hi2  End of string 2.\n       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\n      */\n      int\n      compare(const _CharT* __lo1, const _CharT* __hi1,\n\t      const _CharT* __lo2, const _CharT* __hi2) const\n      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }\n\n      /**\n       *  @brief  Transform string to comparable form.\n       *\n       *  This function is a wrapper for strxfrm functionality.  It takes the\n       *  input string and returns a modified string that can be directly\n       *  compared to other transformed strings.  In the C locale, this\n       *  function just returns a copy of the input string.  In some other\n       *  locales, it may replace two chars with one, change a char for\n       *  another, etc.  It does so by returning collate::do_transform().\n       *\n       *  @param __lo  Start of string.\n       *  @param __hi  End of string.\n       *  @return  Transformed string_type.\n      */\n      string_type\n      transform(const _CharT* __lo, const _CharT* __hi) const\n      { return this->do_transform(__lo, __hi); }\n\n      /**\n       *  @brief  Return hash of a string.\n       *\n       *  This function computes and returns a hash on the input string.  It\n       *  does so by returning collate::do_hash().\n       *\n       *  @param __lo  Start of string.\n       *  @param __hi  End of string.\n       *  @return  Hash value.\n      */\n      long\n      hash(const _CharT* __lo, const _CharT* __hi) const\n      { return this->do_hash(__lo, __hi); }\n\n      // Used to abstract out _CharT bits in virtual member functions, below.\n      int\n      _M_compare(const _CharT*, const _CharT*) const throw();\n\n      size_t\n      _M_transform(_CharT*, const _CharT*, size_t) const throw();\n\n  protected:\n      /// Destructor.\n      virtual\n      ~collate()\n      { _S_destroy_c_locale(_M_c_locale_collate); }\n\n      /**\n       *  @brief  Compare two strings.\n       *\n       *  This function is a hook for derived classes to change the value\n       *  returned.  @see compare().\n       *\n       *  @param __lo1  Start of string 1.\n       *  @param __hi1  End of string 1.\n       *  @param __lo2  Start of string 2.\n       *  @param __hi2  End of string 2.\n       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\n      */\n      virtual int\n      do_compare(const _CharT* __lo1, const _CharT* __hi1,\n\t\t const _CharT* __lo2, const _CharT* __hi2) const;\n\n      /**\n       *  @brief  Transform string to comparable form.\n       *\n       *  This function is a hook for derived classes to change the value\n       *  returned.\n       *\n       *  @param __lo  Start.\n       *  @param __hi  End.\n       *  @return  transformed string.\n      */\n      virtual string_type\n      do_transform(const _CharT* __lo, const _CharT* __hi) const;\n\n      /**\n       *  @brief  Return hash of a string.\n       *\n       *  This function computes and returns a hash on the input string.  This\n       *  function is a hook for derived classes to change the value returned.\n       *\n       *  @param __lo  Start of string.\n       *  @param __hi  End of string.\n       *  @return  Hash value.\n      */\n      virtual long\n      do_hash(const _CharT* __lo, const _CharT* __hi) const;\n    };\n\n  template<typename _CharT>\n    locale::id collate<_CharT>::id;\n\n  // Specializations.\n  template<>\n    int\n    collate<char>::_M_compare(const char*, const char*) const throw();\n\n  template<>\n    size_t\n    collate<char>::_M_transform(char*, const char*, size_t) const throw();\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  template<>\n    int\n    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();\n\n  template<>\n    size_t\n    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();\n#endif\n\n  /// class collate_byname [22.2.4.2].\n  template<typename _CharT>\n    class _GLIBCXX_NAMESPACE_CXX11 collate_byname : public collate<_CharT>\n    {\n    public:\n      ///@{\n      /// Public typedefs\n      typedef _CharT               char_type;\n      typedef basic_string<_CharT> string_type;\n      ///@}\n\n      explicit\n      collate_byname(const char* __s, size_t __refs = 0)\n      : collate<_CharT>(__refs)\n      {\n\tif (__builtin_strcmp(__s, \"C\") != 0\n\t    && __builtin_strcmp(__s, \"POSIX\") != 0)\n\t  {\n\t    this->_S_destroy_c_locale(this->_M_c_locale_collate);\n\t    this->_S_create_c_locale(this->_M_c_locale_collate, __s);\n\t  }\n      }\n\n#if __cplusplus >= 201103L\n      explicit\n      collate_byname(const string& __s, size_t __refs = 0)\n      : collate_byname(__s.c_str(), __refs) { }\n#endif\n\n    protected:\n      virtual\n      ~collate_byname() { }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n# include <bits/locale_classes.tcc>\n\n#endif\n"}],"crc32":2060190032,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]