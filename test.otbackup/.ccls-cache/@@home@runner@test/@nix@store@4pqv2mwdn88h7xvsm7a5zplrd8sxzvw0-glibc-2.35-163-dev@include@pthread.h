[{"ops":[{"insert":"/* Copyright (C) 2002-2022 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n#ifndef _PTHREAD_H\n#define _PTHREAD_H\t1\n\n#include <features.h>\n#include <sched.h>\n#include <time.h>\n\n#include <bits/endian.h>\n#include <bits/pthreadtypes.h>\n#include <bits/setjmp.h>\n#include <bits/wordsize.h>\n#include <bits/types/struct_timespec.h>\n#include <bits/types/__sigset_t.h>\n#include <bits/types/struct___jmp_buf_tag.h>\n#ifdef __USE_MISC\n# include <bits/pthread_stack_min-dynamic.h>\n#endif\n\n/* Detach state.  */\nenum\n{\n  PTHREAD_CREATE_JOINABLE,\n#define PTHREAD_CREATE_JOINABLE\tPTHREAD_CREATE_JOINABLE\n  PTHREAD_CREATE_DETACHED\n#define PTHREAD_CREATE_DETACHED\tPTHREAD_CREATE_DETACHED\n};\n\n\n/* Mutex types.  */\nenum\n{\n  PTHREAD_MUTEX_TIMED_NP,\n  PTHREAD_MUTEX_RECURSIVE_NP,\n  PTHREAD_MUTEX_ERRORCHECK_NP,\n  PTHREAD_MUTEX_ADAPTIVE_NP\n#if defined __USE_UNIX98 || defined __USE_XOPEN2K8\n  ,\n  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,\n  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,\n  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,\n  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL\n#endif\n#ifdef __USE_GNU\n  /* For compatibility.  */\n  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP\n#endif\n};\n\n\n#ifdef __USE_XOPEN2K\n/* Robust mutex or not flags.  */\nenum\n{\n  PTHREAD_MUTEX_STALLED,\n  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,\n  PTHREAD_MUTEX_ROBUST,\n  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST\n};\n#endif\n\n\n#if defined __USE_POSIX199506 || defined __USE_UNIX98\n/* Mutex protocols.  */\nenum\n{\n  PTHREAD_PRIO_NONE,\n  PTHREAD_PRIO_INHERIT,\n  PTHREAD_PRIO_PROTECT\n};\n#endif\n\n\n#define PTHREAD_MUTEX_INITIALIZER \\\n { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_TIMED_NP) } }\n#ifdef __USE_GNU\n# define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \\\n { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_RECURSIVE_NP) } }\n# define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \\\n { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ERRORCHECK_NP) } }\n# define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \\\n { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ADAPTIVE_NP) } }\n#endif\n\n\n/* Read-write lock types.  */\n#if defined __USE_UNIX98 || defined __USE_XOPEN2K\nenum\n{\n  PTHREAD_RWLOCK_PREFER_READER_NP,\n  PTHREAD_RWLOCK_PREFER_WRITER_NP,\n  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,\n  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP\n};\n\n\n/* Read-write lock initializers.  */\n# define PTHREAD_RWLOCK_INITIALIZER \\\n  { { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_DEFAULT_NP) } }\n# ifdef __USE_GNU\n#  define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \\\n  { { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) } }\n# endif\n#endif  /* Unix98 or XOpen2K */\n\n\n/* Scheduler inheritance.  */\nenum\n{\n  PTHREAD_INHERIT_SCHED,\n#define PTHREAD_INHERIT_SCHED   PTHREAD_INHERIT_SCHED\n  PTHREAD_EXPLICIT_SCHED\n#define PTHREAD_EXPLICIT_SCHED  PTHREAD_EXPLICIT_SCHED\n};\n\n\n/* Scope handling.  */\nenum\n{\n  PTHREAD_SCOPE_SYSTEM,\n#define PTHREAD_SCOPE_SYSTEM    PTHREAD_SCOPE_SYSTEM\n  PTHREAD_SCOPE_PROCESS\n#define PTHREAD_SCOPE_PROCESS   PTHREAD_SCOPE_PROCESS\n};\n\n\n/* Process shared or private flag.  */\nenum\n{\n  PTHREAD_PROCESS_PRIVATE,\n#define PTHREAD_PROCESS_PRIVATE PTHREAD_PROCESS_PRIVATE\n  PTHREAD_PROCESS_SHARED\n#define PTHREAD_PROCESS_SHARED  PTHREAD_PROCESS_SHARED\n};\n\n\n\n/* Conditional variable handling.  */\n#define PTHREAD_COND_INITIALIZER { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } }\n\n\n/* Cleanup buffers */\nstruct _pthread_cleanup_buffer\n{\n  void (*__routine) (void *);             /* Function to call.  */\n  void *__arg;                            /* Its argument.  */\n  int __canceltype;                       /* Saved cancellation type. */\n  struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */\n};\n\n/* Cancellation */\nenum\n{\n  PTHREAD_CANCEL_ENABLE,\n#define PTHREAD_CANCEL_ENABLE   PTHREAD_CANCEL_ENABLE\n  PTHREAD_CANCEL_DISABLE\n#define PTHREAD_CANCEL_DISABLE  PTHREAD_CANCEL_DISABLE\n};\nenum\n{\n  PTHREAD_CANCEL_DEFERRED,\n#define PTHREAD_CANCEL_DEFERRED\tPTHREAD_CANCEL_DEFERRED\n  PTHREAD_CANCEL_ASYNCHRONOUS\n#define PTHREAD_CANCEL_ASYNCHRONOUS\tPTHREAD_CANCEL_ASYNCHRONOUS\n};\n#define PTHREAD_CANCELED ((void *) -1)\n\n\n/* Single execution handling.  */\n#define PTHREAD_ONCE_INIT 0\n\n\n#ifdef __USE_XOPEN2K\n/* Value returned by 'pthread_barrier_wait' for one of the threads after\n   the required number of threads have called this function.\n   -1 is distinct from 0 and all errno constants */\n# define PTHREAD_BARRIER_SERIAL_THREAD -1\n#endif\n\n\n__BEGIN_DECLS\n\n/* Create a new thread, starting with execution of START-ROUTINE\n   getting passed ARG.  Creation attributed come from ATTR.  The new\n   handle is stored in *NEWTHREAD.  */\nextern int pthread_create (pthread_t *__restrict __newthread,\n\t\t\t   const pthread_attr_t *__restrict __attr,\n\t\t\t   void *(*__start_routine) (void *),\n\t\t\t   void *__restrict __arg) __THROWNL __nonnull ((1, 3));\n\n/* Terminate calling thread.\n\n   The registered cleanup handlers are called via exception handling\n   so we cannot mark this function with __THROW.*/\nextern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));\n\n/* Make calling thread wait for termination of the thread TH.  The\n   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN\n   is not NULL.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int pthread_join (pthread_t __th, void **__thread_return);\n\n#ifdef __USE_GNU\n/* Check whether thread TH has terminated.  If yes return the status of\n   the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  */\nextern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __THROW;\n\n# ifndef __USE_TIME_BITS64\n/* Make calling thread wait for termination of the thread TH, but only\n   until TIMEOUT.  The exit status of the thread is stored in\n   *THREAD_RETURN, if THREAD_RETURN is not NULL.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,\n\t\t\t\t const struct timespec *__abstime);\n\n/* Make calling thread wait for termination of the thread TH, but only\n   until TIMEOUT measured against the clock specified by CLOCKID.  The\n   exit status of the thread is stored in *THREAD_RETURN, if\n   THREAD_RETURN is not NULL.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,\n                                 clockid_t __clockid,\n\t\t\t\t const struct timespec *__abstime);\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (pthread_timedjoin_np,\n                       (pthread_t __th, void **__thread_return,\n                        const struct timespec *__abstime),\n                       __pthread_timedjoin_np64);\n\nextern int __REDIRECT (pthread_clockjoin_np,\n                       (pthread_t __th, void **__thread_return,\n                        clockid_t __clockid,\n                        const struct timespec *__abstime),\n                       __pthread_clockjoin_np64);\n#  else\n#   define pthread_timedjoin_np __pthread_timedjoin_np64\n#   define pthread_clockjoin_np __pthread_clockjoin_np64\n#  endif\n# endif\n#endif\n\n/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.\n   The resources of TH will therefore be freed immediately when it\n   terminates, instead of waiting for another thread to perform PTHREAD_JOIN\n   on it.  */\nextern int pthread_detach (pthread_t __th) __THROW;\n\n\n/* Obtain the identifier of the current thread.  */\nextern pthread_t pthread_self (void) __THROW __attribute__ ((__const__));\n\n/* Compare two thread identifiers.  */\nextern int pthread_equal (pthread_t __thread1, pthread_t __thread2)\n  __THROW __attribute__ ((__const__));\n\n\n/* Thread attribute handling.  */\n\n/* Initialize thread attribute *ATTR with default attributes\n   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,\n    no user-provided stack).  */\nextern int pthread_attr_init (pthread_attr_t *__attr) __THROW __nonnull ((1));\n\n/* Destroy thread attribute *ATTR.  */\nextern int pthread_attr_destroy (pthread_attr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Get detach state attribute.  */\nextern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,\n\t\t\t\t\tint *__detachstate)\n     __THROW __nonnull ((1, 2));\n\n/* Set detach state attribute.  */\nextern int pthread_attr_setdetachstate (pthread_attr_t *__attr,\n\t\t\t\t\tint __detachstate)\n     __THROW __nonnull ((1));\n\n\n/* Get the size of the guard area created for stack overflow protection.  */\nextern int pthread_attr_getguardsize (const pthread_attr_t *__attr,\n\t\t\t\t      size_t *__guardsize)\n     __THROW __nonnull ((1, 2));\n\n/* Set the size of the guard area created for stack overflow protection.  */\nextern int pthread_attr_setguardsize (pthread_attr_t *__attr,\n\t\t\t\t      size_t __guardsize)\n     __THROW __nonnull ((1));\n\n\n/* Return in *PARAM the scheduling parameters of *ATTR.  */\nextern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,\n\t\t\t\t       struct sched_param *__restrict __param)\n     __THROW __nonnull ((1, 2));\n\n/* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  */\nextern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,\n\t\t\t\t       const struct sched_param *__restrict\n\t\t\t\t       __param) __THROW __nonnull ((1, 2));\n\n/* Return in *POLICY the scheduling policy of *ATTR.  */\nextern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict\n\t\t\t\t\t__attr, int *__restrict __policy)\n     __THROW __nonnull ((1, 2));\n\n/* Set scheduling policy in *ATTR according to POLICY.  */\nextern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)\n     __THROW __nonnull ((1));\n\n/* Return in *INHERIT the scheduling inheritance mode of *ATTR.  */\nextern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict\n\t\t\t\t\t __attr, int *__restrict __inherit)\n     __THROW __nonnull ((1, 2));\n\n/* Set scheduling inheritance mode in *ATTR according to INHERIT.  */\nextern int pthread_attr_setinheritsched (pthread_attr_t *__attr,\n\t\t\t\t\t int __inherit)\n     __THROW __nonnull ((1));\n\n\n/* Return in *SCOPE the scheduling contention scope of *ATTR.  */\nextern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,\n\t\t\t\t  int *__restrict __scope)\n     __THROW __nonnull ((1, 2));\n\n/* Set scheduling contention scope in *ATTR according to SCOPE.  */\nextern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)\n     __THROW __nonnull ((1));\n\n/* Return the previously set address for the stack.  */\nextern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict\n\t\t\t\t      __attr, void **__restrict __stackaddr)\n     __THROW __nonnull ((1, 2)) __attribute_deprecated__;\n\n/* Set the starting address of the stack of the thread to be created.\n   Depending on whether the stack grows up or down the value must either\n   be higher or lower than all the address in the memory block.  The\n   minimal size of the block must be PTHREAD_STACK_MIN.  */\nextern int pthread_attr_setstackaddr (pthread_attr_t *__attr,\n\t\t\t\t      void *__stackaddr)\n     __THROW __nonnull ((1)) __attribute_deprecated__;\n\n/* Return the currently used minimal stack size.  */\nextern int pthread_attr_getstacksize (const pthread_attr_t *__restrict\n\t\t\t\t      __attr, size_t *__restrict __stacksize)\n     __THROW __nonnull ((1, 2));\n\n/* Add information about the minimum stack size needed for the thread\n   to be started.  This size must never be less than PTHREAD_STACK_MIN\n   and must also not exceed the system limits.  */\nextern int pthread_attr_setstacksize (pthread_attr_t *__attr,\n\t\t\t\t      size_t __stacksize)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_XOPEN2K\n/* Return the previously set address for the stack.  */\nextern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,\n\t\t\t\t  void **__restrict __stackaddr,\n\t\t\t\t  size_t *__restrict __stacksize)\n     __THROW __nonnull ((1, 2, 3));\n\n/* The following two interfaces are intended to replace the last two.  They\n   require setting the address as well as the size since only setting the\n   address will make the implementation on some architectures impossible.  */\nextern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,\n\t\t\t\t  size_t __stacksize) __THROW __nonnull ((1));\n#endif\n\n#ifdef __USE_GNU\n/* Thread created with attribute ATTR will be limited to run only on\n   the processors represented in CPUSET.  */\nextern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,\n\t\t\t\t\tsize_t __cpusetsize,\n\t\t\t\t\tconst cpu_set_t *__cpuset)\n     __THROW __nonnull ((1, 3));\n\n/* Get bit set in CPUSET representing the processors threads created with\n   ATTR can run on.  */\nextern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,\n\t\t\t\t\tsize_t __cpusetsize,\n\t\t\t\t\tcpu_set_t *__cpuset)\n     __THROW __nonnull ((1, 3));\n\n/* Get the default attributes used by pthread_create in this process.  */\nextern int pthread_getattr_default_np (pthread_attr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Store *SIGMASK as the signal mask for the new thread in *ATTR.  */\nextern int pthread_attr_setsigmask_np (pthread_attr_t *__attr,\n\t\t\t\t       const __sigset_t *sigmask);\n\n/* Store the signal mask of *ATTR in *SIGMASK.  If there is no signal\n   mask stored, return PTHREAD_ATTR_NOSIGMASK_NP.  Return zero on\n   success.  */\nextern int pthread_attr_getsigmask_np (const pthread_attr_t *__attr,\n\t\t\t\t       __sigset_t *sigmask);\n\n/* Special return value from pthread_attr_getsigmask_np if the signal\n   mask has not been set.  */\n#define PTHREAD_ATTR_NO_SIGMASK_NP (-1)\n\n/* Set the default attributes to be used by pthread_create in this\n   process.  */\nextern int pthread_setattr_default_np (const pthread_attr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Initialize thread attribute *ATTR with attributes corresponding to the\n   already running thread TH.  It shall be called on uninitialized ATTR\n   and destroyed with pthread_attr_destroy when no longer needed.  */\nextern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)\n     __THROW __nonnull ((2));\n#endif\n\n\n/* Functions for scheduling control.  */\n\n/* Set the scheduling parameters for TARGET_THREAD according to POLICY\n   and *PARAM.  */\nextern int pthread_setschedparam (pthread_t __target_thread, int __policy,\n\t\t\t\t  const struct sched_param *__param)\n     __THROW __nonnull ((3));\n\n/* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. */\nextern int pthread_getschedparam (pthread_t __target_thread,\n\t\t\t\t  int *__restrict __policy,\n\t\t\t\t  struct sched_param *__restrict __param)\n     __THROW __nonnull ((2, 3));\n\n/* Set the scheduling priority for TARGET_THREAD.  */\nextern int pthread_setschedprio (pthread_t __target_thread, int __prio)\n     __THROW;\n\n\n#ifdef __USE_GNU\n/* Get thread name visible in the kernel and its interfaces.  */\nextern int pthread_getname_np (pthread_t __target_thread, char *__buf,\n\t\t\t       size_t __buflen)\n     __THROW __nonnull ((2));\n\n/* Set thread name visible in the kernel and its interfaces.  */\nextern int pthread_setname_np (pthread_t __target_thread, const char *__name)\n     __THROW __nonnull ((2));\n#endif\n\n\n#ifdef __USE_UNIX98\n/* Determine level of concurrency.  */\nextern int pthread_getconcurrency (void) __THROW;\n\n/* Set new concurrency level to LEVEL.  */\nextern int pthread_setconcurrency (int __level) __THROW;\n#endif\n\n#ifdef __USE_GNU\nextern int pthread_yield (void) __THROW;\n# ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (pthread_yield, (void), sched_yield)\n  __attribute_deprecated_msg__ (\"\\\npthread_yield is deprecated, use sched_yield instead\");\n# else\n#  define pthread_yield sched_yield\n# endif\n\n\n/* Limit specified thread TH to run only on the processors represented\n   in CPUSET.  */\nextern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,\n\t\t\t\t   const cpu_set_t *__cpuset)\n     __THROW __nonnull ((3));\n\n/* Get bit set in CPUSET representing the processors TH can run on.  */\nextern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,\n\t\t\t\t   cpu_set_t *__cpuset)\n     __THROW __nonnull ((3));\n#endif\n\n\n/* Functions for handling initialization.  */\n\n/* Guarantee that the initialization function INIT_ROUTINE will be called\n   only once, even if pthread_once is executed several times with the\n   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or\n   extern variable initialized to PTHREAD_ONCE_INIT.\n\n   The initialization functions might throw exception which is why\n   this function is not marked with __THROW.  */\nextern int pthread_once (pthread_once_t *__once_control,\n\t\t\t void (*__init_routine) (void)) __nonnull ((1, 2));\n\n\n/* Functions for handling cancellation.\n\n   Note that these functions are explicitly not marked to not throw an\n   exception in C++ code.  If cancellation is implemented by unwinding\n   this is necessary to have the compiler generate the unwind information.  */\n\n/* Set cancelability state of current thread to STATE, returning old\n   state in *OLDSTATE if OLDSTATE is not NULL.  */\nextern int pthread_setcancelstate (int __state, int *__oldstate);\n\n/* Set cancellation state of current thread to TYPE, returning the old\n   type in *OLDTYPE if OLDTYPE is not NULL.  */\nextern int pthread_setcanceltype (int __type, int *__oldtype);\n\n/* Cancel THREAD immediately or at the next possibility.  */\nextern int pthread_cancel (pthread_t __th);\n\n/* Test for pending cancellation for the current thread and terminate\n   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been\n   cancelled.  */\nextern void pthread_testcancel (void);\n\n\n/* Cancellation handling with integration into exception handling.  */\n\nstruct __cancel_jmp_buf_tag\n{\n  __jmp_buf __cancel_jmp_buf;\n  int __mask_was_saved;\n};\n\ntypedef struct\n{\n  struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];\n  void *__pad[4];\n} __pthread_unwind_buf_t __attribute__ ((__aligned__));\n\n/* No special attributes by default.  */\n#ifndef __cleanup_fct_attribute\n# define __cleanup_fct_attribute\n#endif\n\n\n/* Structure to hold the cleanup handler information.  */\nstruct __pthread_cleanup_frame\n{\n  void (*__cancel_routine) (void *);\n  void *__cancel_arg;\n  int __do_it;\n  int __cancel_type;\n};\n\n#if defined __GNUC__ && defined __EXCEPTIONS\n# ifdef __cplusplus\n/* Class to handle cancellation handler invocation.  */\nclass __pthread_cleanup_class\n{\n  void (*__cancel_routine) (void *);\n  void *__cancel_arg;\n  int __do_it;\n  int __cancel_type;\n\n public:\n  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)\n    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }\n  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }\n  void __setdoit (int __newval) { __do_it = __newval; }\n  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,\n\t\t\t\t\t   &__cancel_type); }\n  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }\n};\n\n/* Install a cleanup handler: ROUTINE will be called with arguments ARG\n   when the thread is canceled or calls pthread_exit.  ROUTINE will also\n   be called with arguments ARG when the matching pthread_cleanup_pop\n   is executed with non-zero EXECUTE argument.\n\n   pthread_cleanup_push and pthread_cleanup_pop are macros and must always\n   be used in matching pairs at the same nesting level of braces.  */\n#  define pthread_cleanup_push(routine, arg) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    __pthread_cleanup_class __clframe (routine, arg)\n\n/* Remove a cleanup handler installed by the matching pthread_cleanup_push.\n   If EXECUTE is non-zero, the handler function is called. */\n#  define pthread_cleanup_pop(execute) \\\n    __clframe.__setdoit (execute);\t\t\t\t\t      \\\n  } while (0)\n\n#  ifdef __USE_GNU\n/* Install a cleanup handler as pthread_cleanup_push does, but also\n   saves the current cancellation type and sets it to deferred\n   cancellation.  */\n#   define pthread_cleanup_push_defer_np(routine, arg) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    __pthread_cleanup_class __clframe (routine, arg);\t\t\t      \\\n    __clframe.__defer ()\n\n/* Remove a cleanup handler as pthread_cleanup_pop does, but also\n   restores the cancellation type that was in effect when the matching\n   pthread_cleanup_push_defer was called.  */\n#   define pthread_cleanup_pop_restore_np(execute) \\\n    __clframe.__restore ();\t\t\t\t\t\t      \\\n    __clframe.__setdoit (execute);\t\t\t\t\t      \\\n  } while (0)\n#  endif\n# else\n/* Function called to call the cleanup handler.  As an extern inline\n   function the compiler is free to decide inlining the change when\n   needed or fall back on the copy which must exist somewhere\n   else.  */\n__extern_inline void\n__pthread_cleanup_routine (struct __pthread_cleanup_frame *__frame)\n{\n  if (__frame->__do_it)\n    __frame->__cancel_routine (__frame->__cancel_arg);\n}\n\n/* Install a cleanup handler: ROUTINE will be called with arguments ARG\n   when the thread is canceled or calls pthread_exit.  ROUTINE will also\n   be called with arguments ARG when the matching pthread_cleanup_pop\n   is executed with non-zero EXECUTE argument.\n\n   pthread_cleanup_push and pthread_cleanup_pop are macros and must always\n   be used in matching pairs at the same nesting level of braces.  */\n#  define pthread_cleanup_push(routine, arg) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    struct __pthread_cleanup_frame __clframe\t\t\t\t      \\\n      __attribute__ ((__cleanup__ (__pthread_cleanup_routine)))\t\t      \\\n      = { .__cancel_routine = (routine), .__cancel_arg = (arg),\t \t      \\\n\t  .__do_it = 1 };\n\n/* Remove a cleanup handler installed by the matching pthread_cleanup_push.\n   If EXECUTE is non-zero, the handler function is called. */\n#  define pthread_cleanup_pop(execute) \\\n    __clframe.__do_it = (execute);\t\t\t\t\t      \\\n  } while (0)\n\n#  ifdef __USE_GNU\n/* Install a cleanup handler as pthread_cleanup_push does, but also\n   saves the current cancellation type and sets it to deferred\n   cancellation.  */\n#   define pthread_cleanup_push_defer_np(routine, arg) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    struct __pthread_cleanup_frame __clframe\t\t\t\t      \\\n      __attribute__ ((__cleanup__ (__pthread_cleanup_routine)))\t\t      \\\n      = { .__cancel_routine = (routine), .__cancel_arg = (arg),\t\t      \\\n\t  .__do_it = 1 };\t\t\t\t\t\t      \\\n    (void) pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,\t\t      \\\n\t\t\t\t  &__clframe.__cancel_type)\n\n/* Remove a cleanup handler as pthread_cleanup_pop does, but also\n   restores the cancellation type that was in effect when the matching\n   pthread_cleanup_push_defer was called.  */\n#   define pthread_cleanup_pop_restore_np(execute) \\\n    (void) pthread_setcanceltype (__clframe.__cancel_type, NULL);\t      \\\n    __clframe.__do_it = (execute);\t\t\t\t\t      \\\n  } while (0)\n#  endif\n# endif\n#else\n/* Install a cleanup handler: ROUTINE will be called with arguments ARG\n   when the thread is canceled or calls pthread_exit.  ROUTINE will also\n   be called with arguments ARG when the matching pthread_cleanup_pop\n   is executed with non-zero EXECUTE argument.\n\n   pthread_cleanup_push and pthread_cleanup_pop are macros and must always\n   be used in matching pairs at the same nesting level of braces.  */\n# define pthread_cleanup_push(routine, arg) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    __pthread_unwind_buf_t __cancel_buf;\t\t\t\t      \\\n    void (*__cancel_routine) (void *) = (routine);\t\t\t      \\\n    void *__cancel_arg = (arg);\t\t\t\t\t\t      \\\n    int __not_first_call = __sigsetjmp_cancel (__cancel_buf.__cancel_jmp_buf, \\\n\t\t\t\t\t       0);\t\t\t      \\\n    if (__glibc_unlikely (__not_first_call))\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\t__cancel_routine (__cancel_arg);\t\t\t\t      \\\n\t__pthread_unwind_next (&__cancel_buf);\t\t\t\t      \\\n\t/* NOTREACHED */\t\t\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n    __pthread_register_cancel (&__cancel_buf);\t\t\t\t      \\\n    do {\nextern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)\n     __cleanup_fct_attribute;\n\n/* Remove a cleanup handler installed by the matching pthread_cleanup_push.\n   If EXECUTE is non-zero, the handler function is called. */\n# define pthread_cleanup_pop(execute) \\\n      do { } while (0);/* Empty to allow label before pthread_cleanup_pop.  */\\\n    } while (0);\t\t\t\t\t\t\t      \\\n    __pthread_unregister_cancel (&__cancel_buf);\t\t\t      \\\n    if (execute)\t\t\t\t\t\t\t      \\\n      __cancel_routine (__cancel_arg);\t\t\t\t\t      \\\n  } while (0)\nextern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)\n  __cleanup_fct_attribute;\n\n# ifdef __USE_GNU\n/* Install a cleanup handler as pthread_cleanup_push does, but also\n   saves the current cancellation type and sets it to deferred\n   cancellation.  */\n#  define pthread_cleanup_push_defer_np(routine, arg) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    __pthread_unwind_buf_t __cancel_buf;\t\t\t\t      \\\n    void (*__cancel_routine) (void *) = (routine);\t\t\t      \\\n    void *__cancel_arg = (arg);\t\t\t\t\t\t      \\\n    int __not_first_call = __sigsetjmp_cancel (__cancel_buf.__cancel_jmp_buf, \\\n\t\t\t\t\t       0);\t\t\t      \\\n    if (__glibc_unlikely (__not_first_call))\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\t__cancel_routine (__cancel_arg);\t\t\t\t      \\\n\t__pthread_unwind_next (&__cancel_buf);\t\t\t\t      \\\n\t/* NOTREACHED */\t\t\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n    __pthread_register_cancel_defer (&__cancel_buf);\t\t\t      \\\n    do {\nextern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)\n     __cleanup_fct_attribute;\n\n/* Remove a cleanup handler as pthread_cleanup_pop does, but also\n   restores the cancellation type that was in effect when the matching\n   pthread_cleanup_push_defer was called.  */\n#  define pthread_cleanup_pop_restore_np(execute) \\\n      do { } while (0);/* Empty to allow label before pthread_cleanup_pop.  */\\\n    } while (0);\t\t\t\t\t\t\t      \\\n    __pthread_unregister_cancel_restore (&__cancel_buf);\t\t      \\\n    if (execute)\t\t\t\t\t\t\t      \\\n      __cancel_routine (__cancel_arg);\t\t\t\t\t      \\\n  } while (0)\nextern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)\n  __cleanup_fct_attribute;\n# endif\n\n/* Internal interface to initiate cleanup.  */\nextern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)\n     __cleanup_fct_attribute __attribute__ ((__noreturn__))\n# ifndef SHARED\n     __attribute__ ((__weak__))\n# endif\n     ;\n#endif\n\n/* Function used in the macros.  Calling __sigsetjmp, with its first\n   argument declared as an array, results in a -Wstringop-overflow\n   warning from GCC 11 because struct pthread_unwind_buf is smaller\n   than jmp_buf.  The calls from the macros have __SAVEMASK set to 0,\n   so nothing beyond the common prefix is used and this warning is a\n   false positive.  Use an alias with its first argument declared to\n   use the type in the macros if possible to avoid this warning.  */\n#if __GNUC_PREREQ (11, 0)\nextern int __REDIRECT_NTHNL (__sigsetjmp_cancel,\n\t\t\t     (struct __cancel_jmp_buf_tag __env[1],\n\t\t\t      int __savemask),\n\t\t\t     __sigsetjmp) __attribute_returns_twice__;\n#else\n# define __sigsetjmp_cancel(env, savemask) \\\n  __sigsetjmp ((struct __jmp_buf_tag *) (void *) (env), (savemask))\nextern int __sigsetjmp (struct __jmp_buf_tag __env[1],\n\t\t\tint __savemask) __THROWNL;\n#endif\n\n\n/* Mutex handling.  */\n\n/* Initialize a mutex.  */\nextern int pthread_mutex_init (pthread_mutex_t *__mutex,\n\t\t\t       const pthread_mutexattr_t *__mutexattr)\n     __THROW __nonnull ((1));\n\n/* Destroy a mutex.  */\nextern int pthread_mutex_destroy (pthread_mutex_t *__mutex)\n     __THROW __nonnull ((1));\n\n/* Try locking a mutex.  */\nextern int pthread_mutex_trylock (pthread_mutex_t *__mutex)\n     __THROWNL __nonnull ((1));\n\n/* Lock a mutex.  */\nextern int pthread_mutex_lock (pthread_mutex_t *__mutex)\n     __THROWNL __nonnull ((1));\n\n#ifdef __USE_XOPEN2K\n/* Wait until lock becomes available, or specified time passes. */\n# ifndef __USE_TIME_BITS64\nextern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,\n\t\t\t\t    const struct timespec *__restrict\n\t\t\t\t    __abstime) __THROWNL __nonnull ((1, 2));\n# else\n#  ifdef __REDIRECT_NTHNL\nextern int __REDIRECT_NTHNL (pthread_mutex_timedlock,\n                             (pthread_mutex_t *__restrict __mutex,\n                              const struct timespec *__restrict __abstime),\n                             __pthread_mutex_timedlock64) __nonnull ((1, 2));\n#  else\n#   define pthread_mutex_timedlock __pthread_mutex_timedlock64\n#  endif\n# endif\n#endif\n\n#ifdef __USE_GNU\n# ifndef __USE_TIME_BITS64\nextern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,\n\t\t\t\t    clockid_t __clockid,\n\t\t\t\t    const struct timespec *__restrict\n\t\t\t\t    __abstime) __THROWNL __nonnull ((1, 3));\n# else\n#  ifdef __REDIRECT_NTHNL\nextern int __REDIRECT_NTHNL (pthread_mutex_clocklock,\n                             (pthread_mutex_t *__restrict __mutex,\n                              clockid_t __clockid,\n                              const struct timespec *__restrict __abstime),\n                             __pthread_mutex_clocklock64) __nonnull ((1, 3));\n#  else\n#   define pthread_mutex_clocklock __pthread_mutex_clocklock64\n#  endif\n# endif\n#endif\n\n/* Unlock a mutex.  */\nextern int pthread_mutex_unlock (pthread_mutex_t *__mutex)\n     __THROWNL __nonnull ((1));\n\n\n/* Get the priority ceiling of MUTEX.  */\nextern int pthread_mutex_getprioceiling (const pthread_mutex_t *\n\t\t\t\t\t __restrict __mutex,\n\t\t\t\t\t int *__restrict __prioceiling)\n     __THROW __nonnull ((1, 2));\n\n/* Set the priority ceiling of MUTEX to PRIOCEILING, return old\n   priority ceiling value in *OLD_CEILING.  */\nextern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,\n\t\t\t\t\t int __prioceiling,\n\t\t\t\t\t int *__restrict __old_ceiling)\n     __THROW __nonnull ((1, 3));\n\n\n#ifdef __USE_XOPEN2K8\n/* Declare the state protected by MUTEX as consistent.  */\nextern int pthread_mutex_consistent (pthread_mutex_t *__mutex)\n     __THROW __nonnull ((1));\n# ifdef __USE_GNU\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (pthread_mutex_consistent_np, (pthread_mutex_t *),\n\t\t\t   pthread_mutex_consistent) __nonnull ((1))\n  __attribute_deprecated_msg__ (\"\\\npthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent\");\n#  else\n#   define pthread_mutex_consistent_np pthread_mutex_consistent\n#  endif\n# endif\n#endif\n\n\n/* Functions for handling mutex attributes.  */\n\n/* Initialize mutex attribute object ATTR with default attributes\n   (kind is PTHREAD_MUTEX_TIMED_NP).  */\nextern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Destroy mutex attribute object ATTR.  */\nextern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Get the process-shared flag of the mutex attribute ATTR.  */\nextern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *\n\t\t\t\t\t __restrict __attr,\n\t\t\t\t\t int *__restrict __pshared)\n     __THROW __nonnull ((1, 2));\n\n/* Set the process-shared flag of the mutex attribute ATTR.  */\nextern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,\n\t\t\t\t\t int __pshared)\n     __THROW __nonnull ((1));\n\n#if defined __USE_UNIX98 || defined __USE_XOPEN2K8\n/* Return in *KIND the mutex kind attribute in *ATTR.  */\nextern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict\n\t\t\t\t      __attr, int *__restrict __kind)\n     __THROW __nonnull ((1, 2));\n\n/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,\n   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or\n   PTHREAD_MUTEX_DEFAULT).  */\nextern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)\n     __THROW __nonnull ((1));\n#endif\n\n/* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  */\nextern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *\n\t\t\t\t\t  __restrict __attr,\n\t\t\t\t\t  int *__restrict __protocol)\n     __THROW __nonnull ((1, 2));\n\n/* Set the mutex protocol attribute in *ATTR to PROTOCOL (either\n   PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  */\nextern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,\n\t\t\t\t\t  int __protocol)\n     __THROW __nonnull ((1));\n\n/* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  */\nextern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *\n\t\t\t\t\t     __restrict __attr,\n\t\t\t\t\t     int *__restrict __prioceiling)\n     __THROW __nonnull ((1, 2));\n\n/* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  */\nextern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,\n\t\t\t\t\t     int __prioceiling)\n     __THROW __nonnull ((1));\n\n#ifdef __USE_XOPEN2K\n/* Get the robustness flag of the mutex attribute ATTR.  */\nextern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,\n\t\t\t\t\tint *__robustness)\n     __THROW __nonnull ((1, 2));\n# ifdef __USE_GNU\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (pthread_mutexattr_getrobust_np,\n\t\t\t   (pthread_mutexattr_t *, int *),\n\t\t\t   pthread_mutexattr_getrobust) __nonnull ((1))\n  __attribute_deprecated_msg__ (\"\\\npthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust\");\n#  else\n#   define pthread_mutexattr_getrobust_np pthread_mutexattr_getrobust\n#  endif\n# endif\n\n/* Set the robustness flag of the mutex attribute ATTR.  */\nextern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,\n\t\t\t\t\tint __robustness)\n     __THROW __nonnull ((1));\n# ifdef __USE_GNU\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (pthread_mutexattr_setrobust_np,\n\t\t\t   (pthread_mutexattr_t *, int),\n\t\t\t   pthread_mutexattr_setrobust) __nonnull ((1))\n  __attribute_deprecated_msg__ (\"\\\npthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust\");\n#  else\n#   define pthread_mutexattr_setrobust_np pthread_mutexattr_setrobust\n#  endif\n# endif\n#endif\n\n#if defined __USE_UNIX98 || defined __USE_XOPEN2K\n/* Functions for handling read-write locks.  */\n\n/* Initialize read-write lock RWLOCK using attributes ATTR, or use\n   the default values if later is NULL.  */\nextern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,\n\t\t\t\tconst pthread_rwlockattr_t *__restrict\n\t\t\t\t__attr) __THROW __nonnull ((1));\n\n/* Destroy read-write lock RWLOCK.  */\nextern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)\n     __THROW __nonnull ((1));\n\n/* Acquire read lock for RWLOCK.  */\nextern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)\n     __THROWNL __nonnull ((1));\n\n/* Try to acquire read lock for RWLOCK.  */\nextern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)\n  __THROWNL __nonnull ((1));\n\n# ifdef __USE_XOPEN2K\n/* Try to acquire read lock for RWLOCK or return after specfied time.  */\n#  ifndef __USE_TIME_BITS64\nextern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,\n\t\t\t\t       const struct timespec *__restrict\n\t\t\t\t       __abstime) __THROWNL __nonnull ((1, 2));\n#  else\n#   ifdef __REDIRECT_NTHNL\nextern int __REDIRECT_NTHNL (pthread_rwlock_timedrdlock,\n                             (pthread_rwlock_t *__restrict __rwlock,\n                              const struct timespec *__restrict __abstime),\n                             __pthread_rwlock_timedrdlock64)\n    __nonnull ((1, 2));\n#   else\n#    define pthread_rwlock_timedrdlock __pthread_rwlock_timedrdlock64\n#   endif\n#  endif\n# endif\n\n# ifdef __USE_GNU\n#  ifndef __USE_TIME_BITS64\nextern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,\n\t\t\t\t       clockid_t __clockid,\n\t\t\t\t       const struct timespec *__restrict\n\t\t\t\t       __abstime) __THROWNL __nonnull ((1, 3));\n#  else\n#   ifdef __REDIRECT_NTHNL\nextern int __REDIRECT_NTHNL (pthread_rwlock_clockrdlock,\n                             (pthread_rwlock_t *__restrict __rwlock,\n                              clockid_t __clockid,\n                              const struct timespec *__restrict __abstime),\n                             __pthread_rwlock_clockrdlock64)\n    __nonnull ((1, 3));\n#   else\n#    define pthread_rwlock_clockrdlock __pthread_rwlock_clockrdlock64\n#   endif\n#  endif\n# endif\n\n/* Acquire write lock for RWLOCK.  */\nextern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)\n     __THROWNL __nonnull ((1));\n\n/* Try to acquire write lock for RWLOCK.  */\nextern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)\n     __THROWNL __nonnull ((1));\n\n# ifdef __USE_XOPEN2K\n/* Try to acquire write lock for RWLOCK or return after specfied time.  */\n#  ifndef __USE_TIME_BITS64\nextern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,\n\t\t\t\t       const struct timespec *__restrict\n\t\t\t\t       __abstime) __THROWNL __nonnull ((1, 2));\n#  else\n#   ifdef __REDIRECT_NTHNL\nextern int __REDIRECT_NTHNL (pthread_rwlock_timedwrlock,\n                             (pthread_rwlock_t *__restrict __rwlock,\n                              const struct timespec *__restrict __abstime),\n                             __pthread_rwlock_timedwrlock64)\n    __nonnull ((1, 2));\n#   else\n#    define pthread_rwlock_timedwrlock __pthread_rwlock_timedwrlock64\n#   endif\n#  endif\n# endif\n\n# ifdef __USE_GNU\n#  ifndef __USE_TIME_BITS64\nextern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,\n\t\t\t\t       clockid_t __clockid,\n\t\t\t\t       const struct timespec *__restrict\n\t\t\t\t       __abstime) __THROWNL __nonnull ((1, 3));\n\n#  else\n#   ifdef __REDIRECT_NTHNL\nextern int __REDIRECT_NTHNL (pthread_rwlock_clockwrlock,\n                             (pthread_rwlock_t *__restrict __rwlock,\n                              clockid_t __clockid,\n                              const struct timespec *__restrict __abstime),\n                             __pthread_rwlock_clockwrlock64)\n    __nonnull ((1, 3));\n#   else\n#    define pthread_rwlock_clockwrlock __pthread_rwlock_clockwrlock64\n#   endif\n#  endif\n# endif\n\n/* Unlock RWLOCK.  */\nextern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)\n     __THROWNL __nonnull ((1));\n\n\n/* Functions for handling read-write lock attributes.  */\n\n/* Initialize attribute object ATTR with default values.  */\nextern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Destroy attribute object ATTR.  */\nextern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Return current setting of process-shared attribute of ATTR in PSHARED.  */\nextern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *\n\t\t\t\t\t  __restrict __attr,\n\t\t\t\t\t  int *__restrict __pshared)\n     __THROW __nonnull ((1, 2));\n\n/* Set process-shared attribute of ATTR to PSHARED.  */\nextern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,\n\t\t\t\t\t  int __pshared)\n     __THROW __nonnull ((1));\n\n/* Return current setting of reader/writer preference.  */\nextern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *\n\t\t\t\t\t  __restrict __attr,\n\t\t\t\t\t  int *__restrict __pref)\n     __THROW __nonnull ((1, 2));\n\n/* Set reader/write preference.  */\nextern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,\n\t\t\t\t\t  int __pref) __THROW __nonnull ((1));\n#endif\n\n\n/* Functions for handling conditional variables.  */\n\n/* Initialize condition variable COND using attributes ATTR, or use\n   the default values if later is NULL.  */\nextern int pthread_cond_init (pthread_cond_t *__restrict __cond,\n\t\t\t      const pthread_condattr_t *__restrict __cond_attr)\n     __THROW __nonnull ((1));\n\n/* Destroy condition variable COND.  */\nextern int pthread_cond_destroy (pthread_cond_t *__cond)\n     __THROW __nonnull ((1));\n\n/* Wake up one thread waiting for condition variable COND.  */\nextern int pthread_cond_signal (pthread_cond_t *__cond)\n     __THROWNL __nonnull ((1));\n\n/* Wake up all threads waiting for condition variables COND.  */\nextern int pthread_cond_broadcast (pthread_cond_t *__cond)\n     __THROWNL __nonnull ((1));\n\n/* Wait for condition variable COND to be signaled or broadcast.\n   MUTEX is assumed to be locked before.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int pthread_cond_wait (pthread_cond_t *__restrict __cond,\n\t\t\t      pthread_mutex_t *__restrict __mutex)\n     __nonnull ((1, 2));\n\n/* Wait for condition variable COND to be signaled or broadcast until\n   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an\n   absolute time specification; zero is the beginning of the epoch\n   (00:00:00 GMT, January 1, 1970).\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n# ifndef __USE_TIME_BITS64\nextern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,\n\t\t\t\t   pthread_mutex_t *__restrict __mutex,\n\t\t\t\t   const struct timespec *__restrict __abstime)\n     __nonnull ((1, 2, 3));\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (pthread_cond_timedwait,\n                       (pthread_cond_t *__restrict __cond,\n                        pthread_mutex_t *__restrict __mutex,\n                        const struct timespec *__restrict __abstime),\n                       __pthread_cond_timedwait64)\n     __nonnull ((1, 2, 3));\n#  else\n#   define pthread_cond_timedwait __pthread_cond_timedwait64\n#  endif\n# endif\n\n# ifdef __USE_GNU\n/* Wait for condition variable COND to be signaled or broadcast until\n   ABSTIME measured by the specified clock. MUTEX is assumed to be\n   locked before. CLOCK is the clock to use. ABSTIME is an absolute\n   time specification against CLOCK's epoch.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW. */\n#  ifndef __USE_TIME_BITS64\nextern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,\n\t\t\t\t   pthread_mutex_t *__restrict __mutex,\n\t\t\t\t   __clockid_t __clock_id,\n\t\t\t\t   const struct timespec *__restrict __abstime)\n     __nonnull ((1, 2, 4));\n#  else\n#   ifdef __REDIRECT\nextern int __REDIRECT (pthread_cond_clockwait,\n                       (pthread_cond_t *__restrict __cond,\n                        pthread_mutex_t *__restrict __mutex,\n                        __clockid_t __clock_id,\n                        const struct timespec *__restrict __abstime),\n                       __pthread_cond_clockwait64)\n     __nonnull ((1, 2, 4));\n#   else\n#    define pthread_cond_clockwait __pthread_cond_clockwait64\n#   endif\n#  endif\n# endif\n\n/* Functions for handling condition variable attributes.  */\n\n/* Initialize condition variable attribute ATTR.  */\nextern int pthread_condattr_init (pthread_condattr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Destroy condition variable attribute ATTR.  */\nextern int pthread_condattr_destroy (pthread_condattr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Get the process-shared flag of the condition variable attribute ATTR.  */\nextern int pthread_condattr_getpshared (const pthread_condattr_t *\n\t\t\t\t\t__restrict __attr,\n\t\t\t\t\tint *__restrict __pshared)\n     __THROW __nonnull ((1, 2));\n\n/* Set the process-shared flag of the condition variable attribute ATTR.  */\nextern int pthread_condattr_setpshared (pthread_condattr_t *__attr,\n\t\t\t\t\tint __pshared) __THROW __nonnull ((1));\n\n#ifdef __USE_XOPEN2K\n/* Get the clock selected for the condition variable attribute ATTR.  */\nextern int pthread_condattr_getclock (const pthread_condattr_t *\n\t\t\t\t      __restrict __attr,\n\t\t\t\t      __clockid_t *__restrict __clock_id)\n     __THROW __nonnull ((1, 2));\n\n/* Set the clock selected for the condition variable attribute ATTR.  */\nextern int pthread_condattr_setclock (pthread_condattr_t *__attr,\n\t\t\t\t      __clockid_t __clock_id)\n     __THROW __nonnull ((1));\n#endif\n\n\n#ifdef __USE_XOPEN2K\n/* Functions to handle spinlocks.  */\n\n/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can\n   be shared between different processes.  */\nextern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)\n     __THROW __nonnull ((1));\n\n/* Destroy the spinlock LOCK.  */\nextern int pthread_spin_destroy (pthread_spinlock_t *__lock)\n     __THROW __nonnull ((1));\n\n/* Wait until spinlock LOCK is retrieved.  */\nextern int pthread_spin_lock (pthread_spinlock_t *__lock)\n     __THROWNL __nonnull ((1));\n\n/* Try to lock spinlock LOCK.  */\nextern int pthread_spin_trylock (pthread_spinlock_t *__lock)\n     __THROWNL __nonnull ((1));\n\n/* Release spinlock LOCK.  */\nextern int pthread_spin_unlock (pthread_spinlock_t *__lock)\n     __THROWNL __nonnull ((1));\n\n\n/* Functions to handle barriers.  */\n\n/* Initialize BARRIER with the attributes in ATTR.  The barrier is\n   opened when COUNT waiters arrived.  */\nextern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,\n\t\t\t\t const pthread_barrierattr_t *__restrict\n\t\t\t\t __attr, unsigned int __count)\n     __THROW __nonnull ((1));\n\n/* Destroy a previously dynamically initialized barrier BARRIER.  */\nextern int pthread_barrier_destroy (pthread_barrier_t *__barrier)\n     __THROW __nonnull ((1));\n\n/* Wait on barrier BARRIER.  */\nextern int pthread_barrier_wait (pthread_barrier_t *__barrier)\n     __THROWNL __nonnull ((1));\n\n\n/* Initialize barrier attribute ATTR.  */\nextern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Destroy previously dynamically initialized barrier attribute ATTR.  */\nextern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)\n     __THROW __nonnull ((1));\n\n/* Get the process-shared flag of the barrier attribute ATTR.  */\nextern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *\n\t\t\t\t\t   __restrict __attr,\n\t\t\t\t\t   int *__restrict __pshared)\n     __THROW __nonnull ((1, 2));\n\n/* Set the process-shared flag of the barrier attribute ATTR.  */\nextern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,\n\t\t\t\t\t   int __pshared)\n     __THROW __nonnull ((1));\n#endif\n\n\n/* Functions for handling thread-specific data.  */\n\n/* Create a key value identifying a location in the thread-specific\n   data area.  Each thread maintains a distinct thread-specific data\n   area.  DESTR_FUNCTION, if non-NULL, is called with the value\n   associated to that key when the key is destroyed.\n   DESTR_FUNCTION is not called if the value associated is NULL when\n   the key is destroyed.  */\nextern int pthread_key_create (pthread_key_t *__key,\n\t\t\t       void (*__destr_function) (void *))\n     __THROW __nonnull ((1));\n\n/* Destroy KEY.  */\nextern int pthread_key_delete (pthread_key_t __key) __THROW;\n\n/* Return current value of the thread-specific data slot identified by KEY.  */\nextern void *pthread_getspecific (pthread_key_t __key) __THROW;\n\n/* Store POINTER in the thread-specific data slot identified by KEY. */\nextern int pthread_setspecific (pthread_key_t __key,\n\t\t\t\tconst void *__pointer)\n  __THROW __attr_access_none (2);\n\n\n#ifdef __USE_XOPEN2K\n/* Get ID of CPU-time clock for thread THREAD_ID.  */\nextern int pthread_getcpuclockid (pthread_t __thread_id,\n\t\t\t\t  __clockid_t *__clock_id)\n     __THROW __nonnull ((2));\n#endif\n\n\n/* Install handlers to be called when a new process is created with FORK.\n   The PREPARE handler is called in the parent process just before performing\n   FORK. The PARENT handler is called in the parent process just after FORK.\n   The CHILD handler is called in the child process.  Each of the three\n   handlers can be NULL, meaning that no handler needs to be called at that\n   point.\n   PTHREAD_ATFORK can be called several times, in which case the PREPARE\n   handlers are called in LIFO order (last added with PTHREAD_ATFORK,\n   first called before FORK), and the PARENT and CHILD handlers are called\n   in FIFO (first added, first called).  */\n\nextern int pthread_atfork (void (*__prepare) (void),\n\t\t\t   void (*__parent) (void),\n\t\t\t   void (*__child) (void)) __THROW;\n\n\n#ifdef __USE_EXTERN_INLINES\n/* Optimizations.  */\n__extern_inline int\n__NTH (pthread_equal (pthread_t __thread1, pthread_t __thread2))\n{\n  return __thread1 == __thread2;\n}\n#endif\n\n__END_DECLS\n\n#endif\t/* pthread.h */\n"}],"crc32":1304286904,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]