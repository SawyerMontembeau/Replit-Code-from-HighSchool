[{"ops":[{"insert":"// Support for atomic operations -*- C++ -*-\n\n// Copyright (C) 2004-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file ext/atomicity.h\n *  This file is a GNU extension to the Standard C++ Library.\n */\n\n#ifndef _GLIBCXX_ATOMICITY_H\n#define _GLIBCXX_ATOMICITY_H\t1\n\n#pragma GCC system_header\n\n#include <bits/c++config.h>\n#include <bits/gthr.h>\n#include <bits/atomic_word.h>\n#if __has_include(<sys/single_threaded.h>)\n# include <sys/single_threaded.h>\n#endif\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  __attribute__((__always_inline__))\n  inline bool\n  __is_single_threaded() _GLIBCXX_NOTHROW\n  {\n#ifndef __GTHREADS\n    return true;\n#elif __has_include(<sys/single_threaded.h>)\n    return ::__libc_single_threaded;\n#else\n    return !__gthread_active_p();\n#endif\n  }\n\n  // Functions for portable atomic access.\n  // To abstract locking primitives across all thread policies, use:\n  // __exchange_and_add_dispatch\n  // __atomic_add_dispatch\n#ifdef _GLIBCXX_ATOMIC_BUILTINS\n  inline _Atomic_word\n  __attribute__((__always_inline__))\n  __exchange_and_add(volatile _Atomic_word* __mem, int __val)\n  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }\n\n  inline void\n  __attribute__((__always_inline__))\n  __atomic_add(volatile _Atomic_word* __mem, int __val)\n  { __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }\n#else\n  _Atomic_word\n  __exchange_and_add(volatile _Atomic_word*, int) _GLIBCXX_NOTHROW;\n\n  void\n  __atomic_add(volatile _Atomic_word*, int) _GLIBCXX_NOTHROW;\n#endif\n\n  inline _Atomic_word\n  __attribute__((__always_inline__))\n  __exchange_and_add_single(_Atomic_word* __mem, int __val)\n  {\n    _Atomic_word __result = *__mem;\n    *__mem += __val;\n    return __result;\n  }\n\n  inline void\n  __attribute__((__always_inline__))\n  __atomic_add_single(_Atomic_word* __mem, int __val)\n  { *__mem += __val; }\n\n  inline _Atomic_word\n  __attribute__ ((__always_inline__))\n  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)\n  {\n    if (__is_single_threaded())\n      return __exchange_and_add_single(__mem, __val);\n    else\n      return __exchange_and_add(__mem, __val);\n  }\n\n  inline void\n  __attribute__ ((__always_inline__))\n  __atomic_add_dispatch(_Atomic_word* __mem, int __val)\n  {\n    if (__is_single_threaded())\n      __atomic_add_single(__mem, __val);\n    else\n      __atomic_add(__mem, __val);\n  }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n// Even if the CPU doesn't need a memory barrier, we need to ensure\n// that the compiler doesn't reorder memory accesses across the\n// barriers.\n#ifndef _GLIBCXX_READ_MEM_BARRIER\n#define _GLIBCXX_READ_MEM_BARRIER __atomic_thread_fence (__ATOMIC_ACQUIRE)\n#endif\n#ifndef _GLIBCXX_WRITE_MEM_BARRIER\n#define _GLIBCXX_WRITE_MEM_BARRIER __atomic_thread_fence (__ATOMIC_RELEASE)\n#endif\n\n#endif \n"}],"crc32":2525067786,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]