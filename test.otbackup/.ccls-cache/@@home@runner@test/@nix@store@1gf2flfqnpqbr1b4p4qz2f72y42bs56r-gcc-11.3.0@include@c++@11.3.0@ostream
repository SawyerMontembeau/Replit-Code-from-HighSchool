[{"ops":[{"insert":"// Output streams -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file include/ostream\n *  This is a Standard C++ Library header.\n */\n\n//\n// ISO C++ 14882: 27.6.2  Output streams\n//\n\n#ifndef _GLIBCXX_OSTREAM\n#define _GLIBCXX_OSTREAM 1\n\n#pragma GCC system_header\n\n#include <ios>\n#include <bits/ostream_insert.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @brief  Template class basic_ostream.\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *\n   *  This is the base class for all output streams.  It provides text\n   *  formatting of all builtin types, and communicates with any class\n   *  derived from basic_streambuf to do the actual output.\n  */\n  template<typename _CharT, typename _Traits>\n    class basic_ostream : virtual public basic_ios<_CharT, _Traits>\n    {\n    public:\n      // Types (inherited from basic_ios):\n      typedef _CharT\t\t\t \t\tchar_type;\n      typedef typename _Traits::int_type \t\tint_type;\n      typedef typename _Traits::pos_type \t\tpos_type;\n      typedef typename _Traits::off_type \t\toff_type;\n      typedef _Traits\t\t\t \t\ttraits_type;\n\n      // Non-standard Types:\n      typedef basic_streambuf<_CharT, _Traits> \t\t__streambuf_type;\n      typedef basic_ios<_CharT, _Traits>\t\t__ios_type;\n      typedef basic_ostream<_CharT, _Traits>\t\t__ostream_type;\n      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >\n      \t\t\t\t\t\t\t__num_put_type;\n      typedef ctype<_CharT>\t      \t\t\t__ctype_type;\n\n      /**\n       *  @brief  Base constructor.\n       *\n       *  This ctor is almost never called by the user directly, rather from\n       *  derived classes' initialization lists, which pass a pointer to\n       *  their own stream buffer.\n      */\n      explicit\n      basic_ostream(__streambuf_type* __sb)\n      { this->init(__sb); }\n\n      /**\n       *  @brief  Base destructor.\n       *\n       *  This does very little apart from providing a virtual base dtor.\n      */\n      virtual\n      ~basic_ostream() { }\n\n      /// Safe prefix/suffix operations.\n      class sentry;\n      friend class sentry;\n\n      ///@{\n      /**\n       *  @brief  Interface for manipulators.\n       *\n       *  Manipulators such as @c std::endl and @c std::hex use these\n       *  functions in constructs like \"std::cout << std::endl\".  For more\n       *  information, see the iomanip header.\n      */\n      __ostream_type&\n      operator<<(__ostream_type& (*__pf)(__ostream_type&))\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// DR 60. What is a formatted input function?\n\t// The inserters for manipulators are *not* formatted output functions.\n\treturn __pf(*this);\n      }\n\n      __ostream_type&\n      operator<<(__ios_type& (*__pf)(__ios_type&))\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// DR 60. What is a formatted input function?\n\t// The inserters for manipulators are *not* formatted output functions.\n\t__pf(*this);\n\treturn *this;\n      }\n\n      __ostream_type&\n      operator<<(ios_base& (*__pf) (ios_base&))\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// DR 60. What is a formatted input function?\n\t// The inserters for manipulators are *not* formatted output functions.\n\t__pf(*this);\n\treturn *this;\n      }\n      ///@}\n\n      ///@{\n      /**\n       *  @name Inserters\n       *\n       *  All the @c operator<< functions (aka <em>formatted output\n       *  functions</em>) have some common behavior.  Each starts by\n       *  constructing a temporary object of type std::basic_ostream::sentry.\n       *  This can have several effects, concluding with the setting of a\n       *  status flag; see the sentry documentation for more.\n       *\n       *  If the sentry status is good, the function tries to generate\n       *  whatever data is appropriate for the type of the argument.\n       *\n       *  If an exception is thrown during insertion, ios_base::badbit\n       *  will be turned on in the stream's error state without causing an\n       *  ios_base::failure to be thrown.  The original exception will then\n       *  be rethrown.\n      */\n\n      ///@{\n      /**\n       *  @brief Integer arithmetic inserters\n       *  @param  __n A variable of builtin integral type.\n       *  @return  @c *this if successful\n       *\n       *  These functions use the stream's current locale (specifically, the\n       *  @c num_get facet) to perform numeric formatting.\n      */\n      __ostream_type&\n      operator<<(long __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      operator<<(unsigned long __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      operator<<(bool __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      operator<<(short __n);\n\n      __ostream_type&\n      operator<<(unsigned short __n)\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 117. basic_ostream uses nonexistent num_put member functions.\n\treturn _M_insert(static_cast<unsigned long>(__n));\n      }\n\n      __ostream_type&\n      operator<<(int __n);\n\n      __ostream_type&\n      operator<<(unsigned int __n)\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 117. basic_ostream uses nonexistent num_put member functions.\n\treturn _M_insert(static_cast<unsigned long>(__n));\n      }\n\n#ifdef _GLIBCXX_USE_LONG_LONG\n      __ostream_type&\n      operator<<(long long __n)\n      { return _M_insert(__n); }\n\n      __ostream_type&\n      operator<<(unsigned long long __n)\n      { return _M_insert(__n); }\n#endif\n      ///@}\n\n      ///@{\n      /**\n       *  @brief  Floating point arithmetic inserters\n       *  @param  __f A variable of builtin floating point type.\n       *  @return  @c *this if successful\n       *\n       *  These functions use the stream's current locale (specifically, the\n       *  @c num_get facet) to perform numeric formatting.\n      */\n      __ostream_type&\n      operator<<(double __f)\n      { return _M_insert(__f); }\n\n      __ostream_type&\n      operator<<(float __f)\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 117. basic_ostream uses nonexistent num_put member functions.\n\treturn _M_insert(static_cast<double>(__f));\n      }\n\n      __ostream_type&\n      operator<<(long double __f)\n      { return _M_insert(__f); }\n      ///@}\n\n      /**\n       *  @brief  Pointer arithmetic inserters\n       *  @param  __p A variable of pointer type.\n       *  @return  @c *this if successful\n       *\n       *  These functions use the stream's current locale (specifically, the\n       *  @c num_get facet) to perform numeric formatting.\n      */\n      __ostream_type&\n      operator<<(const void* __p)\n      { return _M_insert(__p); }\n\n#if __cplusplus >= 201703L\n      __ostream_type&\n      operator<<(nullptr_t)\n      { return *this << \"nullptr\"; }\n#endif\n\n#if __cplusplus > 202002L\n      __attribute__((__always_inline__))\n      __ostream_type&\n      operator<<(const volatile void* __p)\n      { return _M_insert(const_cast<const void*>(__p)); }\n#endif\n\n      /**\n       *  @brief  Extracting from another streambuf.\n       *  @param  __sb  A pointer to a streambuf\n       *\n       *  This function behaves like one of the basic arithmetic extractors,\n       *  in that it also constructs a sentry object and has the same error\n       *  handling behavior.\n       *\n       *  If @p __sb is NULL, the stream will set failbit in its error state.\n       *\n       *  Characters are extracted from @p __sb and inserted into @c *this\n       *  until one of the following occurs:\n       *\n       *  - the input stream reaches end-of-file,\n       *  - insertion into the output sequence fails (in this case, the\n       *    character that would have been inserted is not extracted), or\n       *  - an exception occurs while getting a character from @p __sb, which\n       *    sets failbit in the error state\n       *\n       *  If the function inserts no characters, failbit is set.\n      */\n      __ostream_type&\n      operator<<(__streambuf_type* __sb);\n      ///@}\n\n      ///@{\n      /**\n       *  @name Unformatted Output Functions\n       *\n       *  All the unformatted output functions have some common behavior.\n       *  Each starts by constructing a temporary object of type\n       *  std::basic_ostream::sentry.  This has several effects, concluding\n       *  with the setting of a status flag; see the sentry documentation\n       *  for more.\n       *\n       *  If the sentry status is good, the function tries to generate\n       *  whatever data is appropriate for the type of the argument.\n       *\n       *  If an exception is thrown during insertion, ios_base::badbit\n       *  will be turned on in the stream's error state.  If badbit is on in\n       *  the stream's exceptions mask, the exception will be rethrown\n       *  without completing its actions.\n      */\n\n      /**\n       *  @brief  Simple insertion.\n       *  @param  __c  The character to insert.\n       *  @return  *this\n       *\n       *  Tries to insert @p __c.\n       *\n       *  @note  This function is not overloaded on signed char and\n       *         unsigned char.\n      */\n      __ostream_type&\n      put(char_type __c);\n\n      /**\n       *  @brief  Core write functionality, without sentry.\n       *  @param  __s  The array to insert.\n       *  @param  __n  Maximum number of characters to insert.\n      */\n      void\n      _M_write(const char_type* __s, streamsize __n)\n      {\n\tconst streamsize __put = this->rdbuf()->sputn(__s, __n);\n\tif (__put != __n)\n\t  this->setstate(ios_base::badbit);\n      }\n\n      /**\n       *  @brief  Character string insertion.\n       *  @param  __s  The array to insert.\n       *  @param  __n  Maximum number of characters to insert.\n       *  @return  *this\n       *\n       *  Characters are copied from @p __s and inserted into the stream until\n       *  one of the following happens:\n       *\n       *  - @p __n characters are inserted\n       *  - inserting into the output sequence fails (in this case, badbit\n       *    will be set in the stream's error state)\n       *\n       *  @note  This function is not overloaded on signed char and\n       *         unsigned char.\n      */\n      __ostream_type&\n      write(const char_type* __s, streamsize __n);\n      ///@}\n\n      /**\n       *  @brief  Synchronizing the stream buffer.\n       *  @return  *this\n       *\n       *  If @c rdbuf() is a null pointer, changes nothing.\n       *\n       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,\n       *  sets badbit.\n      */\n      __ostream_type&\n      flush();\n\n      /**\n       *  @brief  Getting the current write position.\n       *  @return  A file position object.\n       *\n       *  If @c fail() is not false, returns @c pos_type(-1) to indicate\n       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,out).\n      */\n      pos_type\n      tellp();\n\n      /**\n       *  @brief  Changing the current write position.\n       *  @param  __pos  A file position object.\n       *  @return  *this\n       *\n       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If\n       *  that function fails, sets failbit.\n      */\n      __ostream_type&\n      seekp(pos_type);\n\n      /**\n       *  @brief  Changing the current write position.\n       *  @param  __off  A file offset object.\n       *  @param  __dir  The direction in which to seek.\n       *  @return  *this\n       *\n       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).\n       *  If that function fails, sets failbit.\n      */\n       __ostream_type&\n      seekp(off_type, ios_base::seekdir);\n\n    protected:\n      basic_ostream()\n      { this->init(0); }\n\n#if __cplusplus >= 201103L\n      // Non-standard constructor that does not call init()\n      basic_ostream(basic_iostream<_CharT, _Traits>&) { }\n\n      basic_ostream(const basic_ostream&) = delete;\n\n      basic_ostream(basic_ostream&& __rhs)\n      : __ios_type()\n      { __ios_type::move(__rhs); }\n\n      // 27.7.3.3 Assign/swap\n\n      basic_ostream& operator=(const basic_ostream&) = delete;\n\n      basic_ostream&\n      operator=(basic_ostream&& __rhs)\n      {\n\tswap(__rhs);\n\treturn *this;\n      }\n\n      void\n      swap(basic_ostream& __rhs)\n      { __ios_type::swap(__rhs); }\n#endif\n\n      template<typename _ValueT>\n\t__ostream_type&\n\t_M_insert(_ValueT __v);\n    };\n\n  /**\n   *  @brief  Performs setup work for output streams.\n   *\n   *  Objects of this class are created before all of the standard\n   *  inserters are run.  It is responsible for <em>exception-safe prefix and\n   *  suffix operations</em>.\n  */\n  template <typename _CharT, typename _Traits>\n    class basic_ostream<_CharT, _Traits>::sentry\n    {\n      // Data Members.\n      bool \t\t\t\t_M_ok;\n      basic_ostream<_CharT, _Traits>& \t_M_os;\n\n    public:\n      /**\n       *  @brief  The constructor performs preparatory work.\n       *  @param  __os  The output stream to guard.\n       *\n       *  If the stream state is good (@a __os.good() is true), then if the\n       *  stream is tied to another output stream, @c is.tie()->flush()\n       *  is called to synchronize the output sequences.\n       *\n       *  If the stream state is still good, then the sentry state becomes\n       *  true (@a okay).\n      */\n      explicit\n      sentry(basic_ostream<_CharT, _Traits>& __os);\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n      /**\n       *  @brief  Possibly flushes the stream.\n       *\n       *  If @c ios_base::unitbuf is set in @c os.flags(), and\n       *  @c std::uncaught_exception() is true, the sentry destructor calls\n       *  @c flush() on the output stream.\n      */\n      ~sentry()\n      {\n\t// XXX MT\n\tif (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())\n\t  {\n\t    // Can't call flush directly or else will get into recursive lock.\n\t    if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)\n\t      _M_os.setstate(ios_base::badbit);\n\t  }\n      }\n#pragma GCC diagnostic pop\n\n      /**\n       *  @brief  Quick status checking.\n       *  @return  The sentry state.\n       *\n       *  For ease of use, sentries may be converted to booleans.  The\n       *  return value is that of the sentry state (true == okay).\n      */\n#if __cplusplus >= 201103L\n      explicit\n#endif\n      operator bool() const\n      { return _M_ok; }\n    };\n\n  ///@{\n  /**\n   *  @brief  Character inserters\n   *  @param  __out  An output stream.\n   *  @param  __c  A character.\n   *  @return  out\n   *\n   *  Behaves like one of the formatted arithmetic inserters described in\n   *  std::basic_ostream.  After constructing a sentry object with good\n   *  status, this function inserts a single character and any required\n   *  padding (as determined by [22.2.2.2.2]).  @c __out.width(0) is then\n   *  called.\n   *\n   *  If @p __c is of type @c char and the character type of the stream is not\n   *  @c char, the character is widened before insertion.\n  */\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)\n    { return __ostream_insert(__out, &__c, 1); }\n\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)\n    { return (__out << __out.widen(__c)); }\n\n  // Specialization\n  template<typename _Traits>\n    inline basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, char __c)\n    { return __ostream_insert(__out, &__c, 1); }\n\n  // Signed and unsigned\n  template<typename _Traits>\n    inline basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)\n    { return (__out << static_cast<char>(__c)); }\n\n  template<typename _Traits>\n    inline basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)\n    { return (__out << static_cast<char>(__c)); }\n\n#if __cplusplus > 201703L\n  // The following deleted overloads prevent formatting character values as\n  // numeric values.\n\n  template<typename _Traits>\n    basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>&, wchar_t) = delete;\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template<typename _Traits>\n    basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>&, char8_t) = delete;\n#endif\n\n  template<typename _Traits>\n    basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>&, char16_t) = delete;\n\n  template<typename _Traits>\n    basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>&, char32_t) = delete;\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template<typename _Traits>\n    basic_ostream<wchar_t, _Traits>&\n    operator<<(basic_ostream<wchar_t, _Traits>&, char8_t) = delete;\n#endif // _GLIBCXX_USE_CHAR8_T\n\n  template<typename _Traits>\n    basic_ostream<wchar_t, _Traits>&\n    operator<<(basic_ostream<wchar_t, _Traits>&, char16_t) = delete;\n\n  template<typename _Traits>\n    basic_ostream<wchar_t, _Traits>&\n    operator<<(basic_ostream<wchar_t, _Traits>&, char32_t) = delete;\n#endif // _GLIBCXX_USE_WCHAR_T\n#endif // C++20\n  ///@}\n\n  ///@{\n  /**\n   *  @brief  String inserters\n   *  @param  __out  An output stream.\n   *  @param  __s  A character string.\n   *  @return  out\n   *  @pre  @p __s must be a non-NULL pointer\n   *\n   *  Behaves like one of the formatted arithmetic inserters described in\n   *  std::basic_ostream.  After constructing a sentry object with good\n   *  status, this function inserts @c traits::length(__s) characters starting\n   *  at @p __s, widened if necessary, followed by any required padding (as\n   *  determined by [22.2.2.2.2]).  @c __out.width(0) is then called.\n  */\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)\n    {\n      if (!__s)\n\t__out.setstate(ios_base::badbit);\n      else\n\t__ostream_insert(__out, __s,\n\t\t\t static_cast<streamsize>(_Traits::length(__s)));\n      return __out;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_ostream<_CharT, _Traits> &\n    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);\n\n  // Partial specializations\n  template<typename _Traits>\n    inline basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)\n    {\n      if (!__s)\n\t__out.setstate(ios_base::badbit);\n      else\n\t__ostream_insert(__out, __s,\n\t\t\t static_cast<streamsize>(_Traits::length(__s)));\n      return __out;\n    }\n\n  // Signed and unsigned\n  template<typename _Traits>\n    inline basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)\n    { return (__out << reinterpret_cast<const char*>(__s)); }\n\n  template<typename _Traits>\n    inline basic_ostream<char, _Traits> &\n    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)\n    { return (__out << reinterpret_cast<const char*>(__s)); }\n\n#if __cplusplus > 201703L\n   // The following deleted overloads prevent formatting strings as\n   // pointer values.\n\n  template<typename _Traits>\n    basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>&, const wchar_t*) = delete;\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template<typename _Traits>\n    basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>&, const char8_t*) = delete;\n#endif // _GLIBCXX_USE_CHAR8_T\n\n  template<typename _Traits>\n    basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>&, const char16_t*) = delete;\n\n  template<typename _Traits>\n    basic_ostream<char, _Traits>&\n    operator<<(basic_ostream<char, _Traits>&, const char32_t*) = delete;\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template<typename _Traits>\n    basic_ostream<wchar_t, _Traits>&\n    operator<<(basic_ostream<wchar_t, _Traits>&, const char8_t*) = delete;\n#endif\n\n  template<typename _Traits>\n    basic_ostream<wchar_t, _Traits>&\n    operator<<(basic_ostream<wchar_t, _Traits>&, const char16_t*) = delete;\n\n  template<typename _Traits>\n    basic_ostream<wchar_t, _Traits>&\n    operator<<(basic_ostream<wchar_t, _Traits>&, const char32_t*) = delete;\n#endif // _GLIBCXX_USE_WCHAR_T\n#endif // C++20\n  ///@}\n\n  // Standard basic_ostream manipulators\n\n  /**\n   *  @brief  Write a newline and flush the stream.\n   *\n   *  This manipulator is often mistakenly used when a simple newline is\n   *  desired, leading to poor buffering performance.  See\n   *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering\n   *  for more on this subject.\n  */\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    endl(basic_ostream<_CharT, _Traits>& __os)\n    { return flush(__os.put(__os.widen('\\n'))); }\n\n  /**\n   *  @brief  Write a null character into the output sequence.\n   *\n   *  <em>Null character</em> is @c CharT() by definition.  For CharT\n   *  of @c char, this correctly writes the ASCII @c NUL character\n   *  string terminator.\n  */\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    ends(basic_ostream<_CharT, _Traits>& __os)\n    { return __os.put(_CharT()); }\n\n  /**\n   *  @brief  Flushes the output stream.\n   *\n   *  This manipulator simply calls the stream's @c flush() member function.\n  */\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    flush(basic_ostream<_CharT, _Traits>& __os)\n    { return __os.flush(); }\n\n#if __cplusplus >= 201103L\n  // C++11 27.7.3.9 Rvalue stream insertion [ostream.rvalue]\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 1203. More useful rvalue stream insertion\n\n#if __cpp_lib_concepts\n  // Use concepts if possible because they're cheaper to evaluate.\n  template<typename _Tp>\n    concept __derived_from_ios_base = is_class_v<_Tp>\n      && (!is_same_v<_Tp, ios_base>)\n      && requires (_Tp* __t, ios_base* __b) { __b = __t; };\n\n  template<typename _Os, typename _Tp>\n    requires __derived_from_ios_base<_Os>\n      && requires (_Os& __os, const _Tp& __t) { __os << __t; }\n    using __rvalue_stream_insertion_t = _Os&&;\n#else\n  template<typename _Tp>\n    using _Require_derived_from_ios_base\n      = _Require<is_class<_Tp>, __not_<is_same<_Tp, ios_base>>,\n\t\t is_convertible<typename add_pointer<_Tp>::type, ios_base*>>;\n\n  template<typename _Os, typename _Tp,\n\t   typename = _Require_derived_from_ios_base<_Os>,\n\t   typename\n\t     = decltype(std::declval<_Os&>() << std::declval<const _Tp&>())>\n    using __rvalue_stream_insertion_t = _Os&&;\n#endif\n\n  /**\n   *  @brief  Generic inserter for rvalue stream\n   *  @param  __os  An input stream.\n   *  @param  __x  A reference to the object being inserted.\n   *  @return  __os\n   *\n   *  This is just a forwarding function to allow insertion to\n   *  rvalue streams since they won't bind to the inserter functions\n   *  that take an lvalue reference.\n  */\n  template<typename _Ostream, typename _Tp>\n    inline __rvalue_stream_insertion_t<_Ostream, _Tp>\n    operator<<(_Ostream&& __os, const _Tp& __x)\n    {\n      __os << __x;\n      return std::move(__os);\n    }\n\n#if __cplusplus > 201703L && _GLIBCXX_USE_CXX11_ABI\n  template<typename _CharT, typename _Traits>\n    class __syncbuf_base : public basic_streambuf<_CharT, _Traits>\n    {\n    public:\n      static bool*\n      _S_get(basic_streambuf<_CharT, _Traits>* __buf [[maybe_unused]]) noexcept\n      {\n#if __cpp_rtti\n\tif (auto __p = dynamic_cast<__syncbuf_base*>(__buf))\n\t  return &__p->_M_emit_on_sync;\n#endif\n\treturn nullptr;\n      }\n\n    protected:\n      __syncbuf_base(basic_streambuf<_CharT, _Traits>* __w = nullptr)\n      : _M_wrapped(__w)\n      { }\n\n      basic_streambuf<_CharT, _Traits>* _M_wrapped = nullptr;\n      bool _M_emit_on_sync = false;\n      bool _M_needs_sync = false;\n    };\n\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    emit_on_flush(basic_ostream<_CharT, _Traits>& __os)\n    {\n      if (bool* __flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))\n\t*__flag = true;\n      return __os;\n    }\n\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    noemit_on_flush(basic_ostream<_CharT, _Traits>& __os)\n    {\n      if (bool* __flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))\n\t*__flag = false;\n      return __os;\n    }\n\n  template<typename _CharT, typename _Traits>\n    inline basic_ostream<_CharT, _Traits>&\n    flush_emit(basic_ostream<_CharT, _Traits>& __os)\n    {\n      struct _Restore\n      {\n\t~_Restore() { *_M_flag = _M_prev; }\n\n\tbool _M_prev = false;\n\tbool* _M_flag = &_M_prev;\n      } __restore;\n\n      if (bool* __flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))\n\t{\n\t  __restore._M_prev = *__flag;\n\t  __restore._M_flag = __flag;\n\t  *__flag = true;\n\t}\n\n      __os.flush();\n      return __os;\n    }\n\n#endif // C++20\n\n#endif // C++11\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#include <bits/ostream.tcc>\n\n#endif\t/* _GLIBCXX_OSTREAM */\n"}],"crc32":1278564824,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]