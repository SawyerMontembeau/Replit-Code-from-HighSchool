[{"ops":[{"insert":"// functional_hash.h header -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/functional_hash.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{functional}\n */\n\n#ifndef _FUNCTIONAL_HASH_H\n#define _FUNCTIONAL_HASH_H 1\n\n#pragma GCC system_header\n\n#include <type_traits>\n#include <bits/hash_bytes.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /** @defgroup hashes Hashes\n   *  @ingroup functors\n   *\n   *   Hashing functors taking a variable type and returning a @c std::size_t.\n   *\n   *  @{\n   */\n\n  template<typename _Result, typename _Arg>\n    struct __hash_base\n    {\n      typedef _Result     result_type _GLIBCXX17_DEPRECATED;\n      typedef _Arg      argument_type _GLIBCXX17_DEPRECATED;\n    };\n\n  /// Primary class template hash.\n  template<typename _Tp>\n    struct hash;\n\n  template<typename _Tp, typename = void>\n    struct __poison_hash\n    {\n      static constexpr bool __enable_hash_call = false;\n    private:\n      // Private rather than deleted to be non-trivially-copyable.\n      __poison_hash(__poison_hash&&);\n      ~__poison_hash();\n    };\n\n  template<typename _Tp>\n    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>\n    {\n      static constexpr bool __enable_hash_call = true;\n    };\n\n  // Helper struct for SFINAE-poisoning non-enum types.\n  template<typename _Tp, bool = is_enum<_Tp>::value>\n    struct __hash_enum\n    {\n    private:\n      // Private rather than deleted to be non-trivially-copyable.\n      __hash_enum(__hash_enum&&);\n      ~__hash_enum();\n    };\n\n  // Helper struct for hash with enum types.\n  template<typename _Tp>\n    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>\n    {\n      size_t\n      operator()(_Tp __val) const noexcept\n      {\n       using __type = typename underlying_type<_Tp>::type;\n       return hash<__type>{}(static_cast<__type>(__val));\n      }\n    };\n\n  /// Primary class template hash, usable for enum types only.\n  // Use with non-enum types still SFINAES.\n  template<typename _Tp>\n    struct hash : __hash_enum<_Tp>\n    { };\n\n  /// Partial specializations for pointer types.\n  template<typename _Tp>\n    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>\n    {\n      size_t\n      operator()(_Tp* __p) const noexcept\n      { return reinterpret_cast<size_t>(__p); }\n    };\n\n  // Explicit specializations for integer types.\n#define _Cxx_hashtable_define_trivial_hash(_Tp) \t\\\n  template<>\t\t\t\t\t\t\\\n    struct hash<_Tp> : public __hash_base<size_t, _Tp>  \\\n    {                                                   \\\n      size_t                                            \\\n      operator()(_Tp __val) const noexcept              \\\n      { return static_cast<size_t>(__val); }            \\\n    };\n\n  /// Explicit specialization for bool.\n  _Cxx_hashtable_define_trivial_hash(bool)\n\n  /// Explicit specialization for char.\n  _Cxx_hashtable_define_trivial_hash(char)\n\n  /// Explicit specialization for signed char.\n  _Cxx_hashtable_define_trivial_hash(signed char)\n\n  /// Explicit specialization for unsigned char.\n  _Cxx_hashtable_define_trivial_hash(unsigned char)\n\n  /// Explicit specialization for wchar_t.\n  _Cxx_hashtable_define_trivial_hash(wchar_t)\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n  /// Explicit specialization for char8_t.\n  _Cxx_hashtable_define_trivial_hash(char8_t)\n#endif\n\n  /// Explicit specialization for char16_t.\n  _Cxx_hashtable_define_trivial_hash(char16_t)\n\n  /// Explicit specialization for char32_t.\n  _Cxx_hashtable_define_trivial_hash(char32_t)\n\n  /// Explicit specialization for short.\n  _Cxx_hashtable_define_trivial_hash(short)\n\n  /// Explicit specialization for int.\n  _Cxx_hashtable_define_trivial_hash(int)\n\n  /// Explicit specialization for long.\n  _Cxx_hashtable_define_trivial_hash(long)\n\n  /// Explicit specialization for long long.\n  _Cxx_hashtable_define_trivial_hash(long long)\n\n  /// Explicit specialization for unsigned short.\n  _Cxx_hashtable_define_trivial_hash(unsigned short)\n\n  /// Explicit specialization for unsigned int.\n  _Cxx_hashtable_define_trivial_hash(unsigned int)\n\n  /// Explicit specialization for unsigned long.\n  _Cxx_hashtable_define_trivial_hash(unsigned long)\n\n  /// Explicit specialization for unsigned long long.\n  _Cxx_hashtable_define_trivial_hash(unsigned long long)\n\n#ifdef __GLIBCXX_TYPE_INT_N_0\n  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_0)\n  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_0 unsigned)\n#endif\n#ifdef __GLIBCXX_TYPE_INT_N_1\n  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_1)\n  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_1 unsigned)\n#endif\n#ifdef __GLIBCXX_TYPE_INT_N_2\n  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_2)\n  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_2 unsigned)\n#endif\n#ifdef __GLIBCXX_TYPE_INT_N_3\n  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_3)\n  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_3 unsigned)\n#endif\n\n#undef _Cxx_hashtable_define_trivial_hash\n\n  struct _Hash_impl\n  {\n    static size_t\n    hash(const void* __ptr, size_t __clength,\n\t size_t __seed = static_cast<size_t>(0xc70f6907UL))\n    { return _Hash_bytes(__ptr, __clength, __seed); }\n\n    template<typename _Tp>\n      static size_t\n      hash(const _Tp& __val)\n      { return hash(&__val, sizeof(__val)); }\n\n    template<typename _Tp>\n      static size_t\n      __hash_combine(const _Tp& __val, size_t __hash)\n      { return hash(&__val, sizeof(__val), __hash); }\n  };\n\n  // A hash function similar to FNV-1a (see PR59406 for how it differs).\n  struct _Fnv_hash_impl\n  {\n    static size_t\n    hash(const void* __ptr, size_t __clength,\n\t size_t __seed = static_cast<size_t>(2166136261UL))\n    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }\n\n    template<typename _Tp>\n      static size_t\n      hash(const _Tp& __val)\n      { return hash(&__val, sizeof(__val)); }\n\n    template<typename _Tp>\n      static size_t\n      __hash_combine(const _Tp& __val, size_t __hash)\n      { return hash(&__val, sizeof(__val), __hash); }\n  };\n\n  /// Specialization for float.\n  template<>\n    struct hash<float> : public __hash_base<size_t, float>\n    {\n      size_t\n      operator()(float __val) const noexcept\n      {\n\t// 0 and -0 both hash to zero.\n\treturn __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;\n      }\n    };\n\n  /// Specialization for double.\n  template<>\n    struct hash<double> : public __hash_base<size_t, double>\n    {\n      size_t\n      operator()(double __val) const noexcept\n      {\n\t// 0 and -0 both hash to zero.\n\treturn __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;\n      }\n    };\n\n  /// Specialization for long double.\n  template<>\n    struct hash<long double>\n    : public __hash_base<size_t, long double>\n    {\n      _GLIBCXX_PURE size_t\n      operator()(long double __val) const noexcept;\n    };\n\n#if __cplusplus >= 201703L\n  template<>\n    struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t>\n    {\n      size_t\n      operator()(nullptr_t) const noexcept\n      { return 0; }\n    };\n#endif\n\n  /// @} group hashes\n\n  // Hint about performance of hash functor. If not fast the hash-based\n  // containers will cache the hash code.\n  // Default behavior is to consider that hashers are fast unless specified\n  // otherwise.\n  template<typename _Hash>\n    struct __is_fast_hash : public std::true_type\n    { };\n\n  template<>\n    struct __is_fast_hash<hash<long double>> : public std::false_type\n    { };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _FUNCTIONAL_HASH_H\n"}],"crc32":3402170343,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]