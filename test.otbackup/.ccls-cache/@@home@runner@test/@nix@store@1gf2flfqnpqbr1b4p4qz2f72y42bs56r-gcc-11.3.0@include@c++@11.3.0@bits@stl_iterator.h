[{"ops":[{"insert":"// Iterators -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996-1998\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/** @file bits/stl_iterator.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{iterator}\n *\n *  This file implements reverse_iterator, back_insert_iterator,\n *  front_insert_iterator, insert_iterator, __normal_iterator, and their\n *  supporting functions and overloaded operators.\n */\n\n#ifndef _STL_ITERATOR_H\n#define _STL_ITERATOR_H 1\n\n#include <bits/cpp_type_traits.h>\n#include <bits/stl_iterator_base_types.h>\n#include <ext/type_traits.h>\n#include <bits/move.h>\n#include <bits/ptr_traits.h>\n\n#if __cplusplus >= 201103L\n# include <type_traits>\n#endif\n\n#if __cplusplus > 201703L\n# define __cpp_lib_array_constexpr 201811L\n# define __cpp_lib_constexpr_iterator 201811L\n#elif __cplusplus == 201703L\n# define __cpp_lib_array_constexpr 201803L\n#endif\n\n#if __cplusplus > 201703L\n# include <compare>\n# include <new>\n# include <bits/exception_defines.h>\n# include <bits/iterator_concepts.h>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   * @addtogroup iterators\n   * @{\n   */\n\n#if __cpp_lib_concepts\n  namespace __detail\n  {\n    // Weaken iterator_category _Cat to _Limit if it is derived from that,\n    // otherwise use _Otherwise.\n    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>\n      using __clamp_iter_cat\n\t= conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;\n  }\n#endif\n\n  // 24.4.1 Reverse iterators\n  /**\n   *  Bidirectional and random access iterators have corresponding reverse\n   *  %iterator adaptors that iterate through the data structure in the\n   *  opposite direction.  They have the same signatures as the corresponding\n   *  iterators.  The fundamental relation between a reverse %iterator and its\n   *  corresponding %iterator @c i is established by the identity:\n   *  @code\n   *      &*(reverse_iterator(i)) == &*(i - 1)\n   *  @endcode\n   *\n   *  <em>This mapping is dictated by the fact that while there is always a\n   *  pointer past the end of an array, there might not be a valid pointer\n   *  before the beginning of an array.</em> [24.4.1]/1,2\n   *\n   *  Reverse iterators can be tricky and surprising at first.  Their\n   *  semantics make sense, however, and the trickiness is a side effect of\n   *  the requirement that the iterators must be safe.\n  */\n  template<typename _Iterator>\n    class reverse_iterator\n    : public iterator<typename iterator_traits<_Iterator>::iterator_category,\n\t\t      typename iterator_traits<_Iterator>::value_type,\n\t\t      typename iterator_traits<_Iterator>::difference_type,\n\t\t      typename iterator_traits<_Iterator>::pointer,\n                      typename iterator_traits<_Iterator>::reference>\n    {\n      template<typename _Iter>\n\tfriend class reverse_iterator;\n\n#if __cpp_lib_concepts\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3435. three_way_comparable_with<reverse_iterator<int*>, [...]>\n      template<typename _Iter>\n\tstatic constexpr bool __convertible = !is_same_v<_Iter, _Iterator>\n\t    && convertible_to<const _Iter&, _Iterator>;\n#endif\n\n    protected:\n      _Iterator current;\n\n      typedef iterator_traits<_Iterator>\t\t__traits_type;\n\n    public:\n      typedef _Iterator\t\t\t\t\titerator_type;\n      typedef typename __traits_type::pointer\t\tpointer;\n#if ! __cpp_lib_concepts\n      typedef typename __traits_type::difference_type\tdifference_type;\n      typedef typename __traits_type::reference\t\treference;\n#else\n      using iterator_concept\n\t= conditional_t<random_access_iterator<_Iterator>,\n\t\t\trandom_access_iterator_tag,\n\t\t\tbidirectional_iterator_tag>;\n      using iterator_category\n\t= __detail::__clamp_iter_cat<typename __traits_type::iterator_category,\n\t\t\t\t     random_access_iterator_tag>;\n      using value_type = iter_value_t<_Iterator>;\n      using difference_type = iter_difference_t<_Iterator>;\n      using reference = iter_reference_t<_Iterator>;\n#endif\n\n      /**\n       *  The default constructor value-initializes member @p current.\n       *  If it is a pointer, that means it is zero-initialized.\n      */\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 235 No specification of default ctor for reverse_iterator\n      // 1012. reverse_iterator default ctor should value initialize\n      _GLIBCXX17_CONSTEXPR\n      reverse_iterator() : current() { }\n\n      /**\n       *  This %iterator will move in the opposite direction that @p x does.\n      */\n      explicit _GLIBCXX17_CONSTEXPR\n      reverse_iterator(iterator_type __x) : current(__x) { }\n\n      /**\n       *  The copy constructor is normal.\n      */\n      _GLIBCXX17_CONSTEXPR\n      reverse_iterator(const reverse_iterator& __x)\n      : current(__x.current) { }\n\n#if __cplusplus >= 201103L\n      reverse_iterator& operator=(const reverse_iterator&) = default;\n#endif\n\n      /**\n       *  A %reverse_iterator across other types can be copied if the\n       *  underlying %iterator can be converted to the type of @c current.\n      */\n      template<typename _Iter>\n#if __cpp_lib_concepts\n\trequires __convertible<_Iter>\n#endif\n\t_GLIBCXX17_CONSTEXPR\n        reverse_iterator(const reverse_iterator<_Iter>& __x)\n\t: current(__x.current) { }\n\n#if __cplusplus >= 201103L\n      template<typename _Iter>\n#if __cpp_lib_concepts\n\trequires __convertible<_Iter>\n\t  && assignable_from<_Iterator&, const _Iter&>\n#endif\n\t_GLIBCXX17_CONSTEXPR\n\treverse_iterator&\n\toperator=(const reverse_iterator<_Iter>& __x)\n\t{\n\t  current = __x.current;\n\t  return *this;\n\t}\n#endif\n\n      /**\n       *  @return  @c current, the %iterator used for underlying work.\n      */\n      _GLIBCXX17_CONSTEXPR iterator_type\n      base() const\n      { return current; }\n\n      /**\n       *  @return  A reference to the value at @c --current\n       *\n       *  This requires that @c --current is dereferenceable.\n       *\n       *  @warning This implementation requires that for an iterator of the\n       *           underlying iterator type, @c x, a reference obtained by\n       *           @c *x remains valid after @c x has been modified or\n       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823\n      */\n      _GLIBCXX17_CONSTEXPR reference\n      operator*() const\n      {\n\t_Iterator __tmp = current;\n\treturn *--__tmp;\n      }\n\n      /**\n       *  @return  A pointer to the value at @c --current\n       *\n       *  This requires that @c --current is dereferenceable.\n      */\n      _GLIBCXX17_CONSTEXPR pointer\n      operator->() const\n#if __cplusplus > 201703L && __cpp_concepts >= 201907L\n      requires is_pointer_v<_Iterator>\n\t|| requires(const _Iterator __i) { __i.operator->(); }\n#endif\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 1052. operator-> should also support smart pointers\n\t_Iterator __tmp = current;\n\t--__tmp;\n\treturn _S_to_pointer(__tmp);\n      }\n\n      /**\n       *  @return  @c *this\n       *\n       *  Decrements the underlying iterator.\n      */\n      _GLIBCXX17_CONSTEXPR reverse_iterator&\n      operator++()\n      {\n\t--current;\n\treturn *this;\n      }\n\n      /**\n       *  @return  The original value of @c *this\n       *\n       *  Decrements the underlying iterator.\n      */\n      _GLIBCXX17_CONSTEXPR reverse_iterator\n      operator++(int)\n      {\n\treverse_iterator __tmp = *this;\n\t--current;\n\treturn __tmp;\n      }\n\n      /**\n       *  @return  @c *this\n       *\n       *  Increments the underlying iterator.\n      */\n      _GLIBCXX17_CONSTEXPR reverse_iterator&\n      operator--()\n      {\n\t++current;\n\treturn *this;\n      }\n\n      /**\n       *  @return  A reverse_iterator with the previous value of @c *this\n       *\n       *  Increments the underlying iterator.\n      */\n      _GLIBCXX17_CONSTEXPR reverse_iterator\n      operator--(int)\n      {\n\treverse_iterator __tmp = *this;\n\t++current;\n\treturn __tmp;\n      }\n\n      /**\n       *  @return  A reverse_iterator that refers to @c current - @a __n\n       *\n       *  The underlying iterator must be a Random Access Iterator.\n      */\n      _GLIBCXX17_CONSTEXPR reverse_iterator\n      operator+(difference_type __n) const\n      { return reverse_iterator(current - __n); }\n\n      /**\n       *  @return  *this\n       *\n       *  Moves the underlying iterator backwards @a __n steps.\n       *  The underlying iterator must be a Random Access Iterator.\n      */\n      _GLIBCXX17_CONSTEXPR reverse_iterator&\n      operator+=(difference_type __n)\n      {\n\tcurrent -= __n;\n\treturn *this;\n      }\n\n      /**\n       *  @return  A reverse_iterator that refers to @c current - @a __n\n       *\n       *  The underlying iterator must be a Random Access Iterator.\n      */\n      _GLIBCXX17_CONSTEXPR reverse_iterator\n      operator-(difference_type __n) const\n      { return reverse_iterator(current + __n); }\n\n      /**\n       *  @return  *this\n       *\n       *  Moves the underlying iterator forwards @a __n steps.\n       *  The underlying iterator must be a Random Access Iterator.\n      */\n      _GLIBCXX17_CONSTEXPR reverse_iterator&\n      operator-=(difference_type __n)\n      {\n\tcurrent += __n;\n\treturn *this;\n      }\n\n      /**\n       *  @return  The value at @c current - @a __n - 1\n       *\n       *  The underlying iterator must be a Random Access Iterator.\n      */\n      _GLIBCXX17_CONSTEXPR reference\n      operator[](difference_type __n) const\n      { return *(*this + __n); }\n\n#if __cplusplus > 201703L && __cpp_lib_concepts\n      friend constexpr iter_rvalue_reference_t<_Iterator>\n      iter_move(const reverse_iterator& __i)\n      noexcept(is_nothrow_copy_constructible_v<_Iterator>\n\t       && noexcept(ranges::iter_move(--std::declval<_Iterator&>())))\n      {\n\tauto __tmp = __i.base();\n\treturn ranges::iter_move(--__tmp);\n      }\n\n      template<indirectly_swappable<_Iterator> _Iter2>\n\tfriend constexpr void\n\titer_swap(const reverse_iterator& __x,\n\t\t  const reverse_iterator<_Iter2>& __y)\n\tnoexcept(is_nothrow_copy_constructible_v<_Iterator>\n\t\t && is_nothrow_copy_constructible_v<_Iter2>\n\t\t && noexcept(ranges::iter_swap(--std::declval<_Iterator&>(),\n\t\t\t\t\t       --std::declval<_Iter2&>())))\n\t{\n\t  auto __xtmp = __x.base();\n\t  auto __ytmp = __y.base();\n\t  ranges::iter_swap(--__xtmp, --__ytmp);\n\t}\n#endif\n\n    private:\n      template<typename _Tp>\n\tstatic _GLIBCXX17_CONSTEXPR _Tp*\n\t_S_to_pointer(_Tp* __p)\n        { return __p; }\n\n      template<typename _Tp>\n\tstatic _GLIBCXX17_CONSTEXPR pointer\n\t_S_to_pointer(_Tp __t)\n        { return __t.operator->(); }\n    };\n\n  ///@{\n  /**\n   *  @param  __x  A %reverse_iterator.\n   *  @param  __y  A %reverse_iterator.\n   *  @return  A simple bool.\n   *\n   *  Reverse iterators forward comparisons to their underlying base()\n   *  iterators.\n   *\n  */\n#if __cplusplus <= 201703L || ! defined __cpp_lib_concepts\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator==(const reverse_iterator<_Iterator>& __x,\n\t       const reverse_iterator<_Iterator>& __y)\n    { return __x.base() == __y.base(); }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator<(const reverse_iterator<_Iterator>& __x,\n\t      const reverse_iterator<_Iterator>& __y)\n    { return __y.base() < __x.base(); }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator!=(const reverse_iterator<_Iterator>& __x,\n\t       const reverse_iterator<_Iterator>& __y)\n    { return !(__x == __y); }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator>(const reverse_iterator<_Iterator>& __x,\n\t      const reverse_iterator<_Iterator>& __y)\n    { return __y < __x; }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator<=(const reverse_iterator<_Iterator>& __x,\n\t       const reverse_iterator<_Iterator>& __y)\n    { return !(__y < __x); }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator>=(const reverse_iterator<_Iterator>& __x,\n\t       const reverse_iterator<_Iterator>& __y)\n    { return !(__x < __y); }\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // DR 280. Comparison of reverse_iterator to const reverse_iterator.\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator==(const reverse_iterator<_IteratorL>& __x,\n\t       const reverse_iterator<_IteratorR>& __y)\n    { return __x.base() == __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator<(const reverse_iterator<_IteratorL>& __x,\n\t      const reverse_iterator<_IteratorR>& __y)\n    { return __x.base() > __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator!=(const reverse_iterator<_IteratorL>& __x,\n\t       const reverse_iterator<_IteratorR>& __y)\n    { return __x.base() != __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator>(const reverse_iterator<_IteratorL>& __x,\n\t      const reverse_iterator<_IteratorR>& __y)\n    { return __x.base() < __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator<=(const reverse_iterator<_IteratorL>& __x,\n\t       const reverse_iterator<_IteratorR>& __y)\n    { return __x.base() >= __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator>=(const reverse_iterator<_IteratorL>& __x,\n\t       const reverse_iterator<_IteratorR>& __y)\n    { return __x.base() <= __y.base(); }\n#else // C++20\n  template<typename _IteratorL, typename _IteratorR>\n    constexpr bool\n    operator==(const reverse_iterator<_IteratorL>& __x,\n\t       const reverse_iterator<_IteratorR>& __y)\n    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }\n    { return __x.base() == __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    constexpr bool\n    operator!=(const reverse_iterator<_IteratorL>& __x,\n\t       const reverse_iterator<_IteratorR>& __y)\n    requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; }\n    { return __x.base() != __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    constexpr bool\n    operator<(const reverse_iterator<_IteratorL>& __x,\n\t      const reverse_iterator<_IteratorR>& __y)\n    requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; }\n    { return __x.base() > __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    constexpr bool\n    operator>(const reverse_iterator<_IteratorL>& __x,\n\t      const reverse_iterator<_IteratorR>& __y)\n    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }\n    { return __x.base() < __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    constexpr bool\n    operator<=(const reverse_iterator<_IteratorL>& __x,\n\t       const reverse_iterator<_IteratorR>& __y)\n    requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; }\n    { return __x.base() >= __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    constexpr bool\n    operator>=(const reverse_iterator<_IteratorL>& __x,\n\t       const reverse_iterator<_IteratorR>& __y)\n    requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; }\n    { return __x.base() <= __y.base(); }\n\n  template<typename _IteratorL,\n\t   three_way_comparable_with<_IteratorL> _IteratorR>\n    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>\n    operator<=>(const reverse_iterator<_IteratorL>& __x,\n\t\tconst reverse_iterator<_IteratorR>& __y)\n    { return __y.base() <=> __x.base(); }\n#endif // C++20\n  ///@}\n\n#if __cplusplus < 201103L\n  template<typename _Iterator>\n    inline typename reverse_iterator<_Iterator>::difference_type\n    operator-(const reverse_iterator<_Iterator>& __x,\n\t      const reverse_iterator<_Iterator>& __y)\n    { return __y.base() - __x.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline typename reverse_iterator<_IteratorL>::difference_type\n    operator-(const reverse_iterator<_IteratorL>& __x,\n\t      const reverse_iterator<_IteratorR>& __y)\n    { return __y.base() - __x.base(); }\n#else\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // DR 685. reverse_iterator/move_iterator difference has invalid signatures\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR auto\n    operator-(const reverse_iterator<_IteratorL>& __x,\n\t      const reverse_iterator<_IteratorR>& __y)\n    -> decltype(__y.base() - __x.base())\n    { return __y.base() - __x.base(); }\n#endif\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>\n    operator+(typename reverse_iterator<_Iterator>::difference_type __n,\n\t      const reverse_iterator<_Iterator>& __x)\n    { return reverse_iterator<_Iterator>(__x.base() - __n); }\n\n#if __cplusplus >= 201103L\n  // Same as C++14 make_reverse_iterator but used in C++11 mode too.\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>\n    __make_reverse_iterator(_Iterator __i)\n    { return reverse_iterator<_Iterator>(__i); }\n\n# if __cplusplus >= 201402L\n#  define __cpp_lib_make_reverse_iterator 201402\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // DR 2285. make_reverse_iterator\n  /// Generator function for reverse_iterator.\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>\n    make_reverse_iterator(_Iterator __i)\n    { return reverse_iterator<_Iterator>(__i); }\n\n#  if __cplusplus > 201703L && defined __cpp_lib_concepts\n  template<typename _Iterator1, typename _Iterator2>\n    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)\n    inline constexpr bool\n    disable_sized_sentinel_for<reverse_iterator<_Iterator1>,\n\t\t\t       reverse_iterator<_Iterator2>> = true;\n#  endif // C++20\n# endif // C++14\n\n  template<typename _Iterator>\n    _GLIBCXX20_CONSTEXPR\n    auto\n    __niter_base(reverse_iterator<_Iterator> __it)\n    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))\n    { return __make_reverse_iterator(__niter_base(__it.base())); }\n\n  template<typename _Iterator>\n    struct __is_move_iterator<reverse_iterator<_Iterator> >\n      : __is_move_iterator<_Iterator>\n    { };\n\n  template<typename _Iterator>\n    _GLIBCXX20_CONSTEXPR\n    auto\n    __miter_base(reverse_iterator<_Iterator> __it)\n    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))\n    { return __make_reverse_iterator(__miter_base(__it.base())); }\n#endif // C++11\n\n  // 24.4.2.2.1 back_insert_iterator\n  /**\n   *  @brief  Turns assignment into insertion.\n   *\n   *  These are output iterators, constructed from a container-of-T.\n   *  Assigning a T to the iterator appends it to the container using\n   *  push_back.\n   *\n   *  Tip:  Using the back_inserter function to create these iterators can\n   *  save typing.\n  */\n  template<typename _Container>\n    class back_insert_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n    {\n    protected:\n      _Container* container;\n\n    public:\n      /// A nested typedef for the type of whatever container you used.\n      typedef _Container          container_type;\n#if __cplusplus > 201703L\n      using difference_type = ptrdiff_t;\n\n      constexpr back_insert_iterator() noexcept : container(nullptr) { }\n#endif\n\n      /// The only way to create this %iterator is with a container.\n      explicit _GLIBCXX20_CONSTEXPR\n      back_insert_iterator(_Container& __x)\n      : container(std::__addressof(__x)) { }\n\n      /**\n       *  @param  __value  An instance of whatever type\n       *                 container_type::const_reference is; presumably a\n       *                 reference-to-const T for container<T>.\n       *  @return  This %iterator, for chained operations.\n       *\n       *  This kind of %iterator doesn't really have a @a position in the\n       *  container (you can think of the position as being permanently at\n       *  the end, if you like).  Assigning a value to the %iterator will\n       *  always append the value to the end of the container.\n      */\n#if __cplusplus < 201103L\n      back_insert_iterator&\n      operator=(typename _Container::const_reference __value)\n      {\n\tcontainer->push_back(__value);\n\treturn *this;\n      }\n#else\n      _GLIBCXX20_CONSTEXPR\n      back_insert_iterator&\n      operator=(const typename _Container::value_type& __value)\n      {\n\tcontainer->push_back(__value);\n\treturn *this;\n      }\n\n      _GLIBCXX20_CONSTEXPR\n      back_insert_iterator&\n      operator=(typename _Container::value_type&& __value)\n      {\n\tcontainer->push_back(std::move(__value));\n\treturn *this;\n      }\n#endif\n\n      /// Simply returns *this.\n      _GLIBCXX20_CONSTEXPR\n      back_insert_iterator&\n      operator*()\n      { return *this; }\n\n      /// Simply returns *this.  (This %iterator does not @a move.)\n      _GLIBCXX20_CONSTEXPR\n      back_insert_iterator&\n      operator++()\n      { return *this; }\n\n      /// Simply returns *this.  (This %iterator does not @a move.)\n      _GLIBCXX20_CONSTEXPR\n      back_insert_iterator\n      operator++(int)\n      { return *this; }\n    };\n\n  /**\n   *  @param  __x  A container of arbitrary type.\n   *  @return  An instance of back_insert_iterator working on @p __x.\n   *\n   *  This wrapper function helps in creating back_insert_iterator instances.\n   *  Typing the name of the %iterator requires knowing the precise full\n   *  type of the container, which can be tedious and impedes generic\n   *  programming.  Using this function lets you take advantage of automatic\n   *  template parameter deduction, making the compiler match the correct\n   *  types for you.\n  */\n  template<typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline back_insert_iterator<_Container>\n    back_inserter(_Container& __x)\n    { return back_insert_iterator<_Container>(__x); }\n\n  /**\n   *  @brief  Turns assignment into insertion.\n   *\n   *  These are output iterators, constructed from a container-of-T.\n   *  Assigning a T to the iterator prepends it to the container using\n   *  push_front.\n   *\n   *  Tip:  Using the front_inserter function to create these iterators can\n   *  save typing.\n  */\n  template<typename _Container>\n    class front_insert_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n    {\n    protected:\n      _Container* container;\n\n    public:\n      /// A nested typedef for the type of whatever container you used.\n      typedef _Container          container_type;\n#if __cplusplus > 201703L\n      using difference_type = ptrdiff_t;\n\n      constexpr front_insert_iterator() noexcept : container(nullptr) { }\n#endif\n\n      /// The only way to create this %iterator is with a container.\n      explicit _GLIBCXX20_CONSTEXPR\n      front_insert_iterator(_Container& __x)\n      : container(std::__addressof(__x)) { }\n\n      /**\n       *  @param  __value  An instance of whatever type\n       *                 container_type::const_reference is; presumably a\n       *                 reference-to-const T for container<T>.\n       *  @return  This %iterator, for chained operations.\n       *\n       *  This kind of %iterator doesn't really have a @a position in the\n       *  container (you can think of the position as being permanently at\n       *  the front, if you like).  Assigning a value to the %iterator will\n       *  always prepend the value to the front of the container.\n      */\n#if __cplusplus < 201103L\n      front_insert_iterator&\n      operator=(typename _Container::const_reference __value)\n      {\n\tcontainer->push_front(__value);\n\treturn *this;\n      }\n#else\n      _GLIBCXX20_CONSTEXPR\n      front_insert_iterator&\n      operator=(const typename _Container::value_type& __value)\n      {\n\tcontainer->push_front(__value);\n\treturn *this;\n      }\n\n      _GLIBCXX20_CONSTEXPR\n      front_insert_iterator&\n      operator=(typename _Container::value_type&& __value)\n      {\n\tcontainer->push_front(std::move(__value));\n\treturn *this;\n      }\n#endif\n\n      /// Simply returns *this.\n      _GLIBCXX20_CONSTEXPR\n      front_insert_iterator&\n      operator*()\n      { return *this; }\n\n      /// Simply returns *this.  (This %iterator does not @a move.)\n      _GLIBCXX20_CONSTEXPR\n      front_insert_iterator&\n      operator++()\n      { return *this; }\n\n      /// Simply returns *this.  (This %iterator does not @a move.)\n      _GLIBCXX20_CONSTEXPR\n      front_insert_iterator\n      operator++(int)\n      { return *this; }\n    };\n\n  /**\n   *  @param  __x  A container of arbitrary type.\n   *  @return  An instance of front_insert_iterator working on @p x.\n   *\n   *  This wrapper function helps in creating front_insert_iterator instances.\n   *  Typing the name of the %iterator requires knowing the precise full\n   *  type of the container, which can be tedious and impedes generic\n   *  programming.  Using this function lets you take advantage of automatic\n   *  template parameter deduction, making the compiler match the correct\n   *  types for you.\n  */\n  template<typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline front_insert_iterator<_Container>\n    front_inserter(_Container& __x)\n    { return front_insert_iterator<_Container>(__x); }\n\n  /**\n   *  @brief  Turns assignment into insertion.\n   *\n   *  These are output iterators, constructed from a container-of-T.\n   *  Assigning a T to the iterator inserts it in the container at the\n   *  %iterator's position, rather than overwriting the value at that\n   *  position.\n   *\n   *  (Sequences will actually insert a @e copy of the value before the\n   *  %iterator's position.)\n   *\n   *  Tip:  Using the inserter function to create these iterators can\n   *  save typing.\n  */\n  template<typename _Container>\n    class insert_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n    {\n#if __cplusplus > 201703L && defined __cpp_lib_concepts\n      using _Iter = std::__detail::__range_iter_t<_Container>;\n\n    protected:\n      _Container* container = nullptr;\n      _Iter iter = _Iter();\n#else\n      typedef typename _Container::iterator\t\t_Iter;\n\n    protected:\n      _Container* container;\n      _Iter iter;\n#endif\n\n    public:\n      /// A nested typedef for the type of whatever container you used.\n      typedef _Container          container_type;\n\n#if __cplusplus > 201703L && defined __cpp_lib_concepts\n      using difference_type = ptrdiff_t;\n\n      insert_iterator() = default;\n#endif\n\n      /**\n       *  The only way to create this %iterator is with a container and an\n       *  initial position (a normal %iterator into the container).\n      */\n      _GLIBCXX20_CONSTEXPR\n      insert_iterator(_Container& __x, _Iter __i)\n      : container(std::__addressof(__x)), iter(__i) {}\n\n      /**\n       *  @param  __value  An instance of whatever type\n       *                 container_type::const_reference is; presumably a\n       *                 reference-to-const T for container<T>.\n       *  @return  This %iterator, for chained operations.\n       *\n       *  This kind of %iterator maintains its own position in the\n       *  container.  Assigning a value to the %iterator will insert the\n       *  value into the container at the place before the %iterator.\n       *\n       *  The position is maintained such that subsequent assignments will\n       *  insert values immediately after one another.  For example,\n       *  @code\n       *     // vector v contains A and Z\n       *\n       *     insert_iterator i (v, ++v.begin());\n       *     i = 1;\n       *     i = 2;\n       *     i = 3;\n       *\n       *     // vector v contains A, 1, 2, 3, and Z\n       *  @endcode\n      */\n#if __cplusplus < 201103L\n      insert_iterator&\n      operator=(typename _Container::const_reference __value)\n      {\n\titer = container->insert(iter, __value);\n\t++iter;\n\treturn *this;\n      }\n#else\n      _GLIBCXX20_CONSTEXPR\n      insert_iterator&\n      operator=(const typename _Container::value_type& __value)\n      {\n\titer = container->insert(iter, __value);\n\t++iter;\n\treturn *this;\n      }\n\n      _GLIBCXX20_CONSTEXPR\n      insert_iterator&\n      operator=(typename _Container::value_type&& __value)\n      {\n\titer = container->insert(iter, std::move(__value));\n\t++iter;\n\treturn *this;\n      }\n#endif\n\n      /// Simply returns *this.\n      _GLIBCXX20_CONSTEXPR\n      insert_iterator&\n      operator*()\n      { return *this; }\n\n      /// Simply returns *this.  (This %iterator does not @a move.)\n      _GLIBCXX20_CONSTEXPR\n      insert_iterator&\n      operator++()\n      { return *this; }\n\n      /// Simply returns *this.  (This %iterator does not @a move.)\n      _GLIBCXX20_CONSTEXPR\n      insert_iterator&\n      operator++(int)\n      { return *this; }\n    };\n\n  /**\n   *  @param __x  A container of arbitrary type.\n   *  @param __i  An iterator into the container.\n   *  @return  An instance of insert_iterator working on @p __x.\n   *\n   *  This wrapper function helps in creating insert_iterator instances.\n   *  Typing the name of the %iterator requires knowing the precise full\n   *  type of the container, which can be tedious and impedes generic\n   *  programming.  Using this function lets you take advantage of automatic\n   *  template parameter deduction, making the compiler match the correct\n   *  types for you.\n  */\n#if __cplusplus > 201703L && defined __cpp_lib_concepts\n  template<typename _Container>\n    constexpr insert_iterator<_Container>\n    inserter(_Container& __x, std::__detail::__range_iter_t<_Container> __i)\n    { return insert_iterator<_Container>(__x, __i); }\n#else\n  template<typename _Container>\n    inline insert_iterator<_Container>\n    inserter(_Container& __x, typename _Container::iterator __i)\n    { return insert_iterator<_Container>(__x, __i); }\n#endif\n\n  /// @} group iterators\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // This iterator adapter is @a normal in the sense that it does not\n  // change the semantics of any of the operators of its iterator\n  // parameter.  Its primary purpose is to convert an iterator that is\n  // not a class, e.g. a pointer, into an iterator that is a class.\n  // The _Container parameter exists solely so that different containers\n  // using this template can instantiate different types, even if the\n  // _Iterator parameter is the same.\n  template<typename _Iterator, typename _Container>\n    class __normal_iterator\n    {\n    protected:\n      _Iterator _M_current;\n\n      typedef std::iterator_traits<_Iterator>\t\t__traits_type;\n\n    public:\n      typedef _Iterator\t\t\t\t\titerator_type;\n      typedef typename __traits_type::iterator_category iterator_category;\n      typedef typename __traits_type::value_type  \tvalue_type;\n      typedef typename __traits_type::difference_type \tdifference_type;\n      typedef typename __traits_type::reference \treference;\n      typedef typename __traits_type::pointer   \tpointer;\n\n#if __cplusplus > 201703L && __cpp_lib_concepts\n      using iterator_concept = std::__detail::__iter_concept<_Iterator>;\n#endif\n\n      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT\n      : _M_current(_Iterator()) { }\n\n      explicit _GLIBCXX20_CONSTEXPR\n      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT\n      : _M_current(__i) { }\n\n      // Allow iterator to const_iterator conversion\n      template<typename _Iter>\n        _GLIBCXX20_CONSTEXPR\n        __normal_iterator(const __normal_iterator<_Iter,\n\t\t\t  typename __enable_if<\n      \t       (std::__are_same<_Iter, typename _Container::pointer>::__value),\n\t\t      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT\n        : _M_current(__i.base()) { }\n\n      // Forward iterator requirements\n      _GLIBCXX20_CONSTEXPR\n      reference\n      operator*() const _GLIBCXX_NOEXCEPT\n      { return *_M_current; }\n\n      _GLIBCXX20_CONSTEXPR\n      pointer\n      operator->() const _GLIBCXX_NOEXCEPT\n      { return _M_current; }\n\n      _GLIBCXX20_CONSTEXPR\n      __normal_iterator&\n      operator++() _GLIBCXX_NOEXCEPT\n      {\n\t++_M_current;\n\treturn *this;\n      }\n\n      _GLIBCXX20_CONSTEXPR\n      __normal_iterator\n      operator++(int) _GLIBCXX_NOEXCEPT\n      { return __normal_iterator(_M_current++); }\n\n      // Bidirectional iterator requirements\n      _GLIBCXX20_CONSTEXPR\n      __normal_iterator&\n      operator--() _GLIBCXX_NOEXCEPT\n      {\n\t--_M_current;\n\treturn *this;\n      }\n\n      _GLIBCXX20_CONSTEXPR\n      __normal_iterator\n      operator--(int) _GLIBCXX_NOEXCEPT\n      { return __normal_iterator(_M_current--); }\n\n      // Random access iterator requirements\n      _GLIBCXX20_CONSTEXPR\n      reference\n      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT\n      { return _M_current[__n]; }\n\n      _GLIBCXX20_CONSTEXPR\n      __normal_iterator&\n      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT\n      { _M_current += __n; return *this; }\n\n      _GLIBCXX20_CONSTEXPR\n      __normal_iterator\n      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT\n      { return __normal_iterator(_M_current + __n); }\n\n      _GLIBCXX20_CONSTEXPR\n      __normal_iterator&\n      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT\n      { _M_current -= __n; return *this; }\n\n      _GLIBCXX20_CONSTEXPR\n      __normal_iterator\n      operator-(difference_type __n) const _GLIBCXX_NOEXCEPT\n      { return __normal_iterator(_M_current - __n); }\n\n      _GLIBCXX20_CONSTEXPR\n      const _Iterator&\n      base() const _GLIBCXX_NOEXCEPT\n      { return _M_current; }\n    };\n\n  // Note: In what follows, the left- and right-hand-side iterators are\n  // allowed to vary in types (conceptually in cv-qualification) so that\n  // comparison between cv-qualified and non-cv-qualified iterators be\n  // valid.  However, the greedy and unfriendly operators in std::rel_ops\n  // will make overload resolution ambiguous (when in scope) if we don't\n  // provide overloads whose operands are of the same type.  Can someone\n  // remind me what generic programming is about? -- Gaby\n\n#if __cpp_lib_three_way_comparison\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n    requires requires (_IteratorL __lhs, _IteratorR __rhs)\n    { { __lhs == __rhs } -> std::convertible_to<bool>; }\n    constexpr bool\n    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n    noexcept(noexcept(__lhs.base() == __rhs.base()))\n    { return __lhs.base() == __rhs.base(); }\n\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n    constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL>\n    operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t\tconst __normal_iterator<_IteratorR, _Container>& __rhs)\n    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))\n    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }\n#else\n   // Forward iterator requirements\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() == __rhs.base(); }\n\n  template<typename _Iterator, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,\n\t       const __normal_iterator<_Iterator, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() == __rhs.base(); }\n\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() != __rhs.base(); }\n\n  template<typename _Iterator, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,\n\t       const __normal_iterator<_Iterator, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() != __rhs.base(); }\n\n  // Random access iterator requirements\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n    inline bool\n    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() < __rhs.base(); }\n\n  template<typename _Iterator, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,\n\t      const __normal_iterator<_Iterator, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() < __rhs.base(); }\n\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n    inline bool\n    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() > __rhs.base(); }\n\n  template<typename _Iterator, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,\n\t      const __normal_iterator<_Iterator, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() > __rhs.base(); }\n\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n    inline bool\n    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() <= __rhs.base(); }\n\n  template<typename _Iterator, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,\n\t       const __normal_iterator<_Iterator, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() <= __rhs.base(); }\n\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n    inline bool\n    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() >= __rhs.base(); }\n\n  template<typename _Iterator, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline bool\n    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,\n\t       const __normal_iterator<_Iterator, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() >= __rhs.base(); }\n#endif // three-way comparison\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // According to the resolution of DR179 not only the various comparison\n  // operators but also operator- must accept mixed iterator/const_iterator\n  // parameters.\n  template<typename _IteratorL, typename _IteratorR, typename _Container>\n#if __cplusplus >= 201103L\n    // DR 685.\n    _GLIBCXX20_CONSTEXPR\n    inline auto\n    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t      const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept\n    -> decltype(__lhs.base() - __rhs.base())\n#else\n    inline typename __normal_iterator<_IteratorL, _Container>::difference_type\n    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n#endif\n    { return __lhs.base() - __rhs.base(); }\n\n  template<typename _Iterator, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline typename __normal_iterator<_Iterator, _Container>::difference_type\n    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,\n\t      const __normal_iterator<_Iterator, _Container>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.base() - __rhs.base(); }\n\n  template<typename _Iterator, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    inline __normal_iterator<_Iterator, _Container>\n    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type\n\t      __n, const __normal_iterator<_Iterator, _Container>& __i)\n    _GLIBCXX_NOEXCEPT\n    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template<typename _Iterator, typename _Container>\n    _GLIBCXX20_CONSTEXPR\n    _Iterator\n    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)\n    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)\n    { return __it.base(); }\n\n#if __cplusplus >= 201103L\n  /**\n   * @addtogroup iterators\n   * @{\n   */\n\n#if __cplusplus > 201703L && __cpp_lib_concepts\n  template<semiregular _Sent>\n    class move_sentinel\n    {\n    public:\n      constexpr\n      move_sentinel()\n      noexcept(is_nothrow_default_constructible_v<_Sent>)\n      : _M_last() { }\n\n      constexpr explicit\n      move_sentinel(_Sent __s)\n      noexcept(is_nothrow_move_constructible_v<_Sent>)\n      : _M_last(std::move(__s)) { }\n\n      template<typename _S2> requires convertible_to<const _S2&, _Sent>\n\tconstexpr\n\tmove_sentinel(const move_sentinel<_S2>& __s)\n\tnoexcept(is_nothrow_constructible_v<_Sent, const _S2&>)\n\t: _M_last(__s.base())\n\t{ }\n\n      template<typename _S2> requires assignable_from<_Sent&, const _S2&>\n\tconstexpr move_sentinel&\n\toperator=(const move_sentinel<_S2>& __s)\n\tnoexcept(is_nothrow_assignable_v<_Sent, const _S2&>)\n\t{\n\t  _M_last = __s.base();\n\t  return *this;\n\t}\n\n      constexpr _Sent\n      base() const\n      noexcept(is_nothrow_copy_constructible_v<_Sent>)\n      { return _M_last; }\n\n    private:\n      _Sent _M_last;\n    };\n#endif // C++20\n\n  namespace __detail\n  {\n#if __cplusplus > 201703L && __cpp_lib_concepts\n    template<typename _Iterator>\n      struct __move_iter_cat\n      { };\n\n    template<typename _Iterator>\n      requires requires { typename iterator_traits<_Iterator>::iterator_category; }\n      struct __move_iter_cat<_Iterator>\n      {\n\tusing iterator_category\n\t  = __clamp_iter_cat<typename iterator_traits<_Iterator>::iterator_category,\n\t\t\t     random_access_iterator_tag>;\n      };\n#endif\n  }\n\n  // 24.4.3  Move iterators\n  /**\n   *  Class template move_iterator is an iterator adapter with the same\n   *  behavior as the underlying iterator except that its dereference\n   *  operator implicitly converts the value returned by the underlying\n   *  iterator's dereference operator to an rvalue reference.  Some\n   *  generic algorithms can be called with move iterators to replace\n   *  copying with moving.\n   */\n  template<typename _Iterator>\n    class move_iterator\n#if __cplusplus > 201703L && __cpp_lib_concepts\n      : public __detail::__move_iter_cat<_Iterator>\n#endif\n    {\n      _Iterator _M_current;\n\n      using __traits_type = iterator_traits<_Iterator>;\n#if ! (__cplusplus > 201703L && __cpp_lib_concepts)\n      using __base_ref = typename __traits_type::reference;\n#endif\n\n      template<typename _Iter2>\n\tfriend class move_iterator;\n\n#if __cpp_lib_concepts\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3435. three_way_comparable_with<reverse_iterator<int*>, [...]>\n      template<typename _Iter2>\n\tstatic constexpr bool __convertible = !is_same_v<_Iter2, _Iterator>\n\t    && convertible_to<const _Iter2&, _Iterator>;\n#endif\n\n    public:\n      using iterator_type = _Iterator;\n\n#if __cplusplus > 201703L && __cpp_lib_concepts\n      using iterator_concept = input_iterator_tag;\n      // iterator_category defined in __move_iter_cat\n      using value_type = iter_value_t<_Iterator>;\n      using difference_type = iter_difference_t<_Iterator>;\n      using pointer = _Iterator;\n      using reference = iter_rvalue_reference_t<_Iterator>;\n#else\n      typedef typename __traits_type::iterator_category iterator_category;\n      typedef typename __traits_type::value_type  \tvalue_type;\n      typedef typename __traits_type::difference_type\tdifference_type;\n      // NB: DR 680.\n      typedef _Iterator\t\t\t\t\tpointer;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2106. move_iterator wrapping iterators returning prvalues\n      typedef typename conditional<is_reference<__base_ref>::value,\n\t\t\t typename remove_reference<__base_ref>::type&&,\n\t\t\t __base_ref>::type\t\treference;\n#endif\n\n      _GLIBCXX17_CONSTEXPR\n      move_iterator()\n      : _M_current() { }\n\n      explicit _GLIBCXX17_CONSTEXPR\n      move_iterator(iterator_type __i)\n      : _M_current(std::move(__i)) { }\n\n      template<typename _Iter>\n#if __cpp_lib_concepts\n\trequires __convertible<_Iter>\n#endif\n\t_GLIBCXX17_CONSTEXPR\n\tmove_iterator(const move_iterator<_Iter>& __i)\n\t: _M_current(__i._M_current) { }\n\n      template<typename _Iter>\n#if __cpp_lib_concepts\n\trequires __convertible<_Iter>\n\t  && assignable_from<_Iterator&, const _Iter&>\n#endif\n\t_GLIBCXX17_CONSTEXPR\n\tmove_iterator& operator=(const move_iterator<_Iter>& __i)\n\t{\n\t  _M_current = __i._M_current;\n\t  return *this;\n\t}\n\n#if __cplusplus <= 201703L\n      _GLIBCXX17_CONSTEXPR iterator_type\n      base() const\n      { return _M_current; }\n#else\n      constexpr const iterator_type&\n      base() const & noexcept\n      { return _M_current; }\n\n      constexpr iterator_type\n      base() &&\n      { return std::move(_M_current); }\n#endif\n\n      _GLIBCXX17_CONSTEXPR reference\n      operator*() const\n#if __cplusplus > 201703L && __cpp_lib_concepts\n      { return ranges::iter_move(_M_current); }\n#else\n      { return static_cast<reference>(*_M_current); }\n#endif\n\n      _GLIBCXX17_CONSTEXPR pointer\n      operator->() const\n      { return _M_current; }\n\n      _GLIBCXX17_CONSTEXPR move_iterator&\n      operator++()\n      {\n\t++_M_current;\n\treturn *this;\n      }\n\n      _GLIBCXX17_CONSTEXPR move_iterator\n      operator++(int)\n      {\n\tmove_iterator __tmp = *this;\n\t++_M_current;\n\treturn __tmp;\n      }\n\n#if __cpp_lib_concepts\n      constexpr void\n      operator++(int) requires (!forward_iterator<_Iterator>)\n      { ++_M_current; }\n#endif\n\n      _GLIBCXX17_CONSTEXPR move_iterator&\n      operator--()\n      {\n\t--_M_current;\n\treturn *this;\n      }\n\n      _GLIBCXX17_CONSTEXPR move_iterator\n      operator--(int)\n      {\n\tmove_iterator __tmp = *this;\n\t--_M_current;\n\treturn __tmp;\n      }\n\n      _GLIBCXX17_CONSTEXPR move_iterator\n      operator+(difference_type __n) const\n      { return move_iterator(_M_current + __n); }\n\n      _GLIBCXX17_CONSTEXPR move_iterator&\n      operator+=(difference_type __n)\n      {\n\t_M_current += __n;\n\treturn *this;\n      }\n\n      _GLIBCXX17_CONSTEXPR move_iterator\n      operator-(difference_type __n) const\n      { return move_iterator(_M_current - __n); }\n    \n      _GLIBCXX17_CONSTEXPR move_iterator&\n      operator-=(difference_type __n)\n      { \n\t_M_current -= __n;\n\treturn *this;\n      }\n\n      _GLIBCXX17_CONSTEXPR reference\n      operator[](difference_type __n) const\n#if __cplusplus > 201703L && __cpp_lib_concepts\n      { return ranges::iter_move(_M_current + __n); }\n#else\n      { return std::move(_M_current[__n]); }\n#endif\n\n#if __cplusplus > 201703L && __cpp_lib_concepts\n      template<sentinel_for<_Iterator> _Sent>\n\tfriend constexpr bool\n\toperator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)\n\t{ return __x.base() == __y.base(); }\n\n      template<sized_sentinel_for<_Iterator> _Sent>\n\tfriend constexpr iter_difference_t<_Iterator>\n\toperator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)\n\t{ return __x.base() - __y.base(); }\n\n      template<sized_sentinel_for<_Iterator> _Sent>\n\tfriend constexpr iter_difference_t<_Iterator>\n\toperator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)\n\t{ return __x.base() - __y.base(); }\n\n      friend constexpr iter_rvalue_reference_t<_Iterator>\n      iter_move(const move_iterator& __i)\n      noexcept(noexcept(ranges::iter_move(__i._M_current)))\n      { return ranges::iter_move(__i._M_current); }\n\n      template<indirectly_swappable<_Iterator> _Iter2>\n\tfriend constexpr void\n\titer_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)\n\tnoexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n\t{ return ranges::iter_swap(__x._M_current, __y._M_current); }\n#endif // C++20\n    };\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator==(const move_iterator<_IteratorL>& __x,\n\t       const move_iterator<_IteratorR>& __y)\n#if __cplusplus > 201703L && __cpp_lib_concepts\n    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }\n#endif\n    { return __x.base() == __y.base(); }\n\n#if __cpp_lib_three_way_comparison\n  template<typename _IteratorL,\n\t   three_way_comparable_with<_IteratorL> _IteratorR>\n    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>\n    operator<=>(const move_iterator<_IteratorL>& __x,\n\t\tconst move_iterator<_IteratorR>& __y)\n    { return __x.base() <=> __y.base(); }\n#else\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator!=(const move_iterator<_IteratorL>& __x,\n\t       const move_iterator<_IteratorR>& __y)\n    { return !(__x == __y); }\n#endif\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator<(const move_iterator<_IteratorL>& __x,\n\t      const move_iterator<_IteratorR>& __y)\n#if __cplusplus > 201703L && __cpp_lib_concepts\n    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }\n#endif\n    { return __x.base() < __y.base(); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator<=(const move_iterator<_IteratorL>& __x,\n\t       const move_iterator<_IteratorR>& __y)\n#if __cplusplus > 201703L && __cpp_lib_concepts\n    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }\n#endif\n    { return !(__y < __x); }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator>(const move_iterator<_IteratorL>& __x,\n\t      const move_iterator<_IteratorR>& __y)\n#if __cplusplus > 201703L && __cpp_lib_concepts\n    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }\n#endif\n    { return __y < __x; }\n\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator>=(const move_iterator<_IteratorL>& __x,\n\t       const move_iterator<_IteratorR>& __y)\n#if __cplusplus > 201703L && __cpp_lib_concepts\n    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }\n#endif\n    { return !(__x < __y); }\n\n#if ! (__cplusplus > 201703L && __cpp_lib_concepts)\n  // Note: See __normal_iterator operators note from Gaby to understand\n  // why we have these extra overloads for some move_iterator operators.\n\n  // These extra overloads are not needed in C++20, because the ones above\n  // are constrained with a requires-clause and so overload resolution will\n  // prefer them to greedy unconstrained function templates.\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator==(const move_iterator<_Iterator>& __x,\n\t       const move_iterator<_Iterator>& __y)\n    { return __x.base() == __y.base(); }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator!=(const move_iterator<_Iterator>& __x,\n\t       const move_iterator<_Iterator>& __y)\n    { return !(__x == __y); }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator<(const move_iterator<_Iterator>& __x,\n\t      const move_iterator<_Iterator>& __y)\n    { return __x.base() < __y.base(); }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator<=(const move_iterator<_Iterator>& __x,\n\t       const move_iterator<_Iterator>& __y)\n    { return !(__y < __x); }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator>(const move_iterator<_Iterator>& __x,\n\t      const move_iterator<_Iterator>& __y)\n    { return __y < __x; }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR bool\n    operator>=(const move_iterator<_Iterator>& __x,\n\t       const move_iterator<_Iterator>& __y)\n    { return !(__x < __y); }\n#endif // ! C++20\n\n  // DR 685.\n  template<typename _IteratorL, typename _IteratorR>\n    inline _GLIBCXX17_CONSTEXPR auto\n    operator-(const move_iterator<_IteratorL>& __x,\n\t      const move_iterator<_IteratorR>& __y)\n    -> decltype(__x.base() - __y.base())\n    { return __x.base() - __y.base(); }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>\n    operator+(typename move_iterator<_Iterator>::difference_type __n,\n\t      const move_iterator<_Iterator>& __x)\n    { return __x + __n; }\n\n  template<typename _Iterator>\n    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>\n    make_move_iterator(_Iterator __i)\n    { return move_iterator<_Iterator>(std::move(__i)); }\n\n  template<typename _Iterator, typename _ReturnType\n    = typename conditional<__move_if_noexcept_cond\n      <typename iterator_traits<_Iterator>::value_type>::value,\n                _Iterator, move_iterator<_Iterator>>::type>\n    inline _GLIBCXX17_CONSTEXPR _ReturnType\n    __make_move_if_noexcept_iterator(_Iterator __i)\n    { return _ReturnType(__i); }\n\n  // Overload for pointers that matches std::move_if_noexcept more closely,\n  // returning a constant iterator when we don't want to move.\n  template<typename _Tp, typename _ReturnType\n    = typename conditional<__move_if_noexcept_cond<_Tp>::value,\n\t\t\t   const _Tp*, move_iterator<_Tp*>>::type>\n    inline _GLIBCXX17_CONSTEXPR _ReturnType\n    __make_move_if_noexcept_iterator(_Tp* __i)\n    { return _ReturnType(__i); }\n\n#if __cplusplus > 201703L && __cpp_lib_concepts\n  // [iterators.common] Common iterators\n\n  namespace __detail\n  {\n    template<typename _It>\n      concept __common_iter_has_arrow = indirectly_readable<const _It>\n\t&& (requires(const _It& __it) { __it.operator->(); }\n\t    || is_reference_v<iter_reference_t<_It>>\n\t    || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);\n\n    template<typename _It>\n      concept __common_iter_use_postfix_proxy\n\t= (!requires (_It& __i) { { *__i++ } -> __can_reference; })\n\t  && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>\n\t  && move_constructible<iter_value_t<_It>>;\n  } // namespace __detail\n\n  /// An iterator/sentinel adaptor for representing a non-common range.\n  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n    requires (!same_as<_It, _Sent>) && copyable<_It>\n  class common_iterator\n  {\n    template<typename _Tp, typename _Up>\n      static constexpr bool\n      _S_noexcept1()\n      {\n\tif constexpr (is_trivially_default_constructible_v<_Tp>)\n\t  return is_nothrow_assignable_v<_Tp, _Up>;\n\telse\n\t  return is_nothrow_constructible_v<_Tp, _Up>;\n      }\n\n    template<typename _It2, typename _Sent2>\n      static constexpr bool\n      _S_noexcept()\n      { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }\n\n    class __arrow_proxy\n    {\n      iter_value_t<_It> _M_keep;\n\n      constexpr\n      __arrow_proxy(iter_reference_t<_It>&& __x)\n      : _M_keep(std::move(__x)) { }\n\n      friend class common_iterator;\n\n    public:\n      constexpr const iter_value_t<_It>*\n      operator->() const noexcept\n      { return std::__addressof(_M_keep); }\n    };\n\n    class __postfix_proxy\n    {\n      iter_value_t<_It> _M_keep;\n\n      constexpr\n      __postfix_proxy(iter_reference_t<_It>&& __x)\n      : _M_keep(std::forward<iter_reference_t<_It>>(__x)) { }\n\n      friend class common_iterator;\n\n    public:\n      constexpr const iter_value_t<_It>&\n      operator*() const noexcept\n      { return _M_keep; }\n    };\n\n  public:\n    constexpr\n    common_iterator()\n    noexcept(is_nothrow_default_constructible_v<_It>)\n    requires default_initializable<_It>\n    : _M_it(), _M_index(0)\n    { }\n\n    constexpr\n    common_iterator(_It __i)\n    noexcept(is_nothrow_move_constructible_v<_It>)\n    : _M_it(std::move(__i)), _M_index(0)\n    { }\n\n    constexpr\n    common_iterator(_Sent __s)\n    noexcept(is_nothrow_move_constructible_v<_Sent>)\n    : _M_sent(std::move(__s)), _M_index(1)\n    { }\n\n    template<typename _It2, typename _Sent2>\n      requires convertible_to<const _It2&, _It>\n\t&& convertible_to<const _Sent2&, _Sent>\n      constexpr\n      common_iterator(const common_iterator<_It2, _Sent2>& __x)\n      noexcept(_S_noexcept<const _It2&, const _Sent2&>())\n      : _M_valueless(), _M_index(__x._M_index)\n      {\n\tif (_M_index == 0)\n\t  {\n\t    if constexpr (is_trivially_default_constructible_v<_It>)\n\t      _M_it = std::move(__x._M_it);\n\t    else\n\t      ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);\n\t  }\n\telse if (_M_index == 1)\n\t  {\n\t    if constexpr (is_trivially_default_constructible_v<_Sent>)\n\t      _M_sent = std::move(__x._M_sent);\n\t    else\n\t      ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);\n\t  }\n      }\n\n    constexpr\n    common_iterator(const common_iterator& __x)\n    noexcept(_S_noexcept<const _It&, const _Sent&>())\n    : _M_valueless(), _M_index(__x._M_index)\n    {\n      if (_M_index == 0)\n\t{\n\t  if constexpr (is_trivially_default_constructible_v<_It>)\n\t    _M_it = std::move(__x._M_it);\n\t  else\n\t    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);\n\t}\n      else if (_M_index == 1)\n\t{\n\t  if constexpr (is_trivially_default_constructible_v<_Sent>)\n\t    _M_sent = std::move(__x._M_sent);\n\t  else\n\t    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);\n\t}\n    }\n\n    common_iterator&\n    operator=(const common_iterator& __x)\n    noexcept(is_nothrow_copy_assignable_v<_It>\n\t     && is_nothrow_copy_assignable_v<_Sent>\n\t     && is_nothrow_copy_constructible_v<_It>\n\t     && is_nothrow_copy_constructible_v<_Sent>)\n    {\n      return this->operator=<_It, _Sent>(__x);\n    }\n\n    template<typename _It2, typename _Sent2>\n      requires convertible_to<const _It2&, _It>\n\t&& convertible_to<const _Sent2&, _Sent>\n\t&& assignable_from<_It&, const _It2&>\n\t&& assignable_from<_Sent&, const _Sent2&>\n      common_iterator&\n      operator=(const common_iterator<_It2, _Sent2>& __x)\n      noexcept(is_nothrow_constructible_v<_It, const _It2&>\n\t       && is_nothrow_constructible_v<_Sent, const _Sent2&>\n\t       && is_nothrow_assignable_v<_It, const _It2&>\n\t       && is_nothrow_assignable_v<_Sent, const _Sent2&>)\n      {\n\tswitch(_M_index << 2 | __x._M_index)\n\t  {\n\t  case 0b0000:\n\t    _M_it = __x._M_it;\n\t    break;\n\t  case 0b0101:\n\t    _M_sent = __x._M_sent;\n\t    break;\n\t  case 0b0001:\n\t    _M_it.~_It();\n\t    _M_index = -1;\n\t    [[fallthrough]];\n\t  case 0b1001:\n\t    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);\n\t    _M_index = 1;\n\t    break;\n\t  case 0b0100:\n\t    _M_sent.~_Sent();\n\t    _M_index = -1;\n\t    [[fallthrough]];\n\t  case 0b1000:\n\t    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);\n\t    _M_index = 0;\n\t    break;\n\t  default:\n\t    __glibcxx_assert(__x._M_has_value());\n\t    __builtin_unreachable();\n\t  }\n\treturn *this;\n      }\n\n    ~common_iterator()\n    {\n      switch (_M_index)\n\t{\n\tcase 0:\n\t  _M_it.~_It();\n\t  break;\n\tcase 1:\n\t  _M_sent.~_Sent();\n\t  break;\n\t}\n    }\n\n    decltype(auto)\n    operator*()\n    {\n      __glibcxx_assert(_M_index == 0);\n      return *_M_it;\n    }\n\n    decltype(auto)\n    operator*() const requires __detail::__dereferenceable<const _It>\n    {\n      __glibcxx_assert(_M_index == 0);\n      return *_M_it;\n    }\n\n    decltype(auto)\n    operator->() const requires __detail::__common_iter_has_arrow<_It>\n    {\n      __glibcxx_assert(_M_index == 0);\n      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })\n\treturn _M_it;\n      else if constexpr (is_reference_v<iter_reference_t<_It>>)\n\t{\n\t  auto&& __tmp = *_M_it;\n\t  return std::__addressof(__tmp);\n\t}\n      else\n\treturn __arrow_proxy{*_M_it};\n    }\n\n    common_iterator&\n    operator++()\n    {\n      __glibcxx_assert(_M_index == 0);\n      ++_M_it;\n      return *this;\n    }\n\n    decltype(auto)\n    operator++(int)\n    {\n      __glibcxx_assert(_M_index == 0);\n      if constexpr (forward_iterator<_It>)\n\t{\n\t  common_iterator __tmp = *this;\n\t  ++*this;\n\t  return __tmp;\n\t}\n      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)\n\treturn _M_it++;\n      else\n\t{\n\t  __postfix_proxy __p(**this);\n\t  ++*this;\n\t  return __p;\n\t}\n    }\n\n    template<typename _It2, sentinel_for<_It> _Sent2>\n      requires sentinel_for<_Sent, _It2>\n      friend bool\n      operator==(const common_iterator& __x,\n\t\t const common_iterator<_It2, _Sent2>& __y)\n      {\n\tswitch(__x._M_index << 2 | __y._M_index)\n\t  {\n\t  case 0b0000:\n\t  case 0b0101:\n\t    return true;\n\t  case 0b0001:\n\t    return __x._M_it == __y._M_sent;\n\t  case 0b0100:\n\t    return __x._M_sent == __y._M_it;\n\t  default:\n\t    __glibcxx_assert(__x._M_has_value());\n\t    __glibcxx_assert(__y._M_has_value());\n\t    __builtin_unreachable();\n\t  }\n      }\n\n    template<typename _It2, sentinel_for<_It> _Sent2>\n      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>\n      friend bool\n      operator==(const common_iterator& __x,\n\t\t const common_iterator<_It2, _Sent2>& __y)\n      {\n\tswitch(__x._M_index << 2 | __y._M_index)\n\t  {\n\t  case 0b0101:\n\t    return true;\n\t  case 0b0000:\n\t    return __x._M_it == __y._M_it;\n\t  case 0b0001:\n\t    return __x._M_it == __y._M_sent;\n\t  case 0b0100:\n\t    return __x._M_sent == __y._M_it;\n\t  default:\n\t    __glibcxx_assert(__x._M_has_value());\n\t    __glibcxx_assert(__y._M_has_value());\n\t    __builtin_unreachable();\n\t  }\n      }\n\n    template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>\n      requires sized_sentinel_for<_Sent, _It2>\n      friend iter_difference_t<_It2>\n      operator-(const common_iterator& __x,\n\t\tconst common_iterator<_It2, _Sent2>& __y)\n      {\n\tswitch(__x._M_index << 2 | __y._M_index)\n\t  {\n\t  case 0b0101:\n\t    return 0;\n\t  case 0b0000:\n\t    return __x._M_it - __y._M_it;\n\t  case 0b0001:\n\t    return __x._M_it - __y._M_sent;\n\t  case 0b0100:\n\t    return __x._M_sent - __y._M_it;\n\t  default:\n\t    __glibcxx_assert(__x._M_has_value());\n\t    __glibcxx_assert(__y._M_has_value());\n\t    __builtin_unreachable();\n\t  }\n      }\n\n    friend iter_rvalue_reference_t<_It>\n    iter_move(const common_iterator& __i)\n    noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))\n    requires input_iterator<_It>\n    {\n      __glibcxx_assert(__i._M_index == 0);\n      return ranges::iter_move(__i._M_it);\n    }\n\n    template<indirectly_swappable<_It> _It2, typename _Sent2>\n      friend void\n      iter_swap(const common_iterator& __x,\n\t\tconst common_iterator<_It2, _Sent2>& __y)\n      noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),\n\t\t\t\t\t  std::declval<const _It2&>())))\n      {\n\t__glibcxx_assert(__x._M_index == 0);\n\t__glibcxx_assert(__y._M_index == 0);\n\treturn ranges::iter_swap(__x._M_it, __y._M_it);\n      }\n\n  private:\n    template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>\n      friend class common_iterator;\n\n    bool _M_has_value() const noexcept { return _M_index < 2; }\n\n    union\n    {\n      _It _M_it;\n      _Sent _M_sent;\n      unsigned char _M_valueless;\n    };\n    unsigned char _M_index; // 0==_M_it, 1==_M_sent, 2==valueless\n  };\n\n  template<typename _It, typename _Sent>\n    struct incrementable_traits<common_iterator<_It, _Sent>>\n    {\n      using difference_type = iter_difference_t<_It>;\n    };\n\n  template<input_iterator _It, typename _Sent>\n    struct iterator_traits<common_iterator<_It, _Sent>>\n    {\n    private:\n      template<typename _Iter>\n\tstruct __ptr\n\t{\n\t  using type = void;\n\t};\n\n      template<typename _Iter>\n\trequires __detail::__common_iter_has_arrow<_Iter>\n\tstruct __ptr<_Iter>\n\t{\n\t  using _CIter = common_iterator<_Iter, _Sent>;\n\t  using type = decltype(std::declval<const _CIter&>().operator->());\n\t};\n\n      static auto\n      _S_iter_cat()\n      {\n\tusing _Traits = iterator_traits<_It>;\n\tif constexpr (requires { requires derived_from<typename _Traits::iterator_category,\n\t\t\t\t\t\t       forward_iterator_tag>; })\n\t  return forward_iterator_tag{};\n\telse\n\t  return input_iterator_tag{};\n      }\n\n    public:\n      using iterator_concept = conditional_t<forward_iterator<_It>,\n\t    forward_iterator_tag, input_iterator_tag>;\n      using iterator_category = decltype(_S_iter_cat());\n      using value_type = iter_value_t<_It>;\n      using difference_type = iter_difference_t<_It>;\n      using pointer = typename __ptr<_It>::type;\n      using reference = iter_reference_t<_It>;\n    };\n\n  // [iterators.counted] Counted iterators\n\n  namespace __detail\n  {\n    template<typename _It>\n      struct __counted_iter_value_type\n      { };\n\n    template<indirectly_readable _It>\n      struct __counted_iter_value_type<_It>\n      { using value_type = iter_value_t<_It>; };\n\n    template<typename _It>\n      struct __counted_iter_concept\n      { };\n\n    template<typename _It>\n      requires requires { typename _It::iterator_concept; }\n      struct __counted_iter_concept<_It>\n      { using iterator_concept = typename _It::iterator_concept; };\n\n    template<typename _It>\n      struct __counted_iter_cat\n      { };\n\n    template<typename _It>\n      requires requires { typename _It::iterator_category; }\n      struct __counted_iter_cat<_It>\n      { using iterator_category = typename _It::iterator_category; };\n  }\n\n  /// An iterator adaptor that keeps track of the distance to the end.\n  template<input_or_output_iterator _It>\n    class counted_iterator\n      : public __detail::__counted_iter_value_type<_It>,\n\tpublic __detail::__counted_iter_concept<_It>,\n\tpublic __detail::__counted_iter_cat<_It>\n    {\n    public:\n      using iterator_type = _It;\n      // value_type defined in __counted_iter_value_type\n      using difference_type = iter_difference_t<_It>;\n      // iterator_concept defined in __counted_iter_concept\n      // iterator_category defined in __counted_iter_cat\n\n      constexpr counted_iterator() requires default_initializable<_It> = default;\n\n      constexpr\n      counted_iterator(_It __i, iter_difference_t<_It> __n)\n      : _M_current(std::move(__i)), _M_length(__n)\n      { __glibcxx_assert(__n >= 0); }\n\n      template<typename _It2>\n\trequires convertible_to<const _It2&, _It>\n\tconstexpr\n\tcounted_iterator(const counted_iterator<_It2>& __x)\n\t: _M_current(__x._M_current), _M_length(__x._M_length)\n\t{ }\n\n      template<typename _It2>\n\trequires assignable_from<_It&, const _It2&>\n\tconstexpr counted_iterator&\n\toperator=(const counted_iterator<_It2>& __x)\n\t{\n\t  _M_current = __x._M_current;\n\t  _M_length = __x._M_length;\n\t  return *this;\n\t}\n\n      constexpr const _It&\n      base() const & noexcept\n      { return _M_current; }\n\n      constexpr _It\n      base() &&\n      noexcept(is_nothrow_move_constructible_v<_It>)\n      { return std::move(_M_current); }\n\n      constexpr iter_difference_t<_It>\n      count() const noexcept { return _M_length; }\n\n      constexpr decltype(auto)\n      operator*()\n      noexcept(noexcept(*_M_current))\n      {\n\t__glibcxx_assert( _M_length > 0 );\n\treturn *_M_current;\n      }\n\n      constexpr decltype(auto)\n      operator*() const\n      noexcept(noexcept(*_M_current))\n      requires __detail::__dereferenceable<const _It>\n      {\n\t__glibcxx_assert( _M_length > 0 );\n\treturn *_M_current;\n      }\n\n      constexpr auto\n      operator->() const noexcept\n      requires contiguous_iterator<_It>\n      { return std::to_address(_M_current); }\n\n      constexpr counted_iterator&\n      operator++()\n      {\n\t__glibcxx_assert(_M_length > 0);\n\t++_M_current;\n\t--_M_length;\n\treturn *this;\n      }\n\n      decltype(auto)\n      operator++(int)\n      {\n\t__glibcxx_assert(_M_length > 0);\n\t--_M_length;\n\t__try\n\t  {\n\t    return _M_current++;\n\t  } __catch(...) {\n\t    ++_M_length;\n\t    __throw_exception_again;\n\t  }\n\n      }\n\n      constexpr counted_iterator\n      operator++(int) requires forward_iterator<_It>\n      {\n\tauto __tmp = *this;\n\t++*this;\n\treturn __tmp;\n      }\n\n      constexpr counted_iterator&\n      operator--() requires bidirectional_iterator<_It>\n      {\n\t--_M_current;\n\t++_M_length;\n\treturn *this;\n      }\n\n      constexpr counted_iterator\n      operator--(int) requires bidirectional_iterator<_It>\n      {\n\tauto __tmp = *this;\n\t--*this;\n\treturn __tmp;\n      }\n\n      constexpr counted_iterator\n      operator+(iter_difference_t<_It> __n) const\n\trequires random_access_iterator<_It>\n      { return counted_iterator(_M_current + __n, _M_length - __n); }\n\n      friend constexpr counted_iterator\n      operator+(iter_difference_t<_It> __n, const counted_iterator& __x)\n      requires random_access_iterator<_It>\n      { return __x + __n; }\n\n      constexpr counted_iterator&\n      operator+=(iter_difference_t<_It> __n)\n      requires random_access_iterator<_It>\n      {\n\t__glibcxx_assert(__n <= _M_length);\n\t_M_current += __n;\n\t_M_length -= __n;\n\treturn *this;\n      }\n\n      constexpr counted_iterator\n      operator-(iter_difference_t<_It> __n) const\n      requires random_access_iterator<_It>\n      { return counted_iterator(_M_current - __n, _M_length + __n); }\n\n      template<common_with<_It> _It2>\n\tfriend constexpr iter_difference_t<_It2>\n\toperator-(const counted_iterator& __x,\n\t\t  const counted_iterator<_It2>& __y)\n\t{ return __y._M_length - __x._M_length; }\n\n      friend constexpr iter_difference_t<_It>\n      operator-(const counted_iterator& __x, default_sentinel_t)\n      { return -__x._M_length; }\n\n      friend constexpr iter_difference_t<_It>\n      operator-(default_sentinel_t, const counted_iterator& __y)\n      { return __y._M_length; }\n\n      constexpr counted_iterator&\n      operator-=(iter_difference_t<_It> __n)\n      requires random_access_iterator<_It>\n      {\n\t__glibcxx_assert(-__n <= _M_length);\n\t_M_current -= __n;\n\t_M_length += __n;\n\treturn *this;\n      }\n\n      constexpr decltype(auto)\n      operator[](iter_difference_t<_It> __n) const\n      noexcept(noexcept(_M_current[__n]))\n      requires random_access_iterator<_It>\n      {\n\t__glibcxx_assert(__n < _M_length);\n\treturn _M_current[__n];\n      }\n\n      template<common_with<_It> _It2>\n\tfriend constexpr bool\n\toperator==(const counted_iterator& __x,\n\t\t   const counted_iterator<_It2>& __y)\n\t{ return __x._M_length == __y._M_length; }\n\n      friend constexpr bool\n      operator==(const counted_iterator& __x, default_sentinel_t)\n      { return __x._M_length == 0; }\n\n      template<common_with<_It> _It2>\n\tfriend constexpr strong_ordering\n\toperator<=>(const counted_iterator& __x,\n\t\t    const counted_iterator<_It2>& __y)\n\t{ return __y._M_length <=> __x._M_length; }\n\n      friend constexpr iter_rvalue_reference_t<_It>\n      iter_move(const counted_iterator& __i)\n      noexcept(noexcept(ranges::iter_move(__i._M_current)))\n      requires input_iterator<_It>\n      {\n\t__glibcxx_assert( __i._M_length > 0 );\n\treturn ranges::iter_move(__i._M_current);\n      }\n\n      template<indirectly_swappable<_It> _It2>\n\tfriend constexpr void\n\titer_swap(const counted_iterator& __x,\n\t\t  const counted_iterator<_It2>& __y)\n\tnoexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n\t{\n\t  __glibcxx_assert( __x._M_length > 0 && __y._M_length > 0 );\n\t  ranges::iter_swap(__x._M_current, __y._M_current);\n\t}\n\n    private:\n      template<input_or_output_iterator _It2> friend class counted_iterator;\n\n      _It _M_current = _It();\n      iter_difference_t<_It> _M_length = 0;\n    };\n\n  template<input_iterator _It>\n    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>\n    struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>\n    {\n      using pointer = conditional_t<contiguous_iterator<_It>,\n\t\t\t\t    add_pointer_t<iter_reference_t<_It>>,\n\t\t\t\t    void>;\n    };\n#endif // C++20\n\n  /// @} group iterators\n\n  template<typename _Iterator>\n    _GLIBCXX20_CONSTEXPR\n    auto\n    __niter_base(move_iterator<_Iterator> __it)\n    -> decltype(make_move_iterator(__niter_base(__it.base())))\n    { return make_move_iterator(__niter_base(__it.base())); }\n\n  template<typename _Iterator>\n    struct __is_move_iterator<move_iterator<_Iterator> >\n    {\n      enum { __value = 1 };\n      typedef __true_type __type;\n    };\n\n  template<typename _Iterator>\n    _GLIBCXX20_CONSTEXPR\n    auto\n    __miter_base(move_iterator<_Iterator> __it)\n    -> decltype(__miter_base(__it.base()))\n    { return __miter_base(__it.base()); }\n\n#define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)\n#define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \\\n  std::__make_move_if_noexcept_iterator(_Iter)\n#else\n#define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)\n#define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)\n#endif // C++11\n\n#if __cpp_deduction_guides >= 201606\n  // These helper traits are used for deduction guides\n  // of associative containers.\n  template<typename _InputIterator>\n    using __iter_key_t = remove_const_t<\n    typename iterator_traits<_InputIterator>::value_type::first_type>;\n\n  template<typename _InputIterator>\n    using __iter_val_t =\n    typename iterator_traits<_InputIterator>::value_type::second_type;\n\n  template<typename _T1, typename _T2>\n    struct pair;\n\n  template<typename _InputIterator>\n    using __iter_to_alloc_t =\n    pair<add_const_t<__iter_key_t<_InputIterator>>,\n\t __iter_val_t<_InputIterator>>;\n#endif // __cpp_deduction_guides\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#ifdef _GLIBCXX_DEBUG\n# include <debug/stl_iterator.h>\n#endif\n\n#endif\n"}],"crc32":2260047091,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]