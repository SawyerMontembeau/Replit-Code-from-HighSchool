[{"ops":[{"insert":"// RTTI support for -*- C++ -*-\n// Copyright (C) 1994-2021 Free Software Foundation, Inc.\n//\n// This file is part of GCC.\n//\n// GCC is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation; either version 3, or (at your option)\n// any later version.\n//\n// GCC is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file typeinfo\n *  This is a Standard C++ Library header.\n */\n\n#ifndef _TYPEINFO\n#define _TYPEINFO\n\n#pragma GCC system_header\n\n#include <bits/exception.h>\n#if __cplusplus >= 201103L\n#include <bits/hash_bytes.h>\n#endif\n\n#pragma GCC visibility push(default)\n\nextern \"C++\" {\n\nnamespace __cxxabiv1\n{\n  class __class_type_info;\n} // namespace __cxxabiv1\n\n// Determine whether typeinfo names for the same type are merged (in which\n// case comparison can just compare pointers) or not (in which case strings\n// must be compared), and whether comparison is to be implemented inline or\n// not.  We used to do inline pointer comparison by default if weak symbols\n// are available, but even with weak symbols sometimes names are not merged\n// when objects are loaded with RTLD_LOCAL, so now we always use strcmp by\n// default.  For ABI compatibility, we do the strcmp inline if weak symbols\n// are available, and out-of-line if not.  Out-of-line pointer comparison\n// is used where the object files are to be portable to multiple systems,\n// some of which may not be able to use pointer comparison, but the\n// particular system for which libstdc++ is being built can use pointer\n// comparison; in particular for most ARM EABI systems, where the ABI\n// specifies out-of-line comparison.  The compiler's target configuration\n// can override the defaults by defining __GXX_TYPEINFO_EQUALITY_INLINE to\n// 1 or 0 to indicate whether or not comparison is inline, and\n// __GXX_MERGED_TYPEINFO_NAMES to 1 or 0 to indicate whether or not pointer\n// comparison can be used.\n\n#ifndef __GXX_MERGED_TYPEINFO_NAMES\n// By default, typeinfo names are not merged.\n#define __GXX_MERGED_TYPEINFO_NAMES 0\n#endif\n\n// By default follow the old inline rules to avoid ABI changes.\n#ifndef __GXX_TYPEINFO_EQUALITY_INLINE\n  #if !__GXX_WEAK__\n    #define __GXX_TYPEINFO_EQUALITY_INLINE 0\n  #else\n    #define __GXX_TYPEINFO_EQUALITY_INLINE 1\n  #endif\n#endif\n\nnamespace std\n{\n  /**\n   *  @brief  Part of RTTI.\n   *\n   *  The @c type_info class describes type information generated by\n   *  an implementation.\n  */\n  class type_info\n  {\n  public:\n    /** Destructor first. Being the first non-inline virtual function, this\n     *  controls in which translation unit the vtable is emitted. The\n     *  compiler makes use of that information to know where to emit\n     *  the runtime-mandated type_info structures in the new-abi.  */\n    virtual ~type_info();\n\n    /** Returns an @e implementation-defined byte string; this is not\n     *  portable between compilers!  */\n    const char* name() const _GLIBCXX_NOEXCEPT\n    { return __name[0] == '*' ? __name + 1 : __name; }\n\n#if !__GXX_TYPEINFO_EQUALITY_INLINE\n    // In old abi, or when weak symbols are not supported, there can\n    // be multiple instances of a type_info object for one\n    // type. Uniqueness must use the _name value, not object address.\n    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT;\n    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT;\n#else\n  #if !__GXX_MERGED_TYPEINFO_NAMES\n    /** Returns true if @c *this precedes @c __arg in the implementation's\n     *  collation order.  */\n    // Even with the new abi, on systems that support dlopen\n    // we can run into cases where type_info names aren't merged,\n    // so we still need to do string comparison.\n    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n    { return (__name[0] == '*' && __arg.__name[0] == '*')\n\t? __name < __arg.__name\n\t: __builtin_strcmp (__name, __arg.__name) < 0; }\n\n    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n    {\n      return ((__name == __arg.__name)\n\t      || (__name[0] != '*' &&\n\t\t  __builtin_strcmp (__name, __arg.__name) == 0));\n    }\n  #else\n    // On some targets we can rely on type_info's NTBS being unique,\n    // and therefore address comparisons are sufficient.\n    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n    { return __name < __arg.__name; }\n\n    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n    { return __name == __arg.__name; }\n  #endif\n#endif\n\n#if __cpp_impl_three_way_comparison < 201907L\n    bool operator!=(const type_info& __arg) const _GLIBCXX_NOEXCEPT\n    { return !operator==(__arg); }\n#endif\n\n#if __cplusplus >= 201103L\n    size_t hash_code() const noexcept\n    {\n#  if !__GXX_MERGED_TYPEINFO_NAMES\n      return _Hash_bytes(name(), __builtin_strlen(name()),\n\t\t\t static_cast<size_t>(0xc70f6907UL));\n#  else\n      return reinterpret_cast<size_t>(__name);\n#  endif\n    }\n#endif // C++11\n\n    // Return true if this is a pointer type of some kind\n    virtual bool __is_pointer_p() const;\n\n    // Return true if this is a function type\n    virtual bool __is_function_p() const;\n\n    // Try and catch a thrown type. Store an adjusted pointer to the\n    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then\n    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer\n    // type, then THR_OBJ is the pointer itself. OUTER indicates the\n    // number of outer pointers, and whether they were const\n    // qualified.\n    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,\n\t\t\t    unsigned __outer) const;\n\n    // Internally used during catch matching\n    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,\n\t\t\t     void **__obj_ptr) const;\n\n  protected:\n    const char *__name;\n\n    explicit type_info(const char *__n): __name(__n) { }\n\n  private:\n    /// Assigning type_info is not supported.\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n  };\n\n  /**\n   *  @brief  Thrown during incorrect typecasting.\n   *  @ingroup exceptions\n   *\n   *  If you attempt an invalid @c dynamic_cast expression, an instance of\n   *  this class (or something derived from this class) is thrown.  */\n  class bad_cast : public exception\n  {\n  public:\n    bad_cast() _GLIBCXX_USE_NOEXCEPT { }\n\n    // This declaration is not useless:\n    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118\n    virtual ~bad_cast() _GLIBCXX_USE_NOEXCEPT;\n\n    // See comment in eh_exception.cc.\n    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;\n  };\n\n  /**\n   *  @brief Thrown when a NULL pointer in a @c typeid expression is used.\n   *  @ingroup exceptions\n   */\n  class bad_typeid : public exception\n  {\n  public:\n    bad_typeid () _GLIBCXX_USE_NOEXCEPT { }\n\n    // This declaration is not useless:\n    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118\n    virtual ~bad_typeid() _GLIBCXX_USE_NOEXCEPT;\n\n    // See comment in eh_exception.cc.\n    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;\n  };\n} // namespace std\n\n} // extern \"C++\"\n\n#pragma GCC visibility pop\n\n#endif\n"}],"crc32":1217049161,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]