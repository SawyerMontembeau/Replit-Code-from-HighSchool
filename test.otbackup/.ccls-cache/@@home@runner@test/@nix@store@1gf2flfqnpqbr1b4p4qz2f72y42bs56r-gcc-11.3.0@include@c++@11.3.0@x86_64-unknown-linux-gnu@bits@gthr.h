[{"ops":[{"insert":"/* Threads compatibility routines for libgcc2.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997-2021 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 3, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nUnder Section 7 of GPL version 3, you are granted additional\npermissions described in the GCC Runtime Library Exception, version\n3.1, as published by the Free Software Foundation.\n\nYou should have received a copy of the GNU General Public License and\na copy of the GCC Runtime Library Exception along with this program;\nsee the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n<http://www.gnu.org/licenses/>.  */\n\n#ifndef _GLIBCXX_GCC_GTHR_H\n#define _GLIBCXX_GCC_GTHR_H\n\n#ifndef _GLIBCXX_HIDE_EXPORTS\n#pragma GCC visibility push(default)\n#endif\n\n/* If this file is compiled with threads support, it must\n       #define __GTHREADS 1\n   to indicate that threads support is present.  Also it has define\n   function\n     int __gthread_active_p ()\n   that returns 1 if thread system is active, 0 if not.\n\n   The threads interface must define the following types:\n     __gthread_key_t\n     __gthread_once_t\n     __gthread_mutex_t\n     __gthread_recursive_mutex_t\n\n   The threads interface must define the following macros:\n\n     __GTHREAD_ONCE_INIT\n     \t\tto initialize __gthread_once_t\n     __GTHREAD_MUTEX_INIT\n     \t\tto initialize __gthread_mutex_t to get a fast\n\t\tnon-recursive mutex.\n     __GTHREAD_MUTEX_INIT_FUNCTION\n\t\tto initialize __gthread_mutex_t to get a fast\n\t\tnon-recursive mutex.\n\t\tDefine this to a function which looks like this:\n\t\t  void __GTHREAD_MUTEX_INIT_FUNCTION (__gthread_mutex_t *)\n     \t\tSome systems can't initialize a mutex without a\n\t\tfunction call.  Don't define __GTHREAD_MUTEX_INIT in this case.\n     __GTHREAD_RECURSIVE_MUTEX_INIT\n     __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION\n     \t\tas above, but for a recursive mutex.\n\n   The threads interface must define the following static functions:\n\n     int __gthread_once (__gthread_once_t *once, void (*func) ())\n\n     int __gthread_key_create (__gthread_key_t *keyp, void (*dtor) (void *))\n     int __gthread_key_delete (__gthread_key_t key)\n\n     void *__gthread_getspecific (__gthread_key_t key)\n     int __gthread_setspecific (__gthread_key_t key, const void *ptr)\n\n     int __gthread_mutex_destroy (__gthread_mutex_t *mutex);\n     int __gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *mutex);\n\n     int __gthread_mutex_lock (__gthread_mutex_t *mutex);\n     int __gthread_mutex_trylock (__gthread_mutex_t *mutex);\n     int __gthread_mutex_unlock (__gthread_mutex_t *mutex);\n\n     int __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex);\n     int __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex);\n     int __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex);\n\n   The following are supported in POSIX threads only. They are required to\n   fix a deadlock in static initialization inside libsupc++. The header file\n   gthr-posix.h defines a symbol __GTHREAD_HAS_COND to signify that these extra\n   features are supported.\n\n   Types:\n     __gthread_cond_t\n\n   Macros:\n     __GTHREAD_COND_INIT\n     __GTHREAD_COND_INIT_FUNCTION\n\n   Interface:\n     int __gthread_cond_broadcast (__gthread_cond_t *cond);\n     int __gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex);\n     int __gthread_cond_wait_recursive (__gthread_cond_t *cond,\n\t\t\t\t\t__gthread_recursive_mutex_t *mutex);\n\n   All functions returning int should return zero on success or the error\n   number.  If the operation is not supported, -1 is returned.\n\n   If the following are also defined, you should\n     #define __GTHREADS_CXX0X 1\n   to enable the c++0x thread library.\n\n   Types:\n     __gthread_t\n     __gthread_time_t\n\n   Interface:\n     int __gthread_create (__gthread_t *thread, void *(*func) (void*),\n                           void *args);\n     int __gthread_join (__gthread_t thread, void **value_ptr);\n     int __gthread_detach (__gthread_t thread);\n     int __gthread_equal (__gthread_t t1, __gthread_t t2);\n     __gthread_t __gthread_self (void);\n     int __gthread_yield (void);\n\n     int __gthread_mutex_timedlock (__gthread_mutex_t *m,\n                                    const __gthread_time_t *abs_timeout);\n     int __gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *m,\n                                          const __gthread_time_t *abs_time);\n\n     int __gthread_cond_signal (__gthread_cond_t *cond);\n     int __gthread_cond_timedwait (__gthread_cond_t *cond,\n                                   __gthread_mutex_t *mutex,\n                                   const __gthread_time_t *abs_timeout);\n\n*/\n\n#if __GXX_WEAK__\n/* The pe-coff weak support isn't fully compatible to ELF's weak.\n   For static libraries it might would work, but as we need to deal\n   with shared versions too, we disable it for mingw-targets.  */\n#ifdef __MINGW32__\n#undef _GLIBCXX_GTHREAD_USE_WEAK\n#define _GLIBCXX_GTHREAD_USE_WEAK 0\n#endif\n\n#ifndef _GLIBCXX_GTHREAD_USE_WEAK\n#define _GLIBCXX_GTHREAD_USE_WEAK 1\n#endif\n#endif\n#include <bits/gthr-default.h>\n\n#ifndef _GLIBCXX_HIDE_EXPORTS\n#pragma GCC visibility pop\n#endif\n\n#endif /* ! _GLIBCXX_GCC_GTHR_H */\n"}],"crc32":1931273975,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]