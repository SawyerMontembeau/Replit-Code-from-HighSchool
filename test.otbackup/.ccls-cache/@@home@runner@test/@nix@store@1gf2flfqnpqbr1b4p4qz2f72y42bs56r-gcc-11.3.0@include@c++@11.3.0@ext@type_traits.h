[{"ops":[{"insert":"// -*- C++ -*-\n\n// Copyright (C) 2005-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the terms\n// of the GNU General Public License as published by the Free Software\n// Foundation; either version 3, or (at your option) any later\n// version.\n\n// This library is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file ext/type_traits.h\n *  This file is a GNU extension to the Standard C++ Library.\n */\n\n#ifndef _EXT_TYPE_TRAITS\n#define _EXT_TYPE_TRAITS 1\n\n#pragma GCC system_header\n\n#include <bits/c++config.h>\n#include <bits/cpp_type_traits.h>\n\nextern \"C++\" {\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // Define a nested type if some predicate holds.\n  template<bool, typename>\n    struct __enable_if \n    { };\n\n  template<typename _Tp>\n    struct __enable_if<true, _Tp>\n    { typedef _Tp __type; };\n\n\n  // Conditional expression for types. If true, first, if false, second.\n  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n    struct __conditional_type\n    { typedef _Iftrue __type; };\n\n  template<typename _Iftrue, typename _Iffalse>\n    struct __conditional_type<false, _Iftrue, _Iffalse>\n    { typedef _Iffalse __type; };\n\n\n  // Given an integral builtin type, return the corresponding unsigned type.\n  template<typename _Tp>\n    struct __add_unsigned\n    { \n    private:\n      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;\n      \n    public:\n      typedef typename __if_type::__type __type; \n    };\n\n  template<>\n    struct __add_unsigned<char>\n    { typedef unsigned char __type; };\n\n  template<>\n    struct __add_unsigned<signed char>\n    { typedef unsigned char __type; };\n\n  template<>\n    struct __add_unsigned<short>\n    { typedef unsigned short __type; };\n\n  template<>\n    struct __add_unsigned<int>\n    { typedef unsigned int __type; };\n\n  template<>\n    struct __add_unsigned<long>\n    { typedef unsigned long __type; };\n\n  template<>\n    struct __add_unsigned<long long>\n    { typedef unsigned long long __type; };\n\n  // Declare but don't define.\n  template<>\n    struct __add_unsigned<bool>;\n\n  template<>\n    struct __add_unsigned<wchar_t>;\n\n\n  // Given an integral builtin type, return the corresponding signed type.\n  template<typename _Tp>\n    struct __remove_unsigned\n    { \n    private:\n      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;\n      \n    public:\n      typedef typename __if_type::__type __type; \n    };\n\n  template<>\n    struct __remove_unsigned<char>\n    { typedef signed char __type; };\n\n  template<>\n    struct __remove_unsigned<unsigned char>\n    { typedef signed char __type; };\n\n  template<>\n    struct __remove_unsigned<unsigned short>\n    { typedef short __type; };\n\n  template<>\n    struct __remove_unsigned<unsigned int>\n    { typedef int __type; };\n\n  template<>\n    struct __remove_unsigned<unsigned long>\n    { typedef long __type; };\n\n  template<>\n    struct __remove_unsigned<unsigned long long>\n    { typedef long long __type; };\n\n  // Declare but don't define.\n  template<>\n    struct __remove_unsigned<bool>;\n\n  template<>\n    struct __remove_unsigned<wchar_t>;\n\n\n  // For use in string and vstring.\n  template<typename _Type>\n    inline bool\n    __is_null_pointer(_Type* __ptr)\n    { return __ptr == 0; }\n\n  template<typename _Type>\n    inline bool\n    __is_null_pointer(_Type)\n    { return false; }\n\n#if __cplusplus >= 201103L\n  inline bool\n  __is_null_pointer(std::nullptr_t)\n  { return true; }\n#endif\n\n  // For arithmetic promotions in <complex> and <cmath>\n\n  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>\n    struct __promote\n    { typedef double __type; };\n\n  // No nested __type member for non-integer non-floating point types,\n  // allows this type to be used for SFINAE to constrain overloads in\n  // <cmath> and <complex> to only the intended types.\n  template<typename _Tp>\n    struct __promote<_Tp, false>\n    { };\n\n  template<>\n    struct __promote<long double>\n    { typedef long double __type; };\n\n  template<>\n    struct __promote<double>\n    { typedef double __type; };\n\n  template<>\n    struct __promote<float>\n    { typedef float __type; };\n\n#if __cpp_fold_expressions\n  template<typename... _Tp>\n    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));\n#endif\n\n  template<typename _Tp, typename _Up,\n           typename _Tp2 = typename __promote<_Tp>::__type,\n           typename _Up2 = typename __promote<_Up>::__type>\n    struct __promote_2\n    {\n      typedef __typeof__(_Tp2() + _Up2()) __type;\n    };\n\n  template<typename _Tp, typename _Up, typename _Vp,\n           typename _Tp2 = typename __promote<_Tp>::__type,\n           typename _Up2 = typename __promote<_Up>::__type,\n           typename _Vp2 = typename __promote<_Vp>::__type>\n    struct __promote_3\n    {\n      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;\n    };\n\n  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,\n           typename _Tp2 = typename __promote<_Tp>::__type,\n           typename _Up2 = typename __promote<_Up>::__type,\n           typename _Vp2 = typename __promote<_Vp>::__type,\n           typename _Wp2 = typename __promote<_Wp>::__type>\n    struct __promote_4\n    {\n      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n} // extern \"C++\"\n\n#endif \n"}],"crc32":385638236,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]