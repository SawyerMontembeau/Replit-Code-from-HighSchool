[{"ops":[{"insert":"// Allocator traits -*- C++ -*-\n\n// Copyright (C) 2011-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/alloc_traits.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _ALLOC_TRAITS_H\n#define _ALLOC_TRAITS_H 1\n\n#include <bits/stl_construct.h>\n#include <bits/memoryfwd.h>\n#if __cplusplus >= 201103L\n# include <bits/allocator.h>\n# include <bits/ptr_traits.h>\n# include <ext/numeric_traits.h>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus >= 201103L\n#define __cpp_lib_allocator_traits_is_always_equal 201411\n\n  /// @cond undocumented\n  struct __allocator_traits_base\n  {\n    template<typename _Tp, typename _Up, typename = void>\n      struct __rebind : __replace_first_arg<_Tp, _Up> { };\n\n    template<typename _Tp, typename _Up>\n      struct __rebind<_Tp, _Up,\n\t\t      __void_t<typename _Tp::template rebind<_Up>::other>>\n      { using type = typename _Tp::template rebind<_Up>::other; };\n\n  protected:\n    template<typename _Tp>\n      using __pointer = typename _Tp::pointer;\n    template<typename _Tp>\n      using __c_pointer = typename _Tp::const_pointer;\n    template<typename _Tp>\n      using __v_pointer = typename _Tp::void_pointer;\n    template<typename _Tp>\n      using __cv_pointer = typename _Tp::const_void_pointer;\n    template<typename _Tp>\n      using __pocca = typename _Tp::propagate_on_container_copy_assignment;\n    template<typename _Tp>\n      using __pocma = typename _Tp::propagate_on_container_move_assignment;\n    template<typename _Tp>\n      using __pocs = typename _Tp::propagate_on_container_swap;\n    template<typename _Tp>\n      using __equal = typename _Tp::is_always_equal;\n  };\n\n  template<typename _Alloc, typename _Up>\n    using __alloc_rebind\n      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;\n  /// @endcond\n\n  /**\n   * @brief  Uniform interface to all allocator types.\n   * @headerfile memory\n   * @ingroup allocators\n   * @since C++11\n  */\n  template<typename _Alloc>\n    struct allocator_traits : __allocator_traits_base\n    {\n      /// The allocator type\n      typedef _Alloc allocator_type;\n      /// The allocated type\n      typedef typename _Alloc::value_type value_type;\n\n      /**\n       * @brief   The allocator's pointer type.\n       *\n       * @c Alloc::pointer if that type exists, otherwise @c value_type*\n      */\n      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;\n\n    private:\n      // Select _Func<_Alloc> or pointer_traits<pointer>::rebind<_Tp>\n      template<template<typename> class _Func, typename _Tp, typename = void>\n\tstruct _Ptr\n\t{\n\t  using type = typename pointer_traits<pointer>::template rebind<_Tp>;\n\t};\n\n      template<template<typename> class _Func, typename _Tp>\n\tstruct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>\n\t{\n\t  using type = _Func<_Alloc>;\n\t};\n\n      // Select _A2::difference_type or pointer_traits<_Ptr>::difference_type\n      template<typename _A2, typename _PtrT, typename = void>\n\tstruct _Diff\n\t{ using type = typename pointer_traits<_PtrT>::difference_type; };\n\n      template<typename _A2, typename _PtrT>\n\tstruct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>\n\t{ using type = typename _A2::difference_type; };\n\n      // Select _A2::size_type or make_unsigned<_DiffT>::type\n      template<typename _A2, typename _DiffT, typename = void>\n\tstruct _Size : make_unsigned<_DiffT> { };\n\n      template<typename _A2, typename _DiffT>\n\tstruct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>\n\t{ using type = typename _A2::size_type; };\n\n    public:\n      /**\n       * @brief   The allocator's const pointer type.\n       *\n       * @c Alloc::const_pointer if that type exists, otherwise\n       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>\n      */\n      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;\n\n      /**\n       * @brief   The allocator's void pointer type.\n       *\n       * @c Alloc::void_pointer if that type exists, otherwise\n       * <tt> pointer_traits<pointer>::rebind<void> </tt>\n      */\n      using void_pointer = typename _Ptr<__v_pointer, void>::type;\n\n      /**\n       * @brief   The allocator's const void pointer type.\n       *\n       * @c Alloc::const_void_pointer if that type exists, otherwise\n       * <tt> pointer_traits<pointer>::rebind<const void> </tt>\n      */\n      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;\n\n      /**\n       * @brief   The allocator's difference type\n       *\n       * @c Alloc::difference_type if that type exists, otherwise\n       * <tt> pointer_traits<pointer>::difference_type </tt>\n      */\n      using difference_type = typename _Diff<_Alloc, pointer>::type;\n\n      /**\n       * @brief   The allocator's size type\n       *\n       * @c Alloc::size_type if that type exists, otherwise\n       * <tt> make_unsigned<difference_type>::type </tt>\n      */\n      using size_type = typename _Size<_Alloc, difference_type>::type;\n\n      /**\n       * @brief   How the allocator is propagated on copy assignment\n       *\n       * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_copy_assignment\n\t= __detected_or_t<false_type, __pocca, _Alloc>;\n\n      /**\n       * @brief   How the allocator is propagated on move assignment\n       *\n       * @c Alloc::propagate_on_container_move_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_move_assignment\n\t= __detected_or_t<false_type, __pocma, _Alloc>;\n\n      /**\n       * @brief   How the allocator is propagated on swap\n       *\n       * @c Alloc::propagate_on_container_swap if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_swap\n\t= __detected_or_t<false_type, __pocs, _Alloc>;\n\n      /**\n       * @brief   Whether all instances of the allocator type compare equal.\n       *\n       * @c Alloc::is_always_equal if that type exists,\n       * otherwise @c is_empty<Alloc>::type\n      */\n      using is_always_equal\n\t= __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;\n\n      template<typename _Tp>\n\tusing rebind_alloc = __alloc_rebind<_Alloc, _Tp>;\n      template<typename _Tp>\n\tusing rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n\n    private:\n      template<typename _Alloc2>\n\tstatic constexpr auto\n\t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)\n\t-> decltype(__a.allocate(__n, __hint))\n\t{ return __a.allocate(__n, __hint); }\n\n      template<typename _Alloc2>\n\tstatic constexpr pointer\n\t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)\n\t{ return __a.allocate(__n); }\n\n      template<typename _Tp, typename... _Args>\n\tstruct __construct_helper\n\t{\n\t  template<typename _Alloc2,\n\t    typename = decltype(std::declval<_Alloc2*>()->construct(\n\t\t  std::declval<_Tp*>(), std::declval<_Args>()...))>\n\t    static true_type __test(int);\n\n\t  template<typename>\n\t    static false_type __test(...);\n\n\t  using type = decltype(__test<_Alloc>(0));\n\t};\n\n      template<typename _Tp, typename... _Args>\n\tusing __has_construct\n\t  = typename __construct_helper<_Tp, _Args...>::type;\n\n      template<typename _Tp, typename... _Args>\n\tstatic _GLIBCXX14_CONSTEXPR _Require<__has_construct<_Tp, _Args...>>\n\t_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n\tnoexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))\n\t{ __a.construct(__p, std::forward<_Args>(__args)...); }\n\n      template<typename _Tp, typename... _Args>\n\tstatic _GLIBCXX14_CONSTEXPR\n\t_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,\n\t\t\t       is_constructible<_Tp, _Args...>>>\n\t_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n\tnoexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)\n\t{\n#if __cplusplus <= 201703L\n\t  ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);\n#else\n\t  std::construct_at(__p, std::forward<_Args>(__args)...);\n#endif\n\t}\n\n      template<typename _Alloc2, typename _Tp>\n\tstatic _GLIBCXX14_CONSTEXPR auto\n\t_S_destroy(_Alloc2& __a, _Tp* __p, int)\n\tnoexcept(noexcept(__a.destroy(__p)))\n\t-> decltype(__a.destroy(__p))\n\t{ __a.destroy(__p); }\n\n      template<typename _Alloc2, typename _Tp>\n\tstatic _GLIBCXX14_CONSTEXPR void\n\t_S_destroy(_Alloc2&, _Tp* __p, ...)\n\tnoexcept(std::is_nothrow_destructible<_Tp>::value)\n\t{ std::_Destroy(__p); }\n\n      template<typename _Alloc2>\n\tstatic constexpr auto\n\t_S_max_size(_Alloc2& __a, int)\n\t-> decltype(__a.max_size())\n\t{ return __a.max_size(); }\n\n      template<typename _Alloc2>\n\tstatic constexpr size_type\n\t_S_max_size(_Alloc2&, ...)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2466. allocator_traits::max_size() default behavior is incorrect\n\t  return __gnu_cxx::__numeric_traits<size_type>::__max\n\t    / sizeof(value_type);\n\t}\n\n      template<typename _Alloc2>\n\tstatic constexpr auto\n\t_S_select(_Alloc2& __a, int)\n\t-> decltype(__a.select_on_container_copy_construction())\n\t{ return __a.select_on_container_copy_construction(); }\n\n      template<typename _Alloc2>\n\tstatic constexpr _Alloc2\n\t_S_select(_Alloc2& __a, ...)\n\t{ return __a; }\n\n    public:\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc& __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is\n       *  well-formed, otherwise returns @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)\n      { return _S_allocate(__a, __n, __hint, 0); }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls <tt> a.deallocate(p, n) </tt>\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(_Alloc& __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Tp`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for Tp\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>\n       *  if that expression is well-formed, otherwise uses placement-new\n       *  to construct an object of type @a _Tp at location @a __p from the\n       *  arguments @a __args...\n      */\n      template<typename _Tp, typename... _Args>\n\tstatic _GLIBCXX20_CONSTEXPR auto\n\tconstruct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n\tnoexcept(noexcept(_S_construct(__a, __p,\n\t\t\t\t       std::forward<_Args>(__args)...)))\n\t-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))\n\t{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type @a _Tp\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p) if that expression is well-formed,\n       *  otherwise calls @c __p->~_Tp()\n      */\n      template<typename _Tp>\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(_Alloc& __a, _Tp* __p)\n\tnoexcept(noexcept(_S_destroy(__a, __p, 0)))\n\t{ _S_destroy(__a, __p, 0); }\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size() or @c numeric_limits<size_type>::max()\n       *\n       *  Returns @c __a.max_size() if that expression is well-formed,\n       *  otherwise returns @c numeric_limits<size_type>::max()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const _Alloc& __a) noexcept\n      { return _S_max_size(__a, 0); }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs\n       *\n       *  Returns @c __rhs.select_on_container_copy_construction() if that\n       *  expression is well-formed, otherwise returns @a __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR _Alloc\n      select_on_container_copy_construction(const _Alloc& __rhs)\n      { return _S_select(__rhs, 0); }\n    };\n\n#if __cplusplus > 201703L\n# define __cpp_lib_constexpr_dynamic_alloc 201907L\n#endif\n\n  /// Partial specialization for std::allocator.\n  template<typename _Tp>\n    struct allocator_traits<allocator<_Tp>>\n    {\n      /// The allocator type\n      using allocator_type = allocator<_Tp>;\n\n      /// The allocated type\n      using value_type = _Tp;\n\n      /// The allocator's pointer type.\n      using pointer = _Tp*;\n\n      /// The allocator's const pointer type.\n      using const_pointer = const _Tp*;\n\n      /// The allocator's void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator's const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator's difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator's size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template<typename _Up>\n\tusing rebind_alloc = allocator<_Up>;\n\n      template<typename _Up>\n\tusing rebind_traits = allocator_traits<allocator<_Up>>;\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type& __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns <tt> a.allocate(n, hint) </tt>\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n      {\n#if __cplusplus <= 201703L\n\treturn __a.allocate(__n, __hint);\n#else\n\treturn __a.allocate(__n);\n#endif\n      }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls <tt> a.deallocate(p, n) </tt>\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(allocator_type& __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.\n      */\n      template<typename _Up, typename... _Args>\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type& __a __attribute__((__unused__)), _Up* __p,\n\t\t  _Args&&... __args)\n\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n\t{\n#if __cplusplus <= 201703L\n\t  __a.construct(__p, std::forward<_Args>(__args)...);\n#else\n\t  std::construct_at(__p, std::forward<_Args>(__args)...);\n#endif\n\t}\n\n      /**\n       *  @brief  Destroy an object of type @a _Up\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p).\n      */\n      template<typename _Up>\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)\n\tnoexcept(is_nothrow_destructible<_Up>::value)\n\t{\n#if __cplusplus <= 201703L\n\t  __a.destroy(__p);\n#else\n\t  std::destroy_at(__p);\n#endif\n\t}\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept\n      {\n#if __cplusplus <= 201703L\n\treturn __a.max_size();\n#else\n\treturn size_t(-1) / sizeof(value_type);\n#endif\n      }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type& __rhs)\n      { return __rhs; }\n    };\n\n  /// Explicit specialization for std::allocator<void>.\n  template<>\n    struct allocator_traits<allocator<void>>\n    {\n      /// The allocator type\n      using allocator_type = allocator<void>;\n\n      /// The allocated type\n      using value_type = void;\n\n      /// The allocator's pointer type.\n      using pointer = void*;\n\n      /// The allocator's const pointer type.\n      using const_pointer = const void*;\n\n      /// The allocator's void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator's const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator's difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator's size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template<typename _Up>\n\tusing rebind_alloc = allocator<_Up>;\n\n      template<typename _Up>\n\tusing rebind_traits = allocator_traits<allocator<_Up>>;\n\n      /// allocate is ill-formed for allocator<void>\n      static void*\n      allocate(allocator_type&, size_type, const void* = nullptr) = delete;\n\n      /// deallocate is ill-formed for allocator<void>\n      static void\n      deallocate(allocator_type&, void*, size_type) = delete;\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.\n      */\n      template<typename _Up, typename... _Args>\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&, _Up* __p, _Args&&... __args)\n\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n\t{ std::_Construct(__p, std::forward<_Args>(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Invokes the destructor for `*__p`.\n      */\n      template<typename _Up>\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&, _Up* __p)\n\tnoexcept(is_nothrow_destructible<_Up>::value)\n\t{ std::_Destroy(__p); }\n\n      /// max_size is ill-formed for allocator<void>\n      static size_type\n      max_size(const allocator_type&) = delete;\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return `__rhs`\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type& __rhs)\n      { return __rhs; }\n    };\n\n#if __cplusplus < 201703L\n  template<typename _Alloc>\n    inline void\n    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)\n    { __one = __two; }\n\n  template<typename _Alloc>\n    inline void\n    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)\n    { }\n#endif\n\n  template<typename _Alloc>\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)\n    {\n      typedef allocator_traits<_Alloc> __traits;\n      typedef typename __traits::propagate_on_container_copy_assignment __pocca;\n#if __cplusplus >= 201703L\n      if constexpr (__pocca::value)\n\t__one = __two;\n#else\n      __do_alloc_on_copy(__one, __two, __pocca());\n#endif\n    }\n\n  template<typename _Alloc>\n    constexpr _Alloc\n    __alloc_on_copy(const _Alloc& __a)\n    {\n      typedef allocator_traits<_Alloc> __traits;\n      return __traits::select_on_container_copy_construction(__a);\n    }\n\n#if __cplusplus < 201703L\n  template<typename _Alloc>\n    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)\n    { __one = std::move(__two); }\n\n  template<typename _Alloc>\n    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)\n    { }\n#endif\n\n  template<typename _Alloc>\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_move(_Alloc& __one, _Alloc& __two)\n    {\n      typedef allocator_traits<_Alloc> __traits;\n      typedef typename __traits::propagate_on_container_move_assignment __pocma;\n#if __cplusplus >= 201703L\n      if constexpr (__pocma::value)\n\t__one = std::move(__two);\n#else\n      __do_alloc_on_move(__one, __two, __pocma());\n#endif\n    }\n\n#if __cplusplus < 201703L\n  template<typename _Alloc>\n    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)\n    {\n      using std::swap;\n      swap(__one, __two);\n    }\n\n  template<typename _Alloc>\n    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)\n    { }\n#endif\n\n  template<typename _Alloc>\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_swap(_Alloc& __one, _Alloc& __two)\n    {\n      typedef allocator_traits<_Alloc> __traits;\n      typedef typename __traits::propagate_on_container_swap __pocs;\n#if __cplusplus >= 201703L\n      if constexpr (__pocs::value)\n\t{\n\t  using std::swap;\n\t  swap(__one, __two);\n\t}\n#else\n      __do_alloc_on_swap(__one, __two, __pocs());\n#endif\n    }\n\n  template<typename _Alloc, typename _Tp,\n\t   typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,\n\t   typename = void>\n    struct __is_alloc_insertable_impl\n    : false_type\n    { };\n\n  template<typename _Alloc, typename _Tp, typename _ValueT>\n    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,\n      __void_t<decltype(allocator_traits<_Alloc>::construct(\n\t\t   std::declval<_Alloc&>(), std::declval<_ValueT*>(),\n\t\t   std::declval<_Tp>()))>>\n    : true_type\n    { };\n\n  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template<typename _Alloc>\n    struct __is_copy_insertable\n    : __is_alloc_insertable_impl<_Alloc,\n\t\t\t\t typename _Alloc::value_type const&>::type\n    { };\n\n  // std::allocator<_Tp> just requires CopyConstructible\n  template<typename _Tp>\n    struct __is_copy_insertable<allocator<_Tp>>\n    : is_copy_constructible<_Tp>\n    { };\n\n  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template<typename _Alloc>\n    struct __is_move_insertable\n    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type\n    { };\n\n  // std::allocator<_Tp> just requires MoveConstructible\n  template<typename _Tp>\n    struct __is_move_insertable<allocator<_Tp>>\n    : is_move_constructible<_Tp>\n    { };\n\n  // Trait to detect Allocator-like types.\n  template<typename _Alloc, typename = void>\n    struct __is_allocator : false_type { };\n\n  template<typename _Alloc>\n    struct __is_allocator<_Alloc,\n      __void_t<typename _Alloc::value_type,\n\t       decltype(std::declval<_Alloc&>().allocate(size_t{}))>>\n    : true_type { };\n\n  template<typename _Alloc>\n    using _RequireAllocator\n      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;\n\n  template<typename _Alloc>\n    using _RequireNotAllocator\n      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;\n\n#if __cpp_concepts >= 201907L\n  template<typename _Alloc>\n    concept __allocator_like = requires (_Alloc& __a) {\n      typename _Alloc::value_type;\n      __a.deallocate(__a.allocate(1u), 1u);\n    };\n#endif\n#endif // C++11\n\n  /**\n   * Destroy a range of objects using the supplied allocator.  For\n   * non-default allocators we do not optimize away invocation of\n   * destroy() even if _Tp has a trivial destructor.\n   */\n\n  template<typename _ForwardIterator, typename _Allocator>\n    void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     _Allocator& __alloc)\n    {\n      for (; __first != __last; ++__first)\n#if __cplusplus < 201103L\n\t__alloc.destroy(std::__addressof(*__first));\n#else\n\tallocator_traits<_Allocator>::destroy(__alloc,\n\t\t\t\t\t      std::__addressof(*__first));\n#endif\n    }\n\n  template<typename _ForwardIterator, typename _Tp>\n    inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     allocator<_Tp>&)\n    {\n      _Destroy(__first, __last);\n    }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // _ALLOC_TRAITS_H\n"}],"crc32":1797464664,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]