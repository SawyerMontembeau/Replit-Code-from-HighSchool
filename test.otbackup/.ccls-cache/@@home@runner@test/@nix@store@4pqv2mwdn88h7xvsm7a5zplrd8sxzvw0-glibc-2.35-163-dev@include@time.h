[{"ops":[{"insert":"/* Copyright (C) 1991-2022 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n/*\n *\tISO C99 Standard: 7.23 Date and time\t<time.h>\n */\n\n#ifndef\t_TIME_H\n#define _TIME_H\t1\n\n#include <features.h>\n\n#define __need_size_t\n#define __need_NULL\n#include <stddef.h>\n\n/* This defines CLOCKS_PER_SEC, which is the number of processor clock\n   ticks per second, and possibly a number of other constants.   */\n#include <bits/time.h>\n\n/* Many of the typedefs and structs whose official home is this header\n   may also need to be defined by other headers.  */\n#include <bits/types/clock_t.h>\n#include <bits/types/time_t.h>\n#include <bits/types/struct_tm.h>\n\n#if defined __USE_POSIX199309 || defined __USE_ISOC11\n# include <bits/types/struct_timespec.h>\n#endif\n\n#ifdef __USE_POSIX199309\n# include <bits/types/clockid_t.h>\n# include <bits/types/timer_t.h>\n# include <bits/types/struct_itimerspec.h>\nstruct sigevent;\n#endif\n\n#ifdef __USE_XOPEN2K\n# ifndef __pid_t_defined\ntypedef __pid_t pid_t;\n#  define __pid_t_defined\n# endif\n#endif\n\n#ifdef __USE_XOPEN2K8\n# include <bits/types/locale_t.h>\n#endif\n\n#ifdef __USE_ISOC11\n/* Time base values for timespec_get.  */\n# define TIME_UTC 1\n#endif\n\n__BEGIN_DECLS\n\n/* Time used by the program so far (user time + system time).\n   The result / CLOCKS_PER_SEC is program time in seconds.  */\nextern clock_t clock (void) __THROW;\n\n#ifndef __USE_TIME_BITS64\n/* Return the current time and put it in *TIMER if TIMER is not NULL.  */\nextern time_t time (time_t *__timer) __THROW;\n\n/* Return the difference between TIME1 and TIME0.  */\nextern double difftime (time_t __time1, time_t __time0)\n     __THROW __attribute__ ((__const__));\n\n/* Return the `time_t' representation of TP and normalize TP.  */\nextern time_t mktime (struct tm *__tp) __THROW;\n#else\n# ifdef __REDIRECT_NTH\nextern time_t __REDIRECT_NTH (time, (time_t *__timer), __time64);\nextern double __REDIRECT_NTH (difftime, (time_t __time1, time_t __time0),\n                              __difftime64) __attribute__ ((__const__));\nextern time_t __REDIRECT_NTH (mktime, (struct tm *__tp), __mktime64);\n# else\n#  define time __time64\n#  define difftime __difftime64\n#  define mktime __mktime64\n# endif\n#endif\n\n/* Format TP into S according to FORMAT.\n   Write no more than MAXSIZE characters and return the number\n   of characters written, or 0 if it would exceed MAXSIZE.  */\nextern size_t strftime (char *__restrict __s, size_t __maxsize,\n\t\t\tconst char *__restrict __format,\n\t\t\tconst struct tm *__restrict __tp) __THROW;\n\n#ifdef __USE_XOPEN\n/* Parse S according to FORMAT and store binary time information in TP.\n   The return value is a pointer to the first unparsed character in S.  */\nextern char *strptime (const char *__restrict __s,\n\t\t       const char *__restrict __fmt, struct tm *__tp)\n     __THROW;\n#endif\n\n#ifdef __USE_XOPEN2K8\n/* Similar to the two functions above but take the information from\n   the provided locale and not the global locale.  */\n\nextern size_t strftime_l (char *__restrict __s, size_t __maxsize,\n\t\t\t  const char *__restrict __format,\n\t\t\t  const struct tm *__restrict __tp,\n\t\t\t  locale_t __loc) __THROW;\n#endif\n\n#ifdef __USE_GNU\nextern char *strptime_l (const char *__restrict __s,\n\t\t\t const char *__restrict __fmt, struct tm *__tp,\n\t\t\t locale_t __loc) __THROW;\n#endif\n\n\n#ifndef __USE_TIME_BITS64\n/* Return the `struct tm' representation of *TIMER\n   in Universal Coordinated Time (aka Greenwich Mean Time).  */\nextern struct tm *gmtime (const time_t *__timer) __THROW;\n\n/* Return the `struct tm' representation\n   of *TIMER in the local timezone.  */\nextern struct tm *localtime (const time_t *__timer) __THROW;\n\n#else\n# ifdef __REDIRECT_NTH\nextern struct tm*__REDIRECT_NTH (gmtime, (const time_t *__timer), __gmtime64);\nextern struct tm *__REDIRECT_NTH (localtime, (const time_t *__timer),\n\t\t\t\t  __localtime64);\n# else\n#  define gmtime __gmtime64\n#  define localtime __localtime64\n# endif\n#endif\n\n\n#if defined __USE_POSIX || __GLIBC_USE (ISOC2X)\n# ifndef __USE_TIME_BITS64\n/* Return the `struct tm' representation of *TIMER in UTC,\n   using *TP to store the result.  */\nextern struct tm *gmtime_r (const time_t *__restrict __timer,\n\t\t\t    struct tm *__restrict __tp) __THROW;\n\n/* Return the `struct tm' representation of *TIMER in local time,\n   using *TP to store the result.  */\nextern struct tm *localtime_r (const time_t *__restrict __timer,\n\t\t\t       struct tm *__restrict __tp) __THROW;\n# else\n#  ifdef __REDIRECT_NTH\nextern struct tm*__REDIRECT_NTH (gmtime_r, (const time_t *__restrict __timer,\n                                            struct tm *__restrict __tp),\n                                 __gmtime64_r);\n\nextern struct tm*__REDIRECT_NTH (localtime_r, (const time_t *__restrict __t,\n                                               struct tm *__restrict __tp),\n                                 __localtime64_r);\n#  else\n#   define gmtime_r __gmtime64_r\n#   define localtime_r __localtime_r\n#  endif\n# endif\n#endif\t/* POSIX || C2X */\n\n/* Return a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\n   that is the representation of TP in this format.  */\nextern char *asctime (const struct tm *__tp) __THROW;\n\n/* Equivalent to `asctime (localtime (timer))'.  */\n#ifndef __USE_TIME_BITS64\nextern char *ctime (const time_t *__timer) __THROW;\n#else\n# ifdef __REDIRECT_NTH\nextern char *__REDIRECT_NTH (ctime, (const time_t *__timer), __ctime64);\n# else\n#  define ctime __ctime64\n# endif\n#endif\n\n#ifdef __USE_POSIX\n/* Reentrant versions of the above functions.  */\n\n/* Return in BUF a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\n   that is the representation of TP in this format.  */\nextern char *asctime_r (const struct tm *__restrict __tp,\n\t\t\tchar *__restrict __buf) __THROW;\n\n/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */\n#ifndef __USE_TIME_BITS64\nextern char *ctime_r (const time_t *__restrict __timer,\n\t\t      char *__restrict __buf) __THROW;\n#else\n# ifdef __REDIRECT_NTH\nextern char *__REDIRECT_NTH (ctime_r, (const time_t *__restrict __timer,\n                                       char *__restrict __buf), __ctime64_r);\n# else\n#  define ctime_r __ctime64_r\n# endif\n#endif\n\n#endif\t/* POSIX */\n\n\n/* Defined in localtime.c.  */\nextern char *__tzname[2];\t/* Current timezone names.  */\nextern int __daylight;\t\t/* If daylight-saving time is ever in use.  */\nextern long int __timezone;\t/* Seconds west of UTC.  */\n\n\n#ifdef\t__USE_POSIX\n/* Same as above.  */\nextern char *tzname[2];\n\n/* Set time conversion information from the TZ environment variable.\n   If TZ is not defined, a locale-dependent default is used.  */\nextern void tzset (void) __THROW;\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN\nextern int daylight;\nextern long int timezone;\n#endif\n\n\n/* Nonzero if YEAR is a leap year (every 4 years,\n   except every 100th isn't, and every 400th is).  */\n#define __isleap(year)\t\\\n  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))\n\n\n#ifdef __USE_MISC\n/* Miscellaneous functions many Unices inherited from the public domain\n   localtime package.  These are included only for compatibility.  */\n\n#ifndef __USE_TIME_BITS64\n/* Like `mktime', but for TP represents Universal Time, not local time.  */\nextern time_t timegm (struct tm *__tp) __THROW;\n/* Another name for `mktime'.  */\nextern time_t timelocal (struct tm *__tp) __THROW;\n#else\n# ifdef __REDIRECT_NTH\nextern time_t __REDIRECT_NTH (timegm, (struct tm *__tp), __timegm64);\nextern time_t __REDIRECT_NTH (timelocal, (struct tm *__tp), __mktime64);\n# else\n#  define timegm __timegm64\n# endif\n#endif\n\n/* Return the number of days in YEAR.  */\nextern int dysize (int __year) __THROW  __attribute__ ((__const__));\n#endif\n\n\n#ifdef __USE_POSIX199309\n# ifndef __USE_TIME_BITS64\n/* Pause execution for a number of nanoseconds.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int nanosleep (const struct timespec *__requested_time,\n\t\t      struct timespec *__remaining);\n\n/* Get resolution of clock CLOCK_ID.  */\nextern int clock_getres (clockid_t __clock_id, struct timespec *__res) __THROW;\n\n/* Get current value of clock CLOCK_ID and store it in TP.  */\nextern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __THROW;\n\n/* Set clock CLOCK_ID to value TP.  */\nextern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)\n     __THROW;\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (nanosleep, (const struct timespec *__requested_time,\n                                   struct timespec *__remaining),\n                       __nanosleep64);\nextern int __REDIRECT_NTH (clock_getres, (clockid_t __clock_id,\n                                          struct timespec *__res),\n                           __clock_getres64);\nextern int __REDIRECT_NTH (clock_gettime, (clockid_t __clock_id, struct\n                                           timespec *__tp), __clock_gettime64);\nextern int __REDIRECT_NTH (clock_settime, (clockid_t __clock_id, const struct\n                                           timespec *__tp), __clock_settime64);\n#  else\n#   define nanosleep __nanosleep64\n#   define clock_getres __clock_getres64\n#   define clock_gettime __clock_gettime64\n#   define clock_settime __clock_settime64\n#  endif\n# endif\n\n\n# ifdef __USE_XOPEN2K\n/* High-resolution sleep with the specified clock.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n#  ifndef __USE_TIME_BITS64\nextern int clock_nanosleep (clockid_t __clock_id, int __flags,\n\t\t\t    const struct timespec *__req,\n\t\t\t    struct timespec *__rem);\n#  else\n#   ifdef __REDIRECT\nextern int __REDIRECT (clock_nanosleep, (clockid_t __clock_id, int __flags,\n                                         const struct timespec *__req,\n                                         struct timespec *__rem),\n                       __clock_nanosleep_time64);\n#   else\n#    define clock_nanosleep __clock_nanosleep_time64\n#   endif\n#  endif\n\n/* Return clock ID for CPU-time clock.  */\nextern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __THROW;\n# endif\n\n\n/* Create new per-process timer using CLOCK_ID.  */\nextern int timer_create (clockid_t __clock_id,\n\t\t\t struct sigevent *__restrict __evp,\n\t\t\t timer_t *__restrict __timerid) __THROW;\n\n/* Delete timer TIMERID.  */\nextern int timer_delete (timer_t __timerid) __THROW;\n\n/* Set timer TIMERID to VALUE, returning old value in OVALUE.  */\n# ifndef __USE_TIME_BITS64\nextern int timer_settime (timer_t __timerid, int __flags,\n\t\t\t  const struct itimerspec *__restrict __value,\n\t\t\t  struct itimerspec *__restrict __ovalue) __THROW;\n\n/* Get current value of timer TIMERID and store it in VALUE.  */\nextern int timer_gettime (timer_t __timerid, struct itimerspec *__value)\n     __THROW;\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (timer_settime, (timer_t __timerid, int __flags,\n     const struct itimerspec *__restrict __value,\n     struct itimerspec *__restrict __ovalue),\n                          __timer_settime64);\n\nextern int __REDIRECT_NTH (timer_gettime, (timer_t __timerid,\n                                           struct itimerspec *__value),\n                           __timer_gettime64);\n#  else\n#   define timer_settime __timer_settime64\n#   define timer_gettime __timer_gettime64\n#  endif\n# endif\n\n/* Get expiration overrun for timer TIMERID.  */\nextern int timer_getoverrun (timer_t __timerid) __THROW;\n#endif\n\n\n#ifdef __USE_ISOC11\n# ifndef __USE_TIME_BITS64\n/* Set TS to calendar time based in time base BASE.  */\nextern int timespec_get (struct timespec *__ts, int __base)\n     __THROW __nonnull ((1));\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (timespec_get, (struct timespec *__ts, int __base),\n                           __timespec_get64) __nonnull ((1));\n#  else\n#   define timespec_get __timespec_get64\n#  endif\n# endif\n#endif\n\n\n#if __GLIBC_USE (ISOC2X)\n# ifndef __USE_TIME_BITS64\n/* Set TS to resolution of time base BASE.  */\nextern int timespec_getres (struct timespec *__ts, int __base)\n     __THROW;\n# else\n#  ifdef __REDIRECT_NTH\nextern int __REDIRECT_NTH (timespec_getres, (struct timespec *__ts,\n                                             int __base),\n                           __timespec_getres64);\n#  else\n#   define timespec_getres __timespec_getres64\n#  endif\n# endif\n#endif\n\n\n#ifdef __USE_XOPEN_EXTENDED\n/* Set to one of the following values to indicate an error.\n     1  the DATEMSK environment variable is null or undefined,\n     2  the template file cannot be opened for reading,\n     3  failed to get file status information,\n     4  the template file is not a regular file,\n     5  an error is encountered while reading the template file,\n     6  memory allication failed (not enough memory available),\n     7  there is no line in the template that matches the input,\n     8  invalid input specification Example: February 31 or a time is\n\tspecified that can not be represented in a time_t (representing\n\tthe time in seconds since 00:00:00 UTC, January 1, 1970) */\nextern int getdate_err;\n\n/* Parse the given string as a date specification and return a value\n   representing the value.  The templates from the file identified by\n   the environment variable DATEMSK are used.  In case of an error\n   `getdate_err' is set.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern struct tm *getdate (const char *__string);\n#endif\n\n#ifdef __USE_GNU\n/* Since `getdate' is not reentrant because of the use of `getdate_err'\n   and the static buffer to return the result in, we provide a thread-safe\n   variant.  The functionality is the same.  The result is returned in\n   the buffer pointed to by RESBUFP and in case of an error the return\n   value is != 0 with the same values as given above for `getdate_err'.\n\n   This function is not part of POSIX and therefore no official\n   cancellation point.  But due to similarity with an POSIX interface\n   or due to the implementation it is a cancellation point and\n   therefore not marked with __THROW.  */\nextern int getdate_r (const char *__restrict __string,\n\t\t      struct tm *__restrict __resbufp);\n#endif\n\n__END_DECLS\n\n#endif /* time.h.  */\n"}],"crc32":865565512,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]