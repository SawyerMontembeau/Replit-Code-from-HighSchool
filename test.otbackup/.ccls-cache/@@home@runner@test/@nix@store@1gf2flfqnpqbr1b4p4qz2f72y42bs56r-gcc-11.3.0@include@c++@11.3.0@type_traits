[{"ops":[{"insert":"// C++11 <type_traits> -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file include/type_traits\n *  This is a Standard C++ Library header.\n */\n\n#ifndef _GLIBCXX_TYPE_TRAITS\n#define _GLIBCXX_TYPE_TRAITS 1\n\n#pragma GCC system_header\n\n#if __cplusplus < 201103L\n# include <bits/c++0x_warning.h>\n#else\n\n#include <bits/c++config.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template<typename... _Elements>\n    class tuple;\n\n  template<typename _Tp>\n    class reference_wrapper;\n\n  /**\n   * @defgroup metaprogramming Metaprogramming\n   * @ingroup utilities\n   *\n   * Template utilities for compile-time introspection and modification,\n   * including type classification traits, type property inspection traits\n   * and type transformation traits.\n   *\n   * @since C++11\n   *\n   * @{\n   */\n\n  /// integral_constant\n  template<typename _Tp, _Tp __v>\n    struct integral_constant\n    {\n      static constexpr _Tp                  value = __v;\n      typedef _Tp                           value_type;\n      typedef integral_constant<_Tp, __v>   type;\n      constexpr operator value_type() const noexcept { return value; }\n#if __cplusplus > 201103L\n\n#define __cpp_lib_integral_constant_callable 201304\n\n      constexpr value_type operator()() const noexcept { return value; }\n#endif\n    };\n\n  template<typename _Tp, _Tp __v>\n    constexpr _Tp integral_constant<_Tp, __v>::value;\n\n  /// The type used as a compile-time boolean with true value.\n  using true_type =  integral_constant<bool, true>;\n\n  /// The type used as a compile-time boolean with false value.\n  using false_type = integral_constant<bool, false>;\n\n  /// @cond undocumented\n  /// bool_constant for C++11\n  template<bool __v>\n    using __bool_constant = integral_constant<bool, __v>;\n  /// @endcond\n\n#if __cplusplus >= 201703L\n# define __cpp_lib_bool_constant 201505\n  /// Alias template for compile-time boolean constant types.\n  /// @since C++17\n  template<bool __v>\n    using bool_constant = integral_constant<bool, __v>;\n#endif\n\n  // Metaprogramming helper types.\n\n  template<bool, typename, typename>\n    struct conditional;\n\n  /// @cond undocumented\n  template <typename _Type>\n    struct __type_identity\n    { using type = _Type; };\n\n  template<typename _Tp>\n    using __type_identity_t = typename __type_identity<_Tp>::type;\n\n  template<typename...>\n    struct __or_;\n\n  template<>\n    struct __or_<>\n    : public false_type\n    { };\n\n  template<typename _B1>\n    struct __or_<_B1>\n    : public _B1\n    { };\n\n  template<typename _B1, typename _B2>\n    struct __or_<_B1, _B2>\n    : public conditional<_B1::value, _B1, _B2>::type\n    { };\n\n  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n    struct __or_<_B1, _B2, _B3, _Bn...>\n    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type\n    { };\n\n  template<typename...>\n    struct __and_;\n\n  template<>\n    struct __and_<>\n    : public true_type\n    { };\n\n  template<typename _B1>\n    struct __and_<_B1>\n    : public _B1\n    { };\n\n  template<typename _B1, typename _B2>\n    struct __and_<_B1, _B2>\n    : public conditional<_B1::value, _B2, _B1>::type\n    { };\n\n  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n    struct __and_<_B1, _B2, _B3, _Bn...>\n    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type\n    { };\n\n  template<typename _Pp>\n    struct __not_\n    : public __bool_constant<!bool(_Pp::value)>\n    { };\n  /// @endcond\n\n#if __cplusplus >= 201703L\n\n  /// @cond undocumented\n  template<typename... _Bn>\n    inline constexpr bool __or_v = __or_<_Bn...>::value;\n  template<typename... _Bn>\n    inline constexpr bool __and_v = __and_<_Bn...>::value;\n  /// @endcond\n\n#define __cpp_lib_logical_traits 201510\n\n  template<typename... _Bn>\n    struct conjunction\n    : __and_<_Bn...>\n    { };\n\n  template<typename... _Bn>\n    struct disjunction\n    : __or_<_Bn...>\n    { };\n\n  template<typename _Pp>\n    struct negation\n    : __not_<_Pp>\n    { };\n\n  /** @ingroup variable_templates\n   * @{\n   */\n  template<typename... _Bn>\n    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;\n\n  template<typename... _Bn>\n    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;\n\n  template<typename _Pp>\n    inline constexpr bool negation_v = negation<_Pp>::value;\n  /// @}\n\n#endif // C++17\n\n  // Forward declarations\n  template<typename>\n    struct is_reference;\n  template<typename>\n    struct is_function;\n  template<typename>\n    struct is_void;\n  template<typename>\n    struct remove_cv;\n  template<typename>\n    struct is_const;\n\n  /// @cond undocumented\n  template<typename>\n    struct __is_array_unknown_bounds;\n\n  // Helper functions that return false_type for incomplete classes,\n  // incomplete unions and arrays of known bound from those.\n\n  template <typename _Tp, size_t = sizeof(_Tp)>\n    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)\n    { return {}; }\n\n  template <typename _TypeIdentity,\n      typename _NestedType = typename _TypeIdentity::type>\n    constexpr typename __or_<\n      is_reference<_NestedType>,\n      is_function<_NestedType>,\n      is_void<_NestedType>,\n      __is_array_unknown_bounds<_NestedType>\n    >::type __is_complete_or_unbounded(_TypeIdentity)\n    { return {}; }\n\n  // For several sfinae-friendly trait implementations we transport both the\n  // result information (as the member type) and the failure information (no\n  // member type). This is very similar to std::enable_if, but we cannot use\n  // them, because we need to derive from them as an implementation detail.\n\n  template<typename _Tp>\n    struct __success_type\n    { typedef _Tp type; };\n\n  struct __failure_type\n  { };\n\n  // __remove_cv_t (std::remove_cv_t for C++11).\n  template<typename _Tp>\n    using __remove_cv_t = typename remove_cv<_Tp>::type;\n\n  // Primary type categories.\n\n  template<typename>\n    struct __is_void_helper\n    : public false_type { };\n\n  template<>\n    struct __is_void_helper<void>\n    : public true_type { };\n  /// @endcond\n\n  /// is_void\n  template<typename _Tp>\n    struct is_void\n    : public __is_void_helper<__remove_cv_t<_Tp>>::type\n    { };\n\n  /// @cond undocumented\n  template<typename>\n    struct __is_integral_helper\n    : public false_type { };\n\n  template<>\n    struct __is_integral_helper<bool>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<char>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<signed char>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<unsigned char>\n    : public true_type { };\n\n  // We want is_integral<wchar_t> to be true (and make_signed/unsigned to work)\n  // even when libc doesn't provide working <wchar.h> and related functions,\n  // so check __WCHAR_TYPE__ instead of _GLIBCXX_USE_WCHAR_T.\n#ifdef __WCHAR_TYPE__\n  template<>\n    struct __is_integral_helper<wchar_t>\n    : public true_type { };\n#endif\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template<>\n    struct __is_integral_helper<char8_t>\n    : public true_type { };\n#endif\n\n  template<>\n    struct __is_integral_helper<char16_t>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<char32_t>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<short>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<unsigned short>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<int>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<unsigned int>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<long>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<unsigned long>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<long long>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<unsigned long long>\n    : public true_type { };\n\n  // Conditionalizing on __STRICT_ANSI__ here will break any port that\n  // uses one of these types for size_t.\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n  template<>\n    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_0>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_0>\n    : public true_type { };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n  template<>\n    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_1>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_1>\n    : public true_type { };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n  template<>\n    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_2>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_2>\n    : public true_type { };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n  template<>\n    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_3>\n    : public true_type { };\n\n  template<>\n    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_3>\n    : public true_type { };\n#endif\n  /// @endcond\n\n  /// is_integral\n  template<typename _Tp>\n    struct is_integral\n    : public __is_integral_helper<__remove_cv_t<_Tp>>::type\n    { };\n\n  /// @cond undocumented\n  template<typename>\n    struct __is_floating_point_helper\n    : public false_type { };\n\n  template<>\n    struct __is_floating_point_helper<float>\n    : public true_type { };\n\n  template<>\n    struct __is_floating_point_helper<double>\n    : public true_type { };\n\n  template<>\n    struct __is_floating_point_helper<long double>\n    : public true_type { };\n\n#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)\n  template<>\n    struct __is_floating_point_helper<__float128>\n    : public true_type { };\n#endif\n  /// @endcond\n\n  /// is_floating_point\n  template<typename _Tp>\n    struct is_floating_point\n    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type\n    { };\n\n  /// is_array\n  template<typename>\n    struct is_array\n    : public false_type { };\n\n  template<typename _Tp, std::size_t _Size>\n    struct is_array<_Tp[_Size]>\n    : public true_type { };\n\n  template<typename _Tp>\n    struct is_array<_Tp[]>\n    : public true_type { };\n\n  template<typename>\n    struct __is_pointer_helper\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_pointer_helper<_Tp*>\n    : public true_type { };\n\n  /// is_pointer\n  template<typename _Tp>\n    struct is_pointer\n    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type\n    { };\n\n  /// is_lvalue_reference\n  template<typename>\n    struct is_lvalue_reference\n    : public false_type { };\n\n  template<typename _Tp>\n    struct is_lvalue_reference<_Tp&>\n    : public true_type { };\n\n  /// is_rvalue_reference\n  template<typename>\n    struct is_rvalue_reference\n    : public false_type { };\n\n  template<typename _Tp>\n    struct is_rvalue_reference<_Tp&&>\n    : public true_type { };\n\n  template<typename>\n    struct __is_member_object_pointer_helper\n    : public false_type { };\n\n  template<typename _Tp, typename _Cp>\n    struct __is_member_object_pointer_helper<_Tp _Cp::*>\n    : public __not_<is_function<_Tp>>::type { };\n\n  /// is_member_object_pointer\n  template<typename _Tp>\n    struct is_member_object_pointer\n    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type\n    { };\n\n  template<typename>\n    struct __is_member_function_pointer_helper\n    : public false_type { };\n\n  template<typename _Tp, typename _Cp>\n    struct __is_member_function_pointer_helper<_Tp _Cp::*>\n    : public is_function<_Tp>::type { };\n\n  /// is_member_function_pointer\n  template<typename _Tp>\n    struct is_member_function_pointer\n    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type\n    { };\n\n  /// is_enum\n  template<typename _Tp>\n    struct is_enum\n    : public integral_constant<bool, __is_enum(_Tp)>\n    { };\n\n  /// is_union\n  template<typename _Tp>\n    struct is_union\n    : public integral_constant<bool, __is_union(_Tp)>\n    { };\n\n  /// is_class\n  template<typename _Tp>\n    struct is_class\n    : public integral_constant<bool, __is_class(_Tp)>\n    { };\n\n  /// is_function\n  template<typename _Tp>\n    struct is_function\n    : public __bool_constant<!is_const<const _Tp>::value> { };\n\n  template<typename _Tp>\n    struct is_function<_Tp&>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct is_function<_Tp&&>\n    : public false_type { };\n\n#define __cpp_lib_is_null_pointer 201309\n\n  template<typename>\n    struct __is_null_pointer_helper\n    : public false_type { };\n\n  template<>\n    struct __is_null_pointer_helper<std::nullptr_t>\n    : public true_type { };\n\n  /// is_null_pointer (LWG 2247).\n  template<typename _Tp>\n    struct is_null_pointer\n    : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type\n    { };\n\n  /// __is_nullptr_t (deprecated extension).\n  /// @deprecated Use `is_null_pointer` instead.\n  template<typename _Tp>\n    struct __is_nullptr_t\n    : public is_null_pointer<_Tp>\n    { } _GLIBCXX_DEPRECATED_SUGGEST(\"std::is_null_pointer\");\n\n  // Composite type categories.\n\n  /// is_reference\n  template<typename _Tp>\n    struct is_reference\n    : public __or_<is_lvalue_reference<_Tp>,\n                   is_rvalue_reference<_Tp>>::type\n    { };\n\n  /// is_arithmetic\n  template<typename _Tp>\n    struct is_arithmetic\n    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type\n    { };\n\n  /// is_fundamental\n  template<typename _Tp>\n    struct is_fundamental\n    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,\n\t\t   is_null_pointer<_Tp>>::type\n    { };\n\n  /// is_object\n  template<typename _Tp>\n    struct is_object\n    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,\n                          is_void<_Tp>>>::type\n    { };\n\n  template<typename>\n    struct is_member_pointer;\n\n  /// is_scalar\n  template<typename _Tp>\n    struct is_scalar\n    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,\n                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type\n    { };\n\n  /// is_compound\n  template<typename _Tp>\n    struct is_compound\n    : public __not_<is_fundamental<_Tp>>::type { };\n\n  /// @cond undocumented\n  template<typename _Tp>\n    struct __is_member_pointer_helper\n    : public false_type { };\n\n  template<typename _Tp, typename _Cp>\n    struct __is_member_pointer_helper<_Tp _Cp::*>\n    : public true_type { };\n  /// @endcond\n\n  /// is_member_pointer\n  template<typename _Tp>\n    struct is_member_pointer\n    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type\n    { };\n\n  template<typename, typename>\n    struct is_same;\n\n  /// @cond undocumented\n  template<typename _Tp, typename... _Types>\n    using __is_one_of = __or_<is_same<_Tp, _Types>...>;\n\n  // Check if a type is one of the signed integer types.\n  template<typename _Tp>\n    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,\n\t  signed char, signed short, signed int, signed long,\n\t  signed long long\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n\t  , signed __GLIBCXX_TYPE_INT_N_0\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n\t  , signed __GLIBCXX_TYPE_INT_N_1\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n\t  , signed __GLIBCXX_TYPE_INT_N_2\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n\t  , signed __GLIBCXX_TYPE_INT_N_3\n#endif\n\t  >;\n\n  // Check if a type is one of the unsigned integer types.\n  template<typename _Tp>\n    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,\n\t  unsigned char, unsigned short, unsigned int, unsigned long,\n\t  unsigned long long\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n\t  , unsigned __GLIBCXX_TYPE_INT_N_0\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n\t  , unsigned __GLIBCXX_TYPE_INT_N_1\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n\t  , unsigned __GLIBCXX_TYPE_INT_N_2\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n\t  , unsigned __GLIBCXX_TYPE_INT_N_3\n#endif\n\t  >;\n\n  // Check if a type is one of the signed or unsigned integer types.\n  template<typename _Tp>\n    using __is_standard_integer\n      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;\n\n  // __void_t (std::void_t for C++11)\n  template<typename...> using __void_t = void;\n\n  // Utility to detect referenceable types ([defns.referenceable]).\n\n  template<typename _Tp, typename = void>\n    struct __is_referenceable\n    : public false_type\n    { };\n\n  template<typename _Tp>\n    struct __is_referenceable<_Tp, __void_t<_Tp&>>\n    : public true_type\n    { };\n  /// @endcond\n\n  // Type properties.\n\n  /// is_const\n  template<typename>\n    struct is_const\n    : public false_type { };\n\n  template<typename _Tp>\n    struct is_const<_Tp const>\n    : public true_type { };\n\n  /// is_volatile\n  template<typename>\n    struct is_volatile\n    : public false_type { };\n\n  template<typename _Tp>\n    struct is_volatile<_Tp volatile>\n    : public true_type { };\n\n  /// is_trivial\n  template<typename _Tp>\n    struct is_trivial\n    : public integral_constant<bool, __is_trivial(_Tp)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_trivially_copyable\n  template<typename _Tp>\n    struct is_trivially_copyable\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_standard_layout\n  template<typename _Tp>\n    struct is_standard_layout\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /** is_pod (deprecated in C++20)\n   * @deprecated Use `is_standard_layout && is_trivial` instead.\n   */\n  // Could use is_standard_layout && is_trivial instead of the builtin.\n  template<typename _Tp>\n    struct\n    _GLIBCXX20_DEPRECATED(\"use is_standard_layout && is_trivial instead\")\n    is_pod\n    : public integral_constant<bool, __is_pod(_Tp)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /** is_literal_type\n   * @deprecated Deprecated in C++20. The idea of a literal type isn't useful.\n   */\n  template<typename _Tp>\n    struct\n    _GLIBCXX17_DEPRECATED\n    is_literal_type\n    : public integral_constant<bool, __is_literal_type(_Tp)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_empty\n  template<typename _Tp>\n    struct is_empty\n    : public integral_constant<bool, __is_empty(_Tp)>\n    { };\n\n  /// is_polymorphic\n  template<typename _Tp>\n    struct is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)>\n    { };\n\n#if __cplusplus >= 201402L\n#define __cpp_lib_is_final 201402L\n  /// is_final\n  /// @since C++14\n  template<typename _Tp>\n    struct is_final\n    : public integral_constant<bool, __is_final(_Tp)>\n    { };\n#endif\n\n  /// is_abstract\n  template<typename _Tp>\n    struct is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)>\n    { };\n\n  /// @cond undocumented\n  template<typename _Tp,\n\t   bool = is_arithmetic<_Tp>::value>\n    struct __is_signed_helper\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_signed_helper<_Tp, true>\n    : public integral_constant<bool, _Tp(-1) < _Tp(0)>\n    { };\n  /// @endcond\n\n  /// is_signed\n  template<typename _Tp>\n    struct is_signed\n    : public __is_signed_helper<_Tp>::type\n    { };\n\n  /// is_unsigned\n  template<typename _Tp>\n    struct is_unsigned\n    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>\n    { };\n\n  /// @cond undocumented\n  template<typename _Tp, typename _Up = _Tp&&>\n    _Up\n    __declval(int);\n\n  template<typename _Tp>\n    _Tp\n    __declval(long);\n  /// @endcond\n\n  template<typename _Tp>\n    auto declval() noexcept -> decltype(__declval<_Tp>(0));\n\n  template<typename, unsigned = 0>\n    struct extent;\n\n  template<typename>\n    struct remove_all_extents;\n\n  /// @cond undocumented\n  template<typename _Tp>\n    struct __is_array_known_bounds\n    : public integral_constant<bool, (extent<_Tp>::value > 0)>\n    { };\n\n  template<typename _Tp>\n    struct __is_array_unknown_bounds\n    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>\n    { };\n\n  // Destructible and constructible type properties.\n\n  // In N3290 is_destructible does not say anything about function\n  // types and abstract types, see LWG 2049. This implementation\n  // describes function types as non-destructible and all complete\n  // object types as destructible, iff the explicit destructor\n  // call expression is wellformed.\n  struct __do_is_destructible_impl\n  {\n    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>\n      static true_type __test(int);\n\n    template<typename>\n      static false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_destructible_impl\n    : public __do_is_destructible_impl\n    {\n      typedef decltype(__test<_Tp>(0)) type;\n    };\n\n  template<typename _Tp,\n           bool = __or_<is_void<_Tp>,\n                        __is_array_unknown_bounds<_Tp>,\n                        is_function<_Tp>>::value,\n           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>\n    struct __is_destructible_safe;\n\n  template<typename _Tp>\n    struct __is_destructible_safe<_Tp, false, false>\n    : public __is_destructible_impl<typename\n               remove_all_extents<_Tp>::type>::type\n    { };\n\n  template<typename _Tp>\n    struct __is_destructible_safe<_Tp, true, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_destructible_safe<_Tp, false, true>\n    : public true_type { };\n  /// @endcond\n\n  /// is_destructible\n  template<typename _Tp>\n    struct is_destructible\n    : public __is_destructible_safe<_Tp>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// @cond undocumented\n\n  // is_nothrow_destructible requires that is_destructible is\n  // satisfied as well.  We realize that by mimicing the\n  // implementation of is_destructible but refer to noexcept(expr)\n  // instead of decltype(expr).\n  struct __do_is_nt_destructible_impl\n  {\n    template<typename _Tp>\n      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>\n      __test(int);\n\n    template<typename>\n      static false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_nt_destructible_impl\n    : public __do_is_nt_destructible_impl\n    {\n      typedef decltype(__test<_Tp>(0)) type;\n    };\n\n  template<typename _Tp,\n           bool = __or_<is_void<_Tp>,\n                        __is_array_unknown_bounds<_Tp>,\n                        is_function<_Tp>>::value,\n           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>\n    struct __is_nt_destructible_safe;\n\n  template<typename _Tp>\n    struct __is_nt_destructible_safe<_Tp, false, false>\n    : public __is_nt_destructible_impl<typename\n               remove_all_extents<_Tp>::type>::type\n    { };\n\n  template<typename _Tp>\n    struct __is_nt_destructible_safe<_Tp, true, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_nt_destructible_safe<_Tp, false, true>\n    : public true_type { };\n  /// @endcond\n\n  /// is_nothrow_destructible\n  template<typename _Tp>\n    struct is_nothrow_destructible\n    : public __is_nt_destructible_safe<_Tp>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// @cond undocumented\n  template<typename _Tp, typename... _Args>\n    struct __is_constructible_impl\n    : public __bool_constant<__is_constructible(_Tp, _Args...)>\n    { };\n  /// @endcond\n\n  /// is_constructible\n  template<typename _Tp, typename... _Args>\n    struct is_constructible\n      : public __is_constructible_impl<_Tp, _Args...>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_default_constructible\n  template<typename _Tp>\n    struct is_default_constructible\n    : public __is_constructible_impl<_Tp>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// @cond undocumented\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_copy_constructible_impl;\n\n  template<typename _Tp>\n    struct __is_copy_constructible_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_copy_constructible_impl<_Tp, true>\n    : public __is_constructible_impl<_Tp, const _Tp&>\n    { };\n  /// @endcond\n\n  /// is_copy_constructible\n  template<typename _Tp>\n    struct is_copy_constructible\n    : public __is_copy_constructible_impl<_Tp>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// @cond undocumented\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_move_constructible_impl;\n\n  template<typename _Tp>\n    struct __is_move_constructible_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_move_constructible_impl<_Tp, true>\n    : public __is_constructible_impl<_Tp, _Tp&&>\n    { };\n  /// @endcond\n\n  /// is_move_constructible\n  template<typename _Tp>\n    struct is_move_constructible\n    : public __is_move_constructible_impl<_Tp>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// @cond undocumented\n  template<typename _Tp, typename... _Args>\n    using __is_nothrow_constructible_impl\n      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;\n  /// @endcond\n\n  /// is_nothrow_constructible\n  template<typename _Tp, typename... _Args>\n    struct is_nothrow_constructible\n    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_nothrow_default_constructible\n  template<typename _Tp>\n    struct is_nothrow_default_constructible\n    : public __bool_constant<__is_nothrow_constructible(_Tp)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// @cond undocumented\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_nothrow_copy_constructible_impl;\n\n  template<typename _Tp>\n    struct __is_nothrow_copy_constructible_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_nothrow_copy_constructible_impl<_Tp, true>\n    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>\n    { };\n  /// @endcond\n\n  /// is_nothrow_copy_constructible\n  template<typename _Tp>\n    struct is_nothrow_copy_constructible\n    : public __is_nothrow_copy_constructible_impl<_Tp>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// @cond undocumented\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_nothrow_move_constructible_impl;\n\n  template<typename _Tp>\n    struct __is_nothrow_move_constructible_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_nothrow_move_constructible_impl<_Tp, true>\n    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>\n    { };\n  /// @endcond\n\n  /// is_nothrow_move_constructible\n  template<typename _Tp>\n    struct is_nothrow_move_constructible\n    : public __is_nothrow_move_constructible_impl<_Tp>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_assignable\n  template<typename _Tp, typename _Up>\n    struct is_assignable\n    : public __bool_constant<__is_assignable(_Tp, _Up)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_copy_assignable_impl;\n\n  template<typename _Tp>\n    struct __is_copy_assignable_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_copy_assignable_impl<_Tp, true>\n    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>\n    { };\n\n  /// is_copy_assignable\n  template<typename _Tp>\n    struct is_copy_assignable\n    : public __is_copy_assignable_impl<_Tp>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_move_assignable_impl;\n\n  template<typename _Tp>\n    struct __is_move_assignable_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_move_assignable_impl<_Tp, true>\n    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>\n    { };\n\n  /// is_move_assignable\n  template<typename _Tp>\n    struct is_move_assignable\n    : public __is_move_assignable_impl<_Tp>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  template<typename _Tp, typename _Up>\n    using __is_nothrow_assignable_impl\n      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;\n\n  /// is_nothrow_assignable\n  template<typename _Tp, typename _Up>\n    struct is_nothrow_assignable\n    : public __is_nothrow_assignable_impl<_Tp, _Up>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_nt_copy_assignable_impl;\n\n  template<typename _Tp>\n    struct __is_nt_copy_assignable_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_nt_copy_assignable_impl<_Tp, true>\n    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>\n    { };\n\n  /// is_nothrow_copy_assignable\n  template<typename _Tp>\n    struct is_nothrow_copy_assignable\n    : public __is_nt_copy_assignable_impl<_Tp>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_nt_move_assignable_impl;\n\n  template<typename _Tp>\n    struct __is_nt_move_assignable_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_nt_move_assignable_impl<_Tp, true>\n    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>\n    { };\n\n  /// is_nothrow_move_assignable\n  template<typename _Tp>\n    struct is_nothrow_move_assignable\n    : public __is_nt_move_assignable_impl<_Tp>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_trivially_constructible\n  template<typename _Tp, typename... _Args>\n    struct is_trivially_constructible\n    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_trivially_default_constructible\n  template<typename _Tp>\n    struct is_trivially_default_constructible\n    : public __bool_constant<__is_trivially_constructible(_Tp)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  struct __do_is_implicitly_default_constructible_impl\n  {\n    template <typename _Tp>\n    static void __helper(const _Tp&);\n\n    template <typename _Tp>\n    static true_type __test(const _Tp&,\n                            decltype(__helper<const _Tp&>({}))* = 0);\n\n    static false_type __test(...);\n  };\n\n  template<typename _Tp>\n    struct __is_implicitly_default_constructible_impl\n    : public __do_is_implicitly_default_constructible_impl\n    {\n      typedef decltype(__test(declval<_Tp>())) type;\n    };\n\n  template<typename _Tp>\n    struct __is_implicitly_default_constructible_safe\n    : public __is_implicitly_default_constructible_impl<_Tp>::type\n    { };\n\n  template <typename _Tp>\n    struct __is_implicitly_default_constructible\n    : public __and_<__is_constructible_impl<_Tp>,\n\t\t    __is_implicitly_default_constructible_safe<_Tp>>\n    { };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_trivially_copy_constructible_impl;\n\n  template<typename _Tp>\n    struct __is_trivially_copy_constructible_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_trivially_copy_constructible_impl<_Tp, true>\n    : public __and_<__is_copy_constructible_impl<_Tp>,\n\t\t    integral_constant<bool,\n\t\t\t__is_trivially_constructible(_Tp, const _Tp&)>>\n    { };\n\n  /// is_trivially_copy_constructible\n  template<typename _Tp>\n    struct is_trivially_copy_constructible\n    : public __is_trivially_copy_constructible_impl<_Tp>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_trivially_move_constructible_impl;\n\n  template<typename _Tp>\n    struct __is_trivially_move_constructible_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_trivially_move_constructible_impl<_Tp, true>\n    : public __and_<__is_move_constructible_impl<_Tp>,\n\t\t    integral_constant<bool,\n\t\t\t__is_trivially_constructible(_Tp, _Tp&&)>>\n    { };\n\n  /// is_trivially_move_constructible\n  template<typename _Tp>\n    struct is_trivially_move_constructible\n    : public __is_trivially_move_constructible_impl<_Tp>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_trivially_assignable\n  template<typename _Tp, typename _Up>\n    struct is_trivially_assignable\n    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_trivially_copy_assignable_impl;\n\n  template<typename _Tp>\n    struct __is_trivially_copy_assignable_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_trivially_copy_assignable_impl<_Tp, true>\n    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>\n    { };\n\n  /// is_trivially_copy_assignable\n  template<typename _Tp>\n    struct is_trivially_copy_assignable\n    : public __is_trivially_copy_assignable_impl<_Tp>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __is_trivially_move_assignable_impl;\n\n  template<typename _Tp>\n    struct __is_trivially_move_assignable_impl<_Tp, false>\n    : public false_type { };\n\n  template<typename _Tp>\n    struct __is_trivially_move_assignable_impl<_Tp, true>\n    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>\n    { };\n\n  /// is_trivially_move_assignable\n  template<typename _Tp>\n    struct is_trivially_move_assignable\n    : public __is_trivially_move_assignable_impl<_Tp>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_trivially_destructible\n  template<typename _Tp>\n    struct is_trivially_destructible\n    : public __and_<__is_destructible_safe<_Tp>,\n\t\t    __bool_constant<__has_trivial_destructor(_Tp)>>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n\n  /// has_virtual_destructor\n  template<typename _Tp>\n    struct has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n\n  // type property queries.\n\n  /// alignment_of\n  template<typename _Tp>\n    struct alignment_of\n    : public integral_constant<std::size_t, alignof(_Tp)>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// rank\n  template<typename>\n    struct rank\n    : public integral_constant<std::size_t, 0> { };\n\n  template<typename _Tp, std::size_t _Size>\n    struct rank<_Tp[_Size]>\n    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n\n  template<typename _Tp>\n    struct rank<_Tp[]>\n    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n\n  /// extent\n  template<typename, unsigned _Uint>\n    struct extent\n    : public integral_constant<std::size_t, 0> { };\n\n  template<typename _Tp, unsigned _Uint, std::size_t _Size>\n    struct extent<_Tp[_Size], _Uint>\n    : public integral_constant<std::size_t,\n\t\t\t       _Uint == 0 ? _Size : extent<_Tp,\n\t\t\t\t\t\t\t   _Uint - 1>::value>\n    { };\n\n  template<typename _Tp, unsigned _Uint>\n    struct extent<_Tp[], _Uint>\n    : public integral_constant<std::size_t,\n\t\t\t       _Uint == 0 ? 0 : extent<_Tp,\n\t\t\t\t\t\t       _Uint - 1>::value>\n    { };\n\n\n  // Type relations.\n\n  /// is_same\n  template<typename _Tp, typename _Up>\n    struct is_same\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_SAME\n    : public integral_constant<bool, __is_same(_Tp, _Up)>\n#else\n    : public false_type\n#endif\n    { };\n\n#ifndef _GLIBCXX_HAVE_BUILTIN_IS_SAME\n  template<typename _Tp>\n    struct is_same<_Tp, _Tp>\n    : public true_type\n    { };\n#endif\n\n  /// is_base_of\n  template<typename _Base, typename _Derived>\n    struct is_base_of\n    : public integral_constant<bool, __is_base_of(_Base, _Derived)>\n    { };\n\n  template<typename _From, typename _To,\n           bool = __or_<is_void<_From>, is_function<_To>,\n                        is_array<_To>>::value>\n    struct __is_convertible_helper\n    {\n      typedef typename is_void<_To>::type type;\n    };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wctor-dtor-privacy\"\n  template<typename _From, typename _To>\n    class __is_convertible_helper<_From, _To, false>\n    {\n      template<typename _To1>\n\tstatic void __test_aux(_To1) noexcept;\n\n      template<typename _From1, typename _To1,\n\t       typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>\n\tstatic true_type\n\t__test(int);\n\n      template<typename, typename>\n\tstatic false_type\n\t__test(...);\n\n    public:\n      typedef decltype(__test<_From, _To>(0)) type;\n    };\n#pragma GCC diagnostic pop\n\n  /// is_convertible\n  template<typename _From, typename _To>\n    struct is_convertible\n    : public __is_convertible_helper<_From, _To>::type\n    { };\n\n  // helper trait for unique_ptr<T[]>, shared_ptr<T[]>, and span<T, N>\n  template<typename _ToElementType, typename _FromElementType>\n    using __is_array_convertible\n      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;\n\n  template<typename _From, typename _To,\n           bool = __or_<is_void<_From>, is_function<_To>,\n                        is_array<_To>>::value>\n    struct __is_nt_convertible_helper\n    : is_void<_To>\n    { };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wctor-dtor-privacy\"\n  template<typename _From, typename _To>\n    class __is_nt_convertible_helper<_From, _To, false>\n    {\n      template<typename _To1>\n\tstatic void __test_aux(_To1) noexcept;\n\n      template<typename _From1, typename _To1>\n\tstatic\n\t__bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>\n\t__test(int);\n\n      template<typename, typename>\n\tstatic false_type\n\t__test(...);\n\n    public:\n      using type = decltype(__test<_From, _To>(0));\n    };\n#pragma GCC diagnostic pop\n\n  // is_nothrow_convertible for C++11\n  template<typename _From, typename _To>\n    struct __is_nothrow_convertible\n    : public __is_nt_convertible_helper<_From, _To>::type\n    { };\n\n#if __cplusplus > 201703L\n#define __cpp_lib_is_nothrow_convertible 201806L\n  /// is_nothrow_convertible\n  template<typename _From, typename _To>\n    struct is_nothrow_convertible\n    : public __is_nt_convertible_helper<_From, _To>::type\n    { };\n\n  /// is_nothrow_convertible_v\n  template<typename _From, typename _To>\n    inline constexpr bool is_nothrow_convertible_v\n      = is_nothrow_convertible<_From, _To>::value;\n#endif // C++2a\n\n  // Const-volatile modifications.\n\n  /// remove_const\n  template<typename _Tp>\n    struct remove_const\n    { typedef _Tp     type; };\n\n  template<typename _Tp>\n    struct remove_const<_Tp const>\n    { typedef _Tp     type; };\n\n  /// remove_volatile\n  template<typename _Tp>\n    struct remove_volatile\n    { typedef _Tp     type; };\n\n  template<typename _Tp>\n    struct remove_volatile<_Tp volatile>\n    { typedef _Tp     type; };\n\n  /// remove_cv\n  template<typename _Tp>\n    struct remove_cv\n    { using type = _Tp; };\n\n  template<typename _Tp>\n    struct remove_cv<const _Tp>\n    { using type = _Tp; };\n\n  template<typename _Tp>\n    struct remove_cv<volatile _Tp>\n    { using type = _Tp; };\n\n  template<typename _Tp>\n    struct remove_cv<const volatile _Tp>\n    { using type = _Tp; };\n\n  /// add_const\n  template<typename _Tp>\n    struct add_const\n    { typedef _Tp const     type; };\n\n  /// add_volatile\n  template<typename _Tp>\n    struct add_volatile\n    { typedef _Tp volatile     type; };\n\n  /// add_cv\n  template<typename _Tp>\n    struct add_cv\n    {\n      typedef typename\n      add_const<typename add_volatile<_Tp>::type>::type     type;\n    };\n\n#if __cplusplus > 201103L\n\n#define __cpp_lib_transformation_trait_aliases 201304\n\n  /// Alias template for remove_const\n  template<typename _Tp>\n    using remove_const_t = typename remove_const<_Tp>::type;\n\n  /// Alias template for remove_volatile\n  template<typename _Tp>\n    using remove_volatile_t = typename remove_volatile<_Tp>::type;\n\n  /// Alias template for remove_cv\n  template<typename _Tp>\n    using remove_cv_t = typename remove_cv<_Tp>::type;\n\n  /// Alias template for add_const\n  template<typename _Tp>\n    using add_const_t = typename add_const<_Tp>::type;\n\n  /// Alias template for add_volatile\n  template<typename _Tp>\n    using add_volatile_t = typename add_volatile<_Tp>::type;\n\n  /// Alias template for add_cv\n  template<typename _Tp>\n    using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n  // Reference transformations.\n\n  /// remove_reference\n  template<typename _Tp>\n    struct remove_reference\n    { typedef _Tp   type; };\n\n  template<typename _Tp>\n    struct remove_reference<_Tp&>\n    { typedef _Tp   type; };\n\n  template<typename _Tp>\n    struct remove_reference<_Tp&&>\n    { typedef _Tp   type; };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __add_lvalue_reference_helper\n    { typedef _Tp   type; };\n\n  template<typename _Tp>\n    struct __add_lvalue_reference_helper<_Tp, true>\n    { typedef _Tp&   type; };\n\n  /// add_lvalue_reference\n  template<typename _Tp>\n    struct add_lvalue_reference\n    : public __add_lvalue_reference_helper<_Tp>\n    { };\n\n  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n    struct __add_rvalue_reference_helper\n    { typedef _Tp   type; };\n\n  template<typename _Tp>\n    struct __add_rvalue_reference_helper<_Tp, true>\n    { typedef _Tp&&   type; };\n\n  /// add_rvalue_reference\n  template<typename _Tp>\n    struct add_rvalue_reference\n    : public __add_rvalue_reference_helper<_Tp>\n    { };\n\n#if __cplusplus > 201103L\n  /// Alias template for remove_reference\n  template<typename _Tp>\n    using remove_reference_t = typename remove_reference<_Tp>::type;\n\n  /// Alias template for add_lvalue_reference\n  template<typename _Tp>\n    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n\n  /// Alias template for add_rvalue_reference\n  template<typename _Tp>\n    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n  // Sign modifications.\n\n  /// @cond undocumented\n\n  // Utility for constructing identically cv-qualified types.\n  template<typename _Unqualified, bool _IsConst, bool _IsVol>\n    struct __cv_selector;\n\n  template<typename _Unqualified>\n    struct __cv_selector<_Unqualified, false, false>\n    { typedef _Unqualified __type; };\n\n  template<typename _Unqualified>\n    struct __cv_selector<_Unqualified, false, true>\n    { typedef volatile _Unqualified __type; };\n\n  template<typename _Unqualified>\n    struct __cv_selector<_Unqualified, true, false>\n    { typedef const _Unqualified __type; };\n\n  template<typename _Unqualified>\n    struct __cv_selector<_Unqualified, true, true>\n    { typedef const volatile _Unqualified __type; };\n\n  template<typename _Qualified, typename _Unqualified,\n\t   bool _IsConst = is_const<_Qualified>::value,\n\t   bool _IsVol = is_volatile<_Qualified>::value>\n    class __match_cv_qualifiers\n    {\n      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;\n\n    public:\n      typedef typename __match::__type __type;\n    };\n\n  // Utility for finding the unsigned versions of signed integral types.\n  template<typename _Tp>\n    struct __make_unsigned\n    { typedef _Tp __type; };\n\n  template<>\n    struct __make_unsigned<char>\n    { typedef unsigned char __type; };\n\n  template<>\n    struct __make_unsigned<signed char>\n    { typedef unsigned char __type; };\n\n  template<>\n    struct __make_unsigned<short>\n    { typedef unsigned short __type; };\n\n  template<>\n    struct __make_unsigned<int>\n    { typedef unsigned int __type; };\n\n  template<>\n    struct __make_unsigned<long>\n    { typedef unsigned long __type; };\n\n  template<>\n    struct __make_unsigned<long long>\n    { typedef unsigned long long __type; };\n\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n  template<>\n    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_0>\n    { typedef unsigned __GLIBCXX_TYPE_INT_N_0 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n  template<>\n    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_1>\n    { typedef unsigned __GLIBCXX_TYPE_INT_N_1 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n  template<>\n    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_2>\n    { typedef unsigned __GLIBCXX_TYPE_INT_N_2 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n  template<>\n    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_3>\n    { typedef unsigned __GLIBCXX_TYPE_INT_N_3 __type; };\n#endif\n\n  // Select between integral and enum: not possible to be both.\n  template<typename _Tp,\n\t   bool _IsInt = is_integral<_Tp>::value,\n\t   bool _IsEnum = is_enum<_Tp>::value>\n    class __make_unsigned_selector;\n\n  template<typename _Tp>\n    class __make_unsigned_selector<_Tp, true, false>\n    {\n      using __unsigned_type\n\t= typename __make_unsigned<__remove_cv_t<_Tp>>::__type;\n\n    public:\n      using __type\n\t= typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;\n    };\n\n  class __make_unsigned_selector_base\n  {\n  protected:\n    template<typename...> struct _List { };\n\n    template<typename _Tp, typename... _Up>\n      struct _List<_Tp, _Up...> : _List<_Up...>\n      { static constexpr size_t __size = sizeof(_Tp); };\n\n    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>\n      struct __select;\n\n    template<size_t _Sz, typename _Uint, typename... _UInts>\n      struct __select<_Sz, _List<_Uint, _UInts...>, true>\n      { using __type = _Uint; };\n\n    template<size_t _Sz, typename _Uint, typename... _UInts>\n      struct __select<_Sz, _List<_Uint, _UInts...>, false>\n      : __select<_Sz, _List<_UInts...>>\n      { };\n  };\n\n  // Choose unsigned integer type with the smallest rank and same size as _Tp\n  template<typename _Tp>\n    class __make_unsigned_selector<_Tp, false, true>\n    : __make_unsigned_selector_base\n    {\n      // With -fshort-enums, an enum may be as small as a char.\n      using _UInts = _List<unsigned char, unsigned short, unsigned int,\n\t\t\t   unsigned long, unsigned long long>;\n\n      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;\n\n    public:\n      using __type\n\t= typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;\n    };\n\n  // wchar_t, char8_t, char16_t and char32_t are integral types but are\n  // neither signed integer types nor unsigned integer types, so must be\n  // transformed to the unsigned integer type with the smallest rank.\n  // Use the partial specialization for enumeration types to do that.\n#ifdef __WCHAR_TYPE__\n  template<>\n    struct __make_unsigned<wchar_t>\n    {\n      using __type\n\t= typename __make_unsigned_selector<wchar_t, false, true>::__type;\n    };\n#endif\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template<>\n    struct __make_unsigned<char8_t>\n    {\n      using __type\n\t= typename __make_unsigned_selector<char8_t, false, true>::__type;\n    };\n#endif\n\n  template<>\n    struct __make_unsigned<char16_t>\n    {\n      using __type\n\t= typename __make_unsigned_selector<char16_t, false, true>::__type;\n    };\n\n  template<>\n    struct __make_unsigned<char32_t>\n    {\n      using __type\n\t= typename __make_unsigned_selector<char32_t, false, true>::__type;\n    };\n  /// @endcond\n\n  // Given an integral/enum type, return the corresponding unsigned\n  // integer type.\n  // Primary template.\n  /// make_unsigned\n  template<typename _Tp>\n    struct make_unsigned\n    { typedef typename __make_unsigned_selector<_Tp>::__type type; };\n\n  // Integral, but don't define.\n  template<>\n    struct make_unsigned<bool>;\n\n  /// @cond undocumented\n\n  // Utility for finding the signed versions of unsigned integral types.\n  template<typename _Tp>\n    struct __make_signed\n    { typedef _Tp __type; };\n\n  template<>\n    struct __make_signed<char>\n    { typedef signed char __type; };\n\n  template<>\n    struct __make_signed<unsigned char>\n    { typedef signed char __type; };\n\n  template<>\n    struct __make_signed<unsigned short>\n    { typedef signed short __type; };\n\n  template<>\n    struct __make_signed<unsigned int>\n    { typedef signed int __type; };\n\n  template<>\n    struct __make_signed<unsigned long>\n    { typedef signed long __type; };\n\n  template<>\n    struct __make_signed<unsigned long long>\n    { typedef signed long long __type; };\n\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n  template<>\n    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_0>\n    { typedef __GLIBCXX_TYPE_INT_N_0 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n  template<>\n    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_1>\n    { typedef __GLIBCXX_TYPE_INT_N_1 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n  template<>\n    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_2>\n    { typedef __GLIBCXX_TYPE_INT_N_2 __type; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n  template<>\n    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_3>\n    { typedef __GLIBCXX_TYPE_INT_N_3 __type; };\n#endif\n\n  // Select between integral and enum: not possible to be both.\n  template<typename _Tp,\n\t   bool _IsInt = is_integral<_Tp>::value,\n\t   bool _IsEnum = is_enum<_Tp>::value>\n    class __make_signed_selector;\n\n  template<typename _Tp>\n    class __make_signed_selector<_Tp, true, false>\n    {\n      using __signed_type\n\t= typename __make_signed<__remove_cv_t<_Tp>>::__type;\n\n    public:\n      using __type\n\t= typename __match_cv_qualifiers<_Tp, __signed_type>::__type;\n    };\n\n  // Choose signed integer type with the smallest rank and same size as _Tp\n  template<typename _Tp>\n    class __make_signed_selector<_Tp, false, true>\n    {\n      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;\n\n    public:\n      typedef typename __make_signed_selector<__unsigned_type>::__type __type;\n    };\n\n  // wchar_t, char16_t and char32_t are integral types but are neither\n  // signed integer types nor unsigned integer types, so must be\n  // transformed to the signed integer type with the smallest rank.\n  // Use the partial specialization for enumeration types to do that.\n#if defined(__WCHAR_TYPE__)\n  template<>\n    struct __make_signed<wchar_t>\n    {\n      using __type\n\t= typename __make_signed_selector<wchar_t, false, true>::__type;\n    };\n#endif\n\n#if defined(_GLIBCXX_USE_CHAR8_T)\n  template<>\n    struct __make_signed<char8_t>\n    {\n      using __type\n\t= typename __make_signed_selector<char8_t, false, true>::__type;\n    };\n#endif\n\n  template<>\n    struct __make_signed<char16_t>\n    {\n      using __type\n\t= typename __make_signed_selector<char16_t, false, true>::__type;\n    };\n\n  template<>\n    struct __make_signed<char32_t>\n    {\n      using __type\n\t= typename __make_signed_selector<char32_t, false, true>::__type;\n    };\n  /// @endcond\n\n  // Given an integral/enum type, return the corresponding signed\n  // integer type.\n  // Primary template.\n  /// make_signed\n  template<typename _Tp>\n    struct make_signed\n    { typedef typename __make_signed_selector<_Tp>::__type type; };\n\n  // Integral, but don't define.\n  template<>\n    struct make_signed<bool>;\n\n#if __cplusplus > 201103L\n  /// Alias template for make_signed\n  template<typename _Tp>\n    using make_signed_t = typename make_signed<_Tp>::type;\n\n  /// Alias template for make_unsigned\n  template<typename _Tp>\n    using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n  // Array modifications.\n\n  /// remove_extent\n  template<typename _Tp>\n    struct remove_extent\n    { typedef _Tp     type; };\n\n  template<typename _Tp, std::size_t _Size>\n    struct remove_extent<_Tp[_Size]>\n    { typedef _Tp     type; };\n\n  template<typename _Tp>\n    struct remove_extent<_Tp[]>\n    { typedef _Tp     type; };\n\n  /// remove_all_extents\n  template<typename _Tp>\n    struct remove_all_extents\n    { typedef _Tp     type; };\n\n  template<typename _Tp, std::size_t _Size>\n    struct remove_all_extents<_Tp[_Size]>\n    { typedef typename remove_all_extents<_Tp>::type     type; };\n\n  template<typename _Tp>\n    struct remove_all_extents<_Tp[]>\n    { typedef typename remove_all_extents<_Tp>::type     type; };\n\n#if __cplusplus > 201103L\n  /// Alias template for remove_extent\n  template<typename _Tp>\n    using remove_extent_t = typename remove_extent<_Tp>::type;\n\n  /// Alias template for remove_all_extents\n  template<typename _Tp>\n    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n  // Pointer modifications.\n\n  template<typename _Tp, typename>\n    struct __remove_pointer_helper\n    { typedef _Tp     type; };\n\n  template<typename _Tp, typename _Up>\n    struct __remove_pointer_helper<_Tp, _Up*>\n    { typedef _Up     type; };\n\n  /// remove_pointer\n  template<typename _Tp>\n    struct remove_pointer\n    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>\n    { };\n\n  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,\n\t\t\t\t      is_void<_Tp>>::value>\n    struct __add_pointer_helper\n    { typedef _Tp     type; };\n\n  template<typename _Tp>\n    struct __add_pointer_helper<_Tp, true>\n    { typedef typename remove_reference<_Tp>::type*     type; };\n\n  /// add_pointer\n  template<typename _Tp>\n    struct add_pointer\n    : public __add_pointer_helper<_Tp>\n    { };\n\n#if __cplusplus > 201103L\n  /// Alias template for remove_pointer\n  template<typename _Tp>\n    using remove_pointer_t = typename remove_pointer<_Tp>::type;\n\n  /// Alias template for add_pointer\n  template<typename _Tp>\n    using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n  template<std::size_t _Len>\n    struct __aligned_storage_msa\n    {\n      union __type\n      {\n\tunsigned char __data[_Len];\n\tstruct __attribute__((__aligned__)) { } __align;\n      };\n    };\n\n  /**\n   *  @brief Alignment type.\n   *\n   *  The value of _Align is a default-alignment which shall be the\n   *  most stringent alignment requirement for any C++ object type\n   *  whose size is no greater than _Len (3.9). The member typedef\n   *  type shall be a POD type suitable for use as uninitialized\n   *  storage for any object whose size is at most _Len and whose\n   *  alignment is a divisor of _Align.\n  */\n  template<std::size_t _Len, std::size_t _Align =\n\t   __alignof__(typename __aligned_storage_msa<_Len>::__type)>\n    struct aligned_storage\n    {\n      union type\n      {\n\tunsigned char __data[_Len];\n\tstruct __attribute__((__aligned__((_Align)))) { } __align;\n      };\n    };\n\n  template <typename... _Types>\n    struct __strictest_alignment\n    {\n      static const size_t _S_alignment = 0;\n      static const size_t _S_size = 0;\n    };\n\n  template <typename _Tp, typename... _Types>\n    struct __strictest_alignment<_Tp, _Types...>\n    {\n      static const size_t _S_alignment =\n        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment\n\t? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;\n      static const size_t _S_size =\n        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size\n\t? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;\n    };\n\n  /**\n   *  @brief Provide aligned storage for types.\n   *\n   *  [meta.trans.other]\n   *\n   *  Provides aligned storage for any of the provided types of at\n   *  least size _Len.\n   *\n   *  @see aligned_storage\n   */\n  template <size_t _Len, typename... _Types>\n    struct aligned_union\n    {\n    private:\n      static_assert(sizeof...(_Types) != 0, \"At least one type is required\");\n\n      using __strictest = __strictest_alignment<_Types...>;\n      static const size_t _S_len = _Len > __strictest::_S_size\n\t? _Len : __strictest::_S_size;\n    public:\n      /// The value of the strictest alignment of _Types.\n      static const size_t alignment_value = __strictest::_S_alignment;\n      /// The storage.\n      typedef typename aligned_storage<_S_len, alignment_value>::type type;\n    };\n\n  template <size_t _Len, typename... _Types>\n    const size_t aligned_union<_Len, _Types...>::alignment_value;\n\n  /// @cond undocumented\n\n  // Decay trait for arrays and functions, used for perfect forwarding\n  // in make_pair, make_tuple, etc.\n  template<typename _Up,\n\t   bool _IsArray = is_array<_Up>::value,\n\t   bool _IsFunction = is_function<_Up>::value>\n    struct __decay_selector;\n\n  // NB: DR 705.\n  template<typename _Up>\n    struct __decay_selector<_Up, false, false>\n    { typedef __remove_cv_t<_Up> __type; };\n\n  template<typename _Up>\n    struct __decay_selector<_Up, true, false>\n    { typedef typename remove_extent<_Up>::type* __type; };\n\n  template<typename _Up>\n    struct __decay_selector<_Up, false, true>\n    { typedef typename add_pointer<_Up>::type __type; };\n  /// @endcond\n\n  /// decay\n  template<typename _Tp>\n    class decay\n    {\n      typedef typename remove_reference<_Tp>::type __remove_type;\n\n    public:\n      typedef typename __decay_selector<__remove_type>::__type type;\n    };\n\n  /// @cond undocumented\n\n  // Helper which adds a reference to a type when given a reference_wrapper\n  template<typename _Tp>\n    struct __strip_reference_wrapper\n    {\n      typedef _Tp __type;\n    };\n\n  template<typename _Tp>\n    struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n    {\n      typedef _Tp& __type;\n    };\n\n  // __decay_t (std::decay_t for C++11).\n  template<typename _Tp>\n    using __decay_t = typename decay<_Tp>::type;\n\n  template<typename _Tp>\n    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;\n  /// @endcond\n\n  // Primary template.\n  /// Define a member typedef `type` only if a boolean constant is true.\n  template<bool, typename _Tp = void>\n    struct enable_if\n    { };\n\n  // Partial specialization for true.\n  template<typename _Tp>\n    struct enable_if<true, _Tp>\n    { typedef _Tp type; };\n\n  /// @cond undocumented\n\n  // __enable_if_t (std::enable_if_t for C++11)\n  template<bool _Cond, typename _Tp = void>\n    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;\n\n  // Helper for SFINAE constraints\n  template<typename... _Cond>\n    using _Require = __enable_if_t<__and_<_Cond...>::value>;\n\n  // __remove_cvref_t (std::remove_cvref_t for C++11).\n  template<typename _Tp>\n    using __remove_cvref_t\n     = typename remove_cv<typename remove_reference<_Tp>::type>::type;\n  /// @endcond\n\n  // Primary template.\n  /// Define a member typedef @c type to one of two argument types.\n  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n    struct conditional\n    { typedef _Iftrue type; };\n\n  // Partial specialization for false.\n  template<typename _Iftrue, typename _Iffalse>\n    struct conditional<false, _Iftrue, _Iffalse>\n    { typedef _Iffalse type; };\n\n  /// common_type\n  template<typename... _Tp>\n    struct common_type;\n\n  // Sfinae-friendly common_type implementation:\n\n  /// @cond undocumented\n  struct __do_common_type_impl\n  {\n    template<typename _Tp, typename _Up>\n      using __cond_t\n\t= decltype(true ? std::declval<_Tp>() : std::declval<_Up>());\n\n    // if decay_t<decltype(false ? declval<D1>() : declval<D2>())>\n    // denotes a valid type, let C denote that type.\n    template<typename _Tp, typename _Up>\n      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>\n      _S_test(int);\n\n#if __cplusplus > 201703L\n    // Otherwise, if COND-RES(CREF(D1), CREF(D2)) denotes a type,\n    // let C denote the type decay_t<COND-RES(CREF(D1), CREF(D2))>.\n    template<typename _Tp, typename _Up>\n      static __success_type<__remove_cvref_t<__cond_t<const _Tp&, const _Up&>>>\n      _S_test_2(int);\n#endif\n\n    template<typename, typename>\n      static __failure_type\n      _S_test_2(...);\n\n    template<typename _Tp, typename _Up>\n      static decltype(_S_test_2<_Tp, _Up>(0))\n      _S_test(...);\n  };\n\n  // If sizeof...(T) is zero, there shall be no member type.\n  template<>\n    struct common_type<>\n    { };\n\n  // If sizeof...(T) is one, the same type, if any, as common_type_t<T0, T0>.\n  template<typename _Tp0>\n    struct common_type<_Tp0>\n    : public common_type<_Tp0, _Tp0>\n    { };\n\n  // If sizeof...(T) is two, ...\n  template<typename _Tp1, typename _Tp2,\n\t   typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>\n    struct __common_type_impl\n    {\n      // If is_same_v<T1, D1> is false or is_same_v<T2, D2> is false,\n      // let C denote the same type, if any, as common_type_t<D1, D2>.\n      using type = common_type<_Dp1, _Dp2>;\n    };\n\n  template<typename _Tp1, typename _Tp2>\n    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>\n    : private __do_common_type_impl\n    {\n      // Otherwise, if decay_t<decltype(false ? declval<D1>() : declval<D2>())>\n      // denotes a valid type, let C denote that type.\n      using type = decltype(_S_test<_Tp1, _Tp2>(0));\n    };\n\n  // If sizeof...(T) is two, ...\n  template<typename _Tp1, typename _Tp2>\n    struct common_type<_Tp1, _Tp2>\n    : public __common_type_impl<_Tp1, _Tp2>::type\n    { };\n\n  template<typename...>\n    struct __common_type_pack\n    { };\n\n  template<typename, typename, typename = void>\n    struct __common_type_fold;\n\n  // If sizeof...(T) is greater than two, ...\n  template<typename _Tp1, typename _Tp2, typename... _Rp>\n    struct common_type<_Tp1, _Tp2, _Rp...>\n    : public __common_type_fold<common_type<_Tp1, _Tp2>,\n\t\t\t\t__common_type_pack<_Rp...>>\n    { };\n\n  // Let C denote the same type, if any, as common_type_t<T1, T2>.\n  // If there is such a type C, type shall denote the same type, if any,\n  // as common_type_t<C, R...>.\n  template<typename _CTp, typename... _Rp>\n    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,\n\t\t\t      __void_t<typename _CTp::type>>\n    : public common_type<typename _CTp::type, _Rp...>\n    { };\n\n  // Otherwise, there shall be no member type.\n  template<typename _CTp, typename _Rp>\n    struct __common_type_fold<_CTp, _Rp, void>\n    { };\n\n  template<typename _Tp, bool = is_enum<_Tp>::value>\n    struct __underlying_type_impl\n    {\n      using type = __underlying_type(_Tp);\n    };\n\n  template<typename _Tp>\n    struct __underlying_type_impl<_Tp, false>\n    { };\n  /// @endcond\n\n  /// The underlying type of an enum.\n  template<typename _Tp>\n    struct underlying_type\n    : public __underlying_type_impl<_Tp>\n    { };\n\n  /// @cond undocumented\n  template<typename _Tp>\n    struct __declval_protector\n    {\n      static const bool __stop = false;\n    };\n  /// @endcond\n\n  /** Utility to simplify expressions used in unevaluated operands\n   *  @since C++11\n   *  @ingroup utilities\n   */\n  template<typename _Tp>\n    auto declval() noexcept -> decltype(__declval<_Tp>(0))\n    {\n      static_assert(__declval_protector<_Tp>::__stop,\n\t\t    \"declval() must not be used!\");\n      return __declval<_Tp>(0);\n    }\n\n  /// result_of\n  template<typename _Signature>\n    struct result_of;\n\n  // Sfinae-friendly result_of implementation:\n\n#define __cpp_lib_result_of_sfinae 201210\n\n  /// @cond undocumented\n  struct __invoke_memfun_ref { };\n  struct __invoke_memfun_deref { };\n  struct __invoke_memobj_ref { };\n  struct __invoke_memobj_deref { };\n  struct __invoke_other { };\n\n  // Associate a tag type with a specialization of __success_type.\n  template<typename _Tp, typename _Tag>\n    struct __result_of_success : __success_type<_Tp>\n    { using __invoke_type = _Tag; };\n\n  // [func.require] paragraph 1 bullet 1:\n  struct __result_of_memfun_ref_impl\n  {\n    template<typename _Fp, typename _Tp1, typename... _Args>\n      static __result_of_success<decltype(\n      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)\n      ), __invoke_memfun_ref> _S_test(int);\n\n    template<typename...>\n      static __failure_type _S_test(...);\n  };\n\n  template<typename _MemPtr, typename _Arg, typename... _Args>\n    struct __result_of_memfun_ref\n    : private __result_of_memfun_ref_impl\n    {\n      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;\n    };\n\n  // [func.require] paragraph 1 bullet 2:\n  struct __result_of_memfun_deref_impl\n  {\n    template<typename _Fp, typename _Tp1, typename... _Args>\n      static __result_of_success<decltype(\n      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)\n      ), __invoke_memfun_deref> _S_test(int);\n\n    template<typename...>\n      static __failure_type _S_test(...);\n  };\n\n  template<typename _MemPtr, typename _Arg, typename... _Args>\n    struct __result_of_memfun_deref\n    : private __result_of_memfun_deref_impl\n    {\n      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;\n    };\n\n  // [func.require] paragraph 1 bullet 3:\n  struct __result_of_memobj_ref_impl\n  {\n    template<typename _Fp, typename _Tp1>\n      static __result_of_success<decltype(\n      std::declval<_Tp1>().*std::declval<_Fp>()\n      ), __invoke_memobj_ref> _S_test(int);\n\n    template<typename, typename>\n      static __failure_type _S_test(...);\n  };\n\n  template<typename _MemPtr, typename _Arg>\n    struct __result_of_memobj_ref\n    : private __result_of_memobj_ref_impl\n    {\n      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;\n    };\n\n  // [func.require] paragraph 1 bullet 4:\n  struct __result_of_memobj_deref_impl\n  {\n    template<typename _Fp, typename _Tp1>\n      static __result_of_success<decltype(\n      (*std::declval<_Tp1>()).*std::declval<_Fp>()\n      ), __invoke_memobj_deref> _S_test(int);\n\n    template<typename, typename>\n      static __failure_type _S_test(...);\n  };\n\n  template<typename _MemPtr, typename _Arg>\n    struct __result_of_memobj_deref\n    : private __result_of_memobj_deref_impl\n    {\n      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;\n    };\n\n  template<typename _MemPtr, typename _Arg>\n    struct __result_of_memobj;\n\n  template<typename _Res, typename _Class, typename _Arg>\n    struct __result_of_memobj<_Res _Class::*, _Arg>\n    {\n      typedef __remove_cvref_t<_Arg> _Argval;\n      typedef _Res _Class::* _MemPtr;\n      typedef typename conditional<__or_<is_same<_Argval, _Class>,\n        is_base_of<_Class, _Argval>>::value,\n        __result_of_memobj_ref<_MemPtr, _Arg>,\n        __result_of_memobj_deref<_MemPtr, _Arg>\n      >::type::type type;\n    };\n\n  template<typename _MemPtr, typename _Arg, typename... _Args>\n    struct __result_of_memfun;\n\n  template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>\n    {\n      typedef typename remove_reference<_Arg>::type _Argval;\n      typedef _Res _Class::* _MemPtr;\n      typedef typename conditional<is_base_of<_Class, _Argval>::value,\n        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,\n        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>\n      >::type::type type;\n    };\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2219.  INVOKE-ing a pointer to member with a reference_wrapper\n  //        as the object expression\n\n  // Used by result_of, invoke etc. to unwrap a reference_wrapper.\n  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>\n    struct __inv_unwrap\n    {\n      using type = _Tp;\n    };\n\n  template<typename _Tp, typename _Up>\n    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>\n    {\n      using type = _Up&;\n    };\n\n  template<bool, bool, typename _Functor, typename... _ArgTypes>\n    struct __result_of_impl\n    {\n      typedef __failure_type type;\n    };\n\n  template<typename _MemPtr, typename _Arg>\n    struct __result_of_impl<true, false, _MemPtr, _Arg>\n    : public __result_of_memobj<__decay_t<_MemPtr>,\n\t\t\t\ttypename __inv_unwrap<_Arg>::type>\n    { };\n\n  template<typename _MemPtr, typename _Arg, typename... _Args>\n    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>\n    : public __result_of_memfun<__decay_t<_MemPtr>,\n\t\t\t\ttypename __inv_unwrap<_Arg>::type, _Args...>\n    { };\n\n  // [func.require] paragraph 1 bullet 5:\n  struct __result_of_other_impl\n  {\n    template<typename _Fn, typename... _Args>\n      static __result_of_success<decltype(\n      std::declval<_Fn>()(std::declval<_Args>()...)\n      ), __invoke_other> _S_test(int);\n\n    template<typename...>\n      static __failure_type _S_test(...);\n  };\n\n  template<typename _Functor, typename... _ArgTypes>\n    struct __result_of_impl<false, false, _Functor, _ArgTypes...>\n    : private __result_of_other_impl\n    {\n      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;\n    };\n\n  // __invoke_result (std::invoke_result for C++11)\n  template<typename _Functor, typename... _ArgTypes>\n    struct __invoke_result\n    : public __result_of_impl<\n        is_member_object_pointer<\n          typename remove_reference<_Functor>::type\n        >::value,\n        is_member_function_pointer<\n          typename remove_reference<_Functor>::type\n        >::value,\n\t_Functor, _ArgTypes...\n      >::type\n    { };\n  /// @endcond\n\n  template<typename _Functor, typename... _ArgTypes>\n    struct result_of<_Functor(_ArgTypes...)>\n    : public __invoke_result<_Functor, _ArgTypes...>\n    { };\n\n#if __cplusplus >= 201402L\n  /// Alias template for aligned_storage\n  template<size_t _Len, size_t _Align =\n\t    __alignof__(typename __aligned_storage_msa<_Len>::__type)>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n\n  template <size_t _Len, typename... _Types>\n    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n\n  /// Alias template for decay\n  template<typename _Tp>\n    using decay_t = typename decay<_Tp>::type;\n\n  /// Alias template for enable_if\n  template<bool _Cond, typename _Tp = void>\n    using enable_if_t = typename enable_if<_Cond, _Tp>::type;\n\n  /// Alias template for conditional\n  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;\n\n  /// Alias template for common_type\n  template<typename... _Tp>\n    using common_type_t = typename common_type<_Tp...>::type;\n\n  /// Alias template for underlying_type\n  template<typename _Tp>\n    using underlying_type_t = typename underlying_type<_Tp>::type;\n\n  /// Alias template for result_of\n  template<typename _Tp>\n    using result_of_t = typename result_of<_Tp>::type;\n#endif // C++14\n\n#if __cplusplus >= 201703L || !defined(__STRICT_ANSI__) // c++17 or gnu++11\n#define __cpp_lib_void_t 201411\n  /// A metafunction that always yields void, used for detecting valid types.\n  template<typename...> using void_t = void;\n#endif\n\n  /// @cond undocumented\n\n  /// Implementation of the detection idiom (negative case).\n  template<typename _Default, typename _AlwaysVoid,\n\t   template<typename...> class _Op, typename... _Args>\n    struct __detector\n    {\n      using value_t = false_type;\n      using type = _Default;\n    };\n\n  /// Implementation of the detection idiom (positive case).\n  template<typename _Default, template<typename...> class _Op,\n\t    typename... _Args>\n    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>\n    {\n      using value_t = true_type;\n      using type = _Op<_Args...>;\n    };\n\n  // Detect whether _Op<_Args...> is a valid type, use _Default if not.\n  template<typename _Default, template<typename...> class _Op,\n\t   typename... _Args>\n    using __detected_or = __detector<_Default, void, _Op, _Args...>;\n\n  // _Op<_Args...> if that is a valid type, otherwise _Default.\n  template<typename _Default, template<typename...> class _Op,\n\t   typename... _Args>\n    using __detected_or_t\n      = typename __detected_or<_Default, _Op, _Args...>::type;\n\n  /**\n   *  Use SFINAE to determine if the type _Tp has a publicly-accessible\n   *  member type _NTYPE.\n   */\n#define _GLIBCXX_HAS_NESTED_TYPE(_NTYPE)\t\t\t\t\\\n  template<typename _Tp, typename = __void_t<>>\t\t\t\t\\\n    struct __has_##_NTYPE\t\t\t\t\t\t\\\n    : false_type\t\t\t\t\t\t\t\\\n    { };\t\t\t\t\t\t\t\t\\\n  template<typename _Tp>\t\t\t\t\t\t\\\n    struct __has_##_NTYPE<_Tp, __void_t<typename _Tp::_NTYPE>>\t\t\\\n    : true_type\t\t\t\t\t\t\t\t\\\n    { };\n\n  template <typename _Tp>\n    struct __is_swappable;\n\n  template <typename _Tp>\n    struct __is_nothrow_swappable;\n\n  template<typename>\n    struct __is_tuple_like_impl : false_type\n    { };\n\n  template<typename... _Tps>\n    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type\n    { };\n\n  // Internal type trait that allows us to sfinae-protect tuple_cat.\n  template<typename _Tp>\n    struct __is_tuple_like\n    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type\n    { };\n  /// @endcond\n\n  template<typename _Tp>\n    _GLIBCXX20_CONSTEXPR\n    inline\n    _Require<__not_<__is_tuple_like<_Tp>>,\n\t     is_move_constructible<_Tp>,\n\t     is_move_assignable<_Tp>>\n    swap(_Tp&, _Tp&)\n    noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n\t            is_nothrow_move_assignable<_Tp>>::value);\n\n  template<typename _Tp, size_t _Nm>\n    _GLIBCXX20_CONSTEXPR\n    inline\n    __enable_if_t<__is_swappable<_Tp>::value>\n    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])\n    noexcept(__is_nothrow_swappable<_Tp>::value);\n\n  /// @cond undocumented\n  namespace __swappable_details {\n    using std::swap;\n\n    struct __do_is_swappable_impl\n    {\n      template<typename _Tp, typename\n               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>\n        static true_type __test(int);\n\n      template<typename>\n        static false_type __test(...);\n    };\n\n    struct __do_is_nothrow_swappable_impl\n    {\n      template<typename _Tp>\n        static __bool_constant<\n          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))\n        > __test(int);\n\n      template<typename>\n        static false_type __test(...);\n    };\n\n  } // namespace __swappable_details\n\n  template<typename _Tp>\n    struct __is_swappable_impl\n    : public __swappable_details::__do_is_swappable_impl\n    {\n      typedef decltype(__test<_Tp>(0)) type;\n    };\n\n  template<typename _Tp>\n    struct __is_nothrow_swappable_impl\n    : public __swappable_details::__do_is_nothrow_swappable_impl\n    {\n      typedef decltype(__test<_Tp>(0)) type;\n    };\n\n  template<typename _Tp>\n    struct __is_swappable\n    : public __is_swappable_impl<_Tp>::type\n    { };\n\n  template<typename _Tp>\n    struct __is_nothrow_swappable\n    : public __is_nothrow_swappable_impl<_Tp>::type\n    { };\n  /// @endcond\n\n#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n#define __cpp_lib_is_swappable 201603\n  /// Metafunctions used for detecting swappable types: p0185r1\n\n  /// is_swappable\n  template<typename _Tp>\n    struct is_swappable\n    : public __is_swappable_impl<_Tp>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_nothrow_swappable\n  template<typename _Tp>\n    struct is_nothrow_swappable\n    : public __is_nothrow_swappable_impl<_Tp>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n#if __cplusplus >= 201402L\n  /// is_swappable_v\n  template<typename _Tp>\n    _GLIBCXX17_INLINE constexpr bool is_swappable_v =\n      is_swappable<_Tp>::value;\n\n  /// is_nothrow_swappable_v\n  template<typename _Tp>\n    _GLIBCXX17_INLINE constexpr bool is_nothrow_swappable_v =\n      is_nothrow_swappable<_Tp>::value;\n#endif // __cplusplus >= 201402L\n\n  /// @cond undocumented\n  namespace __swappable_with_details {\n    using std::swap;\n\n    struct __do_is_swappable_with_impl\n    {\n      template<typename _Tp, typename _Up, typename\n               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),\n               typename\n               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>\n        static true_type __test(int);\n\n      template<typename, typename>\n        static false_type __test(...);\n    };\n\n    struct __do_is_nothrow_swappable_with_impl\n    {\n      template<typename _Tp, typename _Up>\n        static __bool_constant<\n          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))\n          &&\n          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))\n        > __test(int);\n\n      template<typename, typename>\n        static false_type __test(...);\n    };\n\n  } // namespace __swappable_with_details\n\n  template<typename _Tp, typename _Up>\n    struct __is_swappable_with_impl\n    : public __swappable_with_details::__do_is_swappable_with_impl\n    {\n      typedef decltype(__test<_Tp, _Up>(0)) type;\n    };\n\n  // Optimization for the homogenous lvalue case, not required:\n  template<typename _Tp>\n    struct __is_swappable_with_impl<_Tp&, _Tp&>\n    : public __swappable_details::__do_is_swappable_impl\n    {\n      typedef decltype(__test<_Tp&>(0)) type;\n    };\n\n  template<typename _Tp, typename _Up>\n    struct __is_nothrow_swappable_with_impl\n    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl\n    {\n      typedef decltype(__test<_Tp, _Up>(0)) type;\n    };\n\n  // Optimization for the homogenous lvalue case, not required:\n  template<typename _Tp>\n    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>\n    : public __swappable_details::__do_is_nothrow_swappable_impl\n    {\n      typedef decltype(__test<_Tp&>(0)) type;\n    };\n  /// @endcond\n\n  /// is_swappable_with\n  template<typename _Tp, typename _Up>\n    struct is_swappable_with\n    : public __is_swappable_with_impl<_Tp, _Up>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"first template argument must be a complete class or an unbounded array\");\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),\n\t\"second template argument must be a complete class or an unbounded array\");\n    };\n\n  /// is_nothrow_swappable_with\n  template<typename _Tp, typename _Up>\n    struct is_nothrow_swappable_with\n    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"first template argument must be a complete class or an unbounded array\");\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),\n\t\"second template argument must be a complete class or an unbounded array\");\n    };\n\n#if __cplusplus >= 201402L\n  /// is_swappable_with_v\n  template<typename _Tp, typename _Up>\n    _GLIBCXX17_INLINE constexpr bool is_swappable_with_v =\n      is_swappable_with<_Tp, _Up>::value;\n\n  /// is_nothrow_swappable_with_v\n  template<typename _Tp, typename _Up>\n    _GLIBCXX17_INLINE constexpr bool is_nothrow_swappable_with_v =\n      is_nothrow_swappable_with<_Tp, _Up>::value;\n#endif // __cplusplus >= 201402L\n\n#endif// c++1z or gnu++11\n\n  /// @cond undocumented\n\n  // __is_invocable (std::is_invocable for C++11)\n\n  // The primary template is used for invalid INVOKE expressions.\n  template<typename _Result, typename _Ret,\n\t   bool = is_void<_Ret>::value, typename = void>\n    struct __is_invocable_impl : false_type { };\n\n  // Used for valid INVOKE and INVOKE<void> expressions.\n  template<typename _Result, typename _Ret>\n    struct __is_invocable_impl<_Result, _Ret,\n\t\t\t       /* is_void<_Ret> = */ true,\n\t\t\t       __void_t<typename _Result::type>>\n    : true_type\n    { };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wctor-dtor-privacy\"\n  // Used for INVOKE<R> expressions to check the implicit conversion to R.\n  template<typename _Result, typename _Ret>\n    struct __is_invocable_impl<_Result, _Ret,\n\t\t\t       /* is_void<_Ret> = */ false,\n\t\t\t       __void_t<typename _Result::type>>\n    {\n    private:\n      // The type of the INVOKE expression.\n      // Unlike declval, this doesn't add_rvalue_reference.\n      static typename _Result::type _S_get();\n\n      template<typename _Tp>\n\tstatic void _S_conv(_Tp);\n\n      // This overload is viable if INVOKE(f, args...) can convert to _Tp.\n      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>\n\tstatic true_type\n\t_S_test(int);\n\n      template<typename _Tp>\n\tstatic false_type\n\t_S_test(...);\n\n    public:\n      using type = decltype(_S_test<_Ret>(1));\n    };\n#pragma GCC diagnostic pop\n\n  template<typename _Fn, typename... _ArgTypes>\n    struct __is_invocable\n    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type\n    { };\n\n  template<typename _Fn, typename _Tp, typename... _Args>\n    constexpr bool __call_is_nt(__invoke_memfun_ref)\n    {\n      using _Up = typename __inv_unwrap<_Tp>::type;\n      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(\n\t    std::declval<_Args>()...));\n    }\n\n  template<typename _Fn, typename _Tp, typename... _Args>\n    constexpr bool __call_is_nt(__invoke_memfun_deref)\n    {\n      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(\n\t    std::declval<_Args>()...));\n    }\n\n  template<typename _Fn, typename _Tp>\n    constexpr bool __call_is_nt(__invoke_memobj_ref)\n    {\n      using _Up = typename __inv_unwrap<_Tp>::type;\n      return noexcept(std::declval<_Up>().*std::declval<_Fn>());\n    }\n\n  template<typename _Fn, typename _Tp>\n    constexpr bool __call_is_nt(__invoke_memobj_deref)\n    {\n      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());\n    }\n\n  template<typename _Fn, typename... _Args>\n    constexpr bool __call_is_nt(__invoke_other)\n    {\n      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));\n    }\n\n  template<typename _Result, typename _Fn, typename... _Args>\n    struct __call_is_nothrow\n    : __bool_constant<\n\tstd::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})\n      >\n    { };\n\n  template<typename _Fn, typename... _Args>\n    using __call_is_nothrow_\n      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;\n\n  // __is_nothrow_invocable (std::is_nothrow_invocable for C++11)\n  template<typename _Fn, typename... _Args>\n    struct __is_nothrow_invocable\n    : __and_<__is_invocable<_Fn, _Args...>,\n             __call_is_nothrow_<_Fn, _Args...>>::type\n    { };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wctor-dtor-privacy\"\n  struct __nonesuchbase {};\n  struct __nonesuch : private __nonesuchbase {\n    ~__nonesuch() = delete;\n    __nonesuch(__nonesuch const&) = delete;\n    void operator=(__nonesuch const&) = delete;\n  };\n#pragma GCC diagnostic pop\n  /// @endcond\n\n#if __cplusplus >= 201703L\n# define __cpp_lib_is_invocable 201703\n\n  /// std::invoke_result\n  template<typename _Functor, typename... _ArgTypes>\n    struct invoke_result\n    : public __invoke_result<_Functor, _ArgTypes...>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),\n\t\"_Functor must be a complete class or an unbounded array\");\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity<_ArgTypes>{}) && ...),\n\t\"each argument type must be a complete class or an unbounded array\");\n    };\n\n  /// std::invoke_result_t\n  template<typename _Fn, typename... _Args>\n    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;\n\n  /// std::is_invocable\n  template<typename _Fn, typename... _ArgTypes>\n    struct is_invocable\n    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),\n\t\"_Fn must be a complete class or an unbounded array\");\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity<_ArgTypes>{}) && ...),\n\t\"each argument type must be a complete class or an unbounded array\");\n    };\n\n  /// std::is_invocable_r\n  template<typename _Ret, typename _Fn, typename... _ArgTypes>\n    struct is_invocable_r\n    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),\n\t\"_Fn must be a complete class or an unbounded array\");\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity<_ArgTypes>{}) && ...),\n\t\"each argument type must be a complete class or an unbounded array\");\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),\n\t\"_Ret must be a complete class or an unbounded array\");\n    };\n\n  /// std::is_nothrow_invocable\n  template<typename _Fn, typename... _ArgTypes>\n    struct is_nothrow_invocable\n    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,\n\t     __call_is_nothrow_<_Fn, _ArgTypes...>>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),\n\t\"_Fn must be a complete class or an unbounded array\");\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity<_ArgTypes>{}) && ...),\n\t\"each argument type must be a complete class or an unbounded array\");\n    };\n\n  /// @cond undocumented\n  template<typename _Result, typename _Ret, typename = void>\n    struct __is_nt_invocable_impl : false_type { };\n\n  template<typename _Result, typename _Ret>\n    struct __is_nt_invocable_impl<_Result, _Ret,\n\t\t\t\t  __void_t<typename _Result::type>>\n    : __or_<is_void<_Ret>,\n\t    __is_nothrow_convertible<typename _Result::type, _Ret>>\n    { };\n  /// @endcond\n\n  /// std::is_nothrow_invocable_r\n  template<typename _Ret, typename _Fn, typename... _ArgTypes>\n    struct is_nothrow_invocable_r\n    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,\n             __call_is_nothrow_<_Fn, _ArgTypes...>>::type\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),\n\t\"_Fn must be a complete class or an unbounded array\");\n      static_assert((std::__is_complete_or_unbounded(\n\t__type_identity<_ArgTypes>{}) && ...),\n\t\"each argument type must be a complete class or an unbounded array\");\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),\n\t\"_Ret must be a complete class or an unbounded array\");\n    };\n#endif // C++17\n\n#if __cplusplus >= 201703L\n# define __cpp_lib_type_trait_variable_templates 201510L\n  /**\n   * @defgroup variable_templates Variable templates for type traits.\n   * @ingroup metaprogramming\n   *\n   * The variable `is_foo_v<T>` is a boolean constant with the same value\n   * as the type trait `is_foo<T>::value`.\n   *\n   * @since C++17\n   */\n\n  /** @ingroup variable_templates\n   * @{\n   */\ntemplate <typename _Tp>\n  inline constexpr bool is_void_v = is_void<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_integral_v = is_integral<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_array_v = is_array<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_lvalue_reference_v =\n    is_lvalue_reference<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_rvalue_reference_v =\n    is_rvalue_reference<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_member_object_pointer_v =\n    is_member_object_pointer<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_member_function_pointer_v =\n    is_member_function_pointer<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_enum_v = is_enum<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_union_v = is_union<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_class_v = is_class<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_function_v = is_function<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_reference_v = is_reference<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_object_v = is_object<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_compound_v = is_compound<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_const_v = is_const<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_volatile_v = is_volatile<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_trivial_v = is_trivial<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_trivially_copyable_v =\n    is_trivially_copyable<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\ntemplate <typename _Tp>\n  _GLIBCXX20_DEPRECATED(\"use is_standard_layout_v && is_trivial_v instead\")\n  inline constexpr bool is_pod_v = is_pod<_Tp>::value;\ntemplate <typename _Tp>\n  _GLIBCXX17_DEPRECATED\n  inline constexpr bool is_literal_type_v = is_literal_type<_Tp>::value;\n#pragma GCC diagnostic pop\n template <typename _Tp>\n  inline constexpr bool is_empty_v = is_empty<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_abstract_v = is_abstract<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_final_v = is_final<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_signed_v = is_signed<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;\ntemplate <typename _Tp, typename... _Args>\n  inline constexpr bool is_constructible_v =\n    is_constructible<_Tp, _Args...>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_default_constructible_v =\n    is_default_constructible<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_copy_constructible_v =\n    is_copy_constructible<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_move_constructible_v =\n    is_move_constructible<_Tp>::value;\ntemplate <typename _Tp, typename _Up>\n  inline constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;\ntemplate <typename _Tp, typename... _Args>\n  inline constexpr bool is_trivially_constructible_v =\n    is_trivially_constructible<_Tp, _Args...>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_trivially_default_constructible_v =\n    is_trivially_default_constructible<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_trivially_copy_constructible_v =\n    is_trivially_copy_constructible<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_trivially_move_constructible_v =\n    is_trivially_move_constructible<_Tp>::value;\ntemplate <typename _Tp, typename _Up>\n  inline constexpr bool is_trivially_assignable_v =\n    is_trivially_assignable<_Tp, _Up>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_trivially_copy_assignable_v =\n    is_trivially_copy_assignable<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_trivially_move_assignable_v =\n    is_trivially_move_assignable<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_trivially_destructible_v =\n    is_trivially_destructible<_Tp>::value;\ntemplate <typename _Tp, typename... _Args>\n  inline constexpr bool is_nothrow_constructible_v =\n    is_nothrow_constructible<_Tp, _Args...>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_nothrow_default_constructible_v =\n    is_nothrow_default_constructible<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_nothrow_copy_constructible_v =\n    is_nothrow_copy_constructible<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_nothrow_move_constructible_v =\n    is_nothrow_move_constructible<_Tp>::value;\ntemplate <typename _Tp, typename _Up>\n  inline constexpr bool is_nothrow_assignable_v =\n    is_nothrow_assignable<_Tp, _Up>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_nothrow_copy_assignable_v =\n    is_nothrow_copy_assignable<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_nothrow_move_assignable_v =\n    is_nothrow_move_assignable<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool is_nothrow_destructible_v =\n    is_nothrow_destructible<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr bool has_virtual_destructor_v =\n    has_virtual_destructor<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;\ntemplate <typename _Tp>\n  inline constexpr size_t rank_v = rank<_Tp>::value;\ntemplate <typename _Tp, unsigned _Idx = 0>\n  inline constexpr size_t extent_v = extent<_Tp, _Idx>::value;\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_SAME\ntemplate <typename _Tp, typename _Up>\n  inline constexpr bool is_same_v = __is_same(_Tp, _Up);\n#else\ntemplate <typename _Tp, typename _Up>\n  inline constexpr bool is_same_v = std::is_same<_Tp, _Up>::value;\n#endif\ntemplate <typename _Base, typename _Derived>\n  inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;\ntemplate <typename _From, typename _To>\n  inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;\ntemplate<typename _Fn, typename... _Args>\n  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;\ntemplate<typename _Fn, typename... _Args>\n  inline constexpr bool is_nothrow_invocable_v\n    = is_nothrow_invocable<_Fn, _Args...>::value;\ntemplate<typename _Ret, typename _Fn, typename... _Args>\n  inline constexpr bool is_invocable_r_v\n    = is_invocable_r<_Ret, _Fn, _Args...>::value;\ntemplate<typename _Ret, typename _Fn, typename... _Args>\n  inline constexpr bool is_nothrow_invocable_r_v\n    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;\n/// @}\n\n#ifdef _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP\n# define __cpp_lib_has_unique_object_representations 201606\n  /// has_unique_object_representations\n  template<typename _Tp>\n    struct has_unique_object_representations\n    : bool_constant<__has_unique_object_representations(\n      remove_cv_t<remove_all_extents_t<_Tp>>\n      )>\n    {\n      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n\t\"template argument must be a complete class or an unbounded array\");\n    };\n\n  /// @ingroup variable_templates\n  template<typename _Tp>\n    inline constexpr bool has_unique_object_representations_v\n      = has_unique_object_representations<_Tp>::value;\n#endif\n\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE\n# define __cpp_lib_is_aggregate 201703\n  /// is_aggregate\n  template<typename _Tp>\n    struct is_aggregate\n    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>\n    { };\n\n  /// @ingroup variable_templates\n  template<typename _Tp>\n    inline constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;\n#endif\n#endif // C++17\n\n#if __cplusplus > 201703L\n#define __cpp_lib_remove_cvref 201711L\n\n  /// Remove references and cv-qualifiers.\n  template<typename _Tp>\n    struct remove_cvref\n    : remove_cv<_Tp>\n    { };\n\n  template<typename _Tp>\n    struct remove_cvref<_Tp&>\n    : remove_cv<_Tp>\n    { };\n\n  template<typename _Tp>\n    struct remove_cvref<_Tp&&>\n    : remove_cv<_Tp>\n    { };\n\n  template<typename _Tp>\n    using remove_cvref_t = typename remove_cvref<_Tp>::type;\n\n#define __cpp_lib_type_identity 201806L\n  /// Identity metafunction.\n  template<typename _Tp>\n    struct type_identity { using type = _Tp; };\n\n  template<typename _Tp>\n    using type_identity_t = typename type_identity<_Tp>::type;\n\n#define __cpp_lib_unwrap_ref 201811L\n\n  /// Unwrap a reference_wrapper\n  template<typename _Tp>\n    struct unwrap_reference { using type = _Tp; };\n\n  template<typename _Tp>\n    struct unwrap_reference<reference_wrapper<_Tp>> { using type = _Tp&; };\n\n  template<typename _Tp>\n    using unwrap_reference_t = typename unwrap_reference<_Tp>::type;\n\n  /// Decay type and if it's a reference_wrapper, unwrap it\n  template<typename _Tp>\n    struct unwrap_ref_decay { using type = unwrap_reference_t<decay_t<_Tp>>; };\n\n  template<typename _Tp>\n    using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;\n\n#define __cpp_lib_bounded_array_traits 201902L\n\n  /// True for a type that is an array of known bound.\n  template<typename _Tp>\n    struct is_bounded_array\n    : public __is_array_known_bounds<_Tp>\n    { };\n\n  /// True for a type that is an array of unknown bound.\n  template<typename _Tp>\n    struct is_unbounded_array\n    : public __is_array_unknown_bounds<_Tp>\n    { };\n\n  /// @ingroup variable_templates\n  template<typename _Tp>\n    inline constexpr bool is_bounded_array_v\n      = is_bounded_array<_Tp>::value;\n\n  /// @ingroup variable_templates\n  template<typename _Tp>\n    inline constexpr bool is_unbounded_array_v\n      = is_unbounded_array<_Tp>::value;\n\n#if __cplusplus > 202002L\n#define __cpp_lib_is_scoped_enum 202011L\n\n  /// @since C++23\n  //@{\n\n  template<typename _Tp>\n    struct is_scoped_enum\n    : false_type\n    { };\n\n  template<typename _Tp>\n    requires __is_enum(_Tp)\n    && requires(_Tp __t) { __t = __t; } // fails if incomplete\n    struct is_scoped_enum<_Tp>\n    : bool_constant<!requires(_Tp __t, void(*__f)(int)) { __f(__t); }>\n    { };\n\n  // FIXME remove this partial specialization and use remove_cv_t<_Tp> above\n  // when PR c++/99968 is fixed.\n  template<typename _Tp>\n    requires __is_enum(_Tp)\n    && requires(_Tp __t) { __t = __t; } // fails if incomplete\n    struct is_scoped_enum<const _Tp>\n    : bool_constant<!requires(_Tp __t, void(*__f)(int)) { __f(__t); }>\n    { };\n\n  /**\n   * @ingroup variable_templates\n   */\n  template<typename _Tp>\n    inline constexpr bool is_scoped_enum_v = is_scoped_enum<_Tp>::value;\n#endif // C++23\n\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED\n\n#define __cpp_lib_is_constant_evaluated 201811L\n\n  /// Returns true only when called during constant evaluation.\n  constexpr inline bool\n  is_constant_evaluated() noexcept\n  { return __builtin_is_constant_evaluated(); }\n  /// @}\n#endif\n\n  /// @cond undocumented\n  template<typename _From, typename _To>\n    using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;\n\n  template<typename _Xp, typename _Yp>\n    using __cond_res\n      = decltype(false ? declval<_Xp(&)()>()() : declval<_Yp(&)()>()());\n\n  template<typename _Ap, typename _Bp, typename = void>\n    struct __common_ref_impl\n    { };\n\n  // [meta.trans.other], COMMON-REF(A, B)\n  template<typename _Ap, typename _Bp>\n    using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;\n\n  // COND-RES(COPYCV(X, Y) &, COPYCV(Y, X) &)\n  template<typename _Xp, typename _Yp>\n    using __condres_cvref\n      = __cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>;\n\n  // If A and B are both lvalue reference types, ...\n  template<typename _Xp, typename _Yp>\n    struct __common_ref_impl<_Xp&, _Yp&, __void_t<__condres_cvref<_Xp, _Yp>>>\n    : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>,\n\t\t__condres_cvref<_Xp, _Yp>>\n    { };\n\n  // let C be remove_reference_t<COMMON-REF(X&, Y&)>&&\n  template<typename _Xp, typename _Yp>\n    using __common_ref_C = remove_reference_t<__common_ref<_Xp&, _Yp&>>&&;\n\n  // If A and B are both rvalue reference types, ...\n  template<typename _Xp, typename _Yp>\n    struct __common_ref_impl<_Xp&&, _Yp&&,\n      _Require<is_convertible<_Xp&&, __common_ref_C<_Xp, _Yp>>,\n\t       is_convertible<_Yp&&, __common_ref_C<_Xp, _Yp>>>>\n    { using type = __common_ref_C<_Xp, _Yp>; };\n\n  // let D be COMMON-REF(const X&, Y&)\n  template<typename _Xp, typename _Yp>\n    using __common_ref_D = __common_ref<const _Xp&, _Yp&>;\n\n  // If A is an rvalue reference and B is an lvalue reference, ...\n  template<typename _Xp, typename _Yp>\n    struct __common_ref_impl<_Xp&&, _Yp&,\n      _Require<is_convertible<_Xp&&, __common_ref_D<_Xp, _Yp>>>>\n    { using type = __common_ref_D<_Xp, _Yp>; };\n\n  // If A is an lvalue reference and B is an rvalue reference, ...\n  template<typename _Xp, typename _Yp>\n    struct __common_ref_impl<_Xp&, _Yp&&>\n    : __common_ref_impl<_Yp&&, _Xp&>\n    { };\n  /// @endcond\n\n  template<typename _Tp, typename _Up,\n\t   template<typename> class _TQual, template<typename> class _UQual>\n    struct basic_common_reference\n    { };\n\n  /// @cond undocumented\n  template<typename _Tp>\n    struct __xref\n    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>; };\n\n  template<typename _Tp>\n    struct __xref<_Tp&>\n    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&; };\n\n  template<typename _Tp>\n    struct __xref<_Tp&&>\n    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&&; };\n\n  template<typename _Tp1, typename _Tp2>\n    using __basic_common_ref\n      = typename basic_common_reference<remove_cvref_t<_Tp1>,\n\t\t\t\t\tremove_cvref_t<_Tp2>,\n\t\t\t\t\t__xref<_Tp1>::template __type,\n\t\t\t\t\t__xref<_Tp2>::template __type>::type;\n  /// @endcond\n\n  template<typename... _Tp>\n    struct common_reference;\n\n  template<typename... _Tp>\n    using common_reference_t = typename common_reference<_Tp...>::type;\n\n  // If sizeof...(T) is zero, there shall be no member type.\n  template<>\n    struct common_reference<>\n    { };\n\n  // If sizeof...(T) is one ...\n  template<typename _Tp0>\n    struct common_reference<_Tp0>\n    { using type = _Tp0; };\n\n  /// @cond undocumented\n  template<typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void>\n    struct __common_reference_impl\n    : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1>\n    { };\n\n  // If sizeof...(T) is two ...\n  template<typename _Tp1, typename _Tp2>\n    struct common_reference<_Tp1, _Tp2>\n    : __common_reference_impl<_Tp1, _Tp2>\n    { };\n\n  // If T1 and T2 are reference types and COMMON-REF(T1, T2) is well-formed, ...\n  template<typename _Tp1, typename _Tp2>\n    struct __common_reference_impl<_Tp1&, _Tp2&, 1,\n\t\t\t\t   void_t<__common_ref<_Tp1&, _Tp2&>>>\n    { using type = __common_ref<_Tp1&, _Tp2&>; };\n\n  template<typename _Tp1, typename _Tp2>\n    struct __common_reference_impl<_Tp1&&, _Tp2&&, 1,\n\t\t\t\t   void_t<__common_ref<_Tp1&&, _Tp2&&>>>\n    { using type = __common_ref<_Tp1&&, _Tp2&&>; };\n\n  template<typename _Tp1, typename _Tp2>\n    struct __common_reference_impl<_Tp1&, _Tp2&&, 1,\n\t\t\t\t   void_t<__common_ref<_Tp1&, _Tp2&&>>>\n    { using type = __common_ref<_Tp1&, _Tp2&&>; };\n\n  template<typename _Tp1, typename _Tp2>\n    struct __common_reference_impl<_Tp1&&, _Tp2&, 1,\n\t\t\t\t   void_t<__common_ref<_Tp1&&, _Tp2&>>>\n    { using type = __common_ref<_Tp1&&, _Tp2&>; };\n\n  // Otherwise, if basic_common_reference<...>::type is well-formed, ...\n  template<typename _Tp1, typename _Tp2>\n    struct __common_reference_impl<_Tp1, _Tp2, 2,\n\t\t\t\t   void_t<__basic_common_ref<_Tp1, _Tp2>>>\n    { using type = __basic_common_ref<_Tp1, _Tp2>; };\n\n  // Otherwise, if COND-RES(T1, T2) is well-formed, ...\n  template<typename _Tp1, typename _Tp2>\n    struct __common_reference_impl<_Tp1, _Tp2, 3,\n\t\t\t\t   void_t<__cond_res<_Tp1, _Tp2>>>\n    { using type = __cond_res<_Tp1, _Tp2>; };\n\n  // Otherwise, if common_type_t<T1, T2> is well-formed, ...\n  template<typename _Tp1, typename _Tp2>\n    struct __common_reference_impl<_Tp1, _Tp2, 4,\n\t\t\t\t   void_t<common_type_t<_Tp1, _Tp2>>>\n    { using type = common_type_t<_Tp1, _Tp2>; };\n\n  // Otherwise, there shall be no member type.\n  template<typename _Tp1, typename _Tp2>\n    struct __common_reference_impl<_Tp1, _Tp2, 5, void>\n    { };\n\n  // Otherwise, if sizeof...(T) is greater than two, ...\n  template<typename _Tp1, typename _Tp2, typename... _Rest>\n    struct common_reference<_Tp1, _Tp2, _Rest...>\n    : __common_type_fold<common_reference<_Tp1, _Tp2>,\n\t\t\t __common_type_pack<_Rest...>>\n    { };\n\n  // Reuse __common_type_fold for common_reference<T1, T2, Rest...>\n  template<typename _Tp1, typename _Tp2, typename... _Rest>\n    struct __common_type_fold<common_reference<_Tp1, _Tp2>,\n\t\t\t      __common_type_pack<_Rest...>,\n\t\t\t      void_t<common_reference_t<_Tp1, _Tp2>>>\n    : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...>\n    { };\n  /// @endcond\n\n#endif // C++2a\n\n  /// @} group metaprogramming\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif  // C++11\n\n#endif  // _GLIBCXX_TYPE_TRAITS\n"}],"crc32":501101800,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]