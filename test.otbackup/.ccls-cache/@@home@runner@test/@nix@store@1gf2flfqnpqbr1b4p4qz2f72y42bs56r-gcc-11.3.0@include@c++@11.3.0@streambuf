[{"ops":[{"insert":"// Stream buffer classes -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file include/streambuf\n *  This is a Standard C++ Library header.\n */\n\n//\n// ISO C++ 14882: 27.5  Stream buffers\n//\n\n#ifndef _GLIBXX_STREAMBUF\n#define _GLIBXX_STREAMBUF 1\n\n#pragma GCC system_header\n\n#include <bits/c++config.h>\n#include <iosfwd>\n#include <bits/localefwd.h>\n#include <bits/ios_base.h>\n#include <bits/cpp_type_traits.h>\n#include <ext/type_traits.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#define _IsUnused __attribute__ ((__unused__))\n\n  template<typename _CharT, typename _Traits>\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,\n\t\t\t  basic_streambuf<_CharT, _Traits>*, bool&);\n\n  /**\n   *  @brief  The actual work of input and output (interface).\n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *\n   *  This is a base class.  Derived stream buffers each control a\n   *  pair of character sequences:  one for input, and one for output.\n   *\n   *  Section [27.5.1] of the standard describes the requirements and\n   *  behavior of stream buffer classes.  That section (three paragraphs)\n   *  is reproduced here, for simplicity and accuracy.\n   *\n   *  -# Stream buffers can impose various constraints on the sequences\n   *     they control.  Some constraints are:\n   *     - The controlled input sequence can be not readable.\n   *     - The controlled output sequence can be not writable.\n   *     - The controlled sequences can be associated with the contents of\n   *       other representations for character sequences, such as external\n   *       files.\n   *     - The controlled sequences can support operations @e directly to or\n   *       from associated sequences.\n   *     - The controlled sequences can impose limitations on how the\n   *       program can read characters from a sequence, write characters to\n   *       a sequence, put characters back into an input sequence, or alter\n   *       the stream position.\n   *     .\n   *  -# Each sequence is characterized by three pointers which, if non-null,\n   *     all point into the same @c charT array object.  The array object\n   *     represents, at any moment, a (sub)sequence of characters from the\n   *     sequence.  Operations performed on a sequence alter the values\n   *     stored in these pointers, perform reads and writes directly to or\n   *     from associated sequences, and alter <em>the stream position</em> and\n   *     conversion state as needed to maintain this subsequence relationship.\n   *     The three pointers are:\n   *     - the <em>beginning pointer</em>, or lowest element address in the\n   *       array (called @e xbeg here);\n   *     - the <em>next pointer</em>, or next element address that is a\n   *       current candidate for reading or writing (called @e xnext here);\n   *     - the <em>end pointer</em>, or first element address beyond the\n   *       end of the array (called @e xend here).\n   *     .\n   *  -# The following semantic constraints shall always apply for any set\n   *     of three pointers for a sequence, using the pointer names given\n   *     immediately above:\n   *     - If @e xnext is not a null pointer, then @e xbeg and @e xend shall\n   *       also be non-null pointers into the same @c charT array, as\n   *       described above; otherwise, @e xbeg and @e xend shall also be null.\n   *     - If @e xnext is not a null pointer and @e xnext < @e xend for an\n   *       output sequence, then a <em>write position</em> is available.\n   *       In this case, @e *xnext shall be assignable as the next element\n   *       to write (to put, or to store a character value, into the sequence).\n   *     - If @e xnext is not a null pointer and @e xbeg < @e xnext for an\n   *       input sequence, then a <em>putback position</em> is available.\n   *       In this case, @e xnext[-1] shall have a defined value and is the\n   *       next (preceding) element to store a character that is put back\n   *       into the input sequence.\n   *     - If @e xnext is not a null pointer and @e xnext< @e xend for an\n   *       input sequence, then a <em>read position</em> is available.\n   *       In this case, @e *xnext shall have a defined value and is the\n   *       next element to read (to get, or to obtain a character value,\n   *       from the sequence).\n  */\n  template<typename _CharT, typename _Traits>\n    class basic_streambuf\n    {\n    public:\n      ///@{\n      /**\n       *  These are standard types.  They permit a standardized way of\n       *  referring to names of (or names dependent on) the template\n       *  parameters, which are specific to the implementation.\n      */\n      typedef _CharT \t\t\t\t\tchar_type;\n      typedef _Traits \t\t\t\t\ttraits_type;\n      typedef typename traits_type::int_type \t\tint_type;\n      typedef typename traits_type::pos_type \t\tpos_type;\n      typedef typename traits_type::off_type \t\toff_type;\n      ///@}\n\n      ///@{\n      /// This is a non-standard type.\n      typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n      ///@}\n\n      friend class basic_ios<char_type, traits_type>;\n      friend class basic_istream<char_type, traits_type>;\n      friend class basic_ostream<char_type, traits_type>;\n      friend class istreambuf_iterator<char_type, traits_type>;\n      friend class ostreambuf_iterator<char_type, traits_type>;\n\n      friend streamsize\n      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);\n\n      template<bool _IsMove, typename _CharT2>\n        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n\t\t\t\t\t       _CharT2*>::__type\n        __copy_move_a2(istreambuf_iterator<_CharT2>,\n\t\t       istreambuf_iterator<_CharT2>, _CharT2*);\n\n      template<typename _CharT2>\n        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n\t\t\t\t  istreambuf_iterator<_CharT2> >::__type\n        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,\n\t     const _CharT2&);\n\n      template<typename _CharT2, typename _Distance>\n        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,\n\t\t\t\t\t       void>::__type\n        advance(istreambuf_iterator<_CharT2>&, _Distance);\n\n      friend void __istream_extract(istream&, char*, streamsize);\n\n      template<typename _CharT2, typename _Traits2, typename _Alloc>\n        friend basic_istream<_CharT2, _Traits2>&\n        operator>>(basic_istream<_CharT2, _Traits2>&,\n\t\t   basic_string<_CharT2, _Traits2, _Alloc>&);\n\n      template<typename _CharT2, typename _Traits2, typename _Alloc>\n        friend basic_istream<_CharT2, _Traits2>&\n        getline(basic_istream<_CharT2, _Traits2>&,\n\t\tbasic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);\n\n    protected:\n      /*\n       *  This is based on _IO_FILE, just reordered to be more consistent,\n       *  and is intended to be the most minimal abstraction for an\n       *  internal buffer.\n       *  -  get == input == read\n       *  -  put == output == write\n      */\n      char_type* \t\t_M_in_beg;     ///< Start of get area.\n      char_type* \t\t_M_in_cur;     ///< Current read area.\n      char_type* \t\t_M_in_end;     ///< End of get area.\n      char_type* \t\t_M_out_beg;    ///< Start of put area.\n      char_type* \t\t_M_out_cur;    ///< Current put area.\n      char_type* \t\t_M_out_end;    ///< End of put area.\n\n      /// Current locale setting.\n      locale \t\t\t_M_buf_locale;\n\n  public:\n      /// Destructor deallocates no buffer space.\n      virtual\n      ~basic_streambuf()\n      { }\n\n      // [27.5.2.2.1] locales\n      /**\n       *  @brief  Entry point for imbue().\n       *  @param  __loc  The new locale.\n       *  @return  The previous locale.\n       *\n       *  Calls the derived imbue(__loc).\n      */\n      locale\n      pubimbue(const locale& __loc)\n      {\n\tlocale __tmp(this->getloc());\n\tthis->imbue(__loc);\n\t_M_buf_locale = __loc;\n\treturn __tmp;\n      }\n\n      /**\n       *  @brief  Locale access.\n       *  @return  The current locale in effect.\n       *\n       *  If pubimbue(loc) has been called, then the most recent @c loc\n       *  is returned.  Otherwise the global locale in effect at the time\n       *  of construction is returned.\n      */\n      locale\n      getloc() const\n      { return _M_buf_locale; }\n\n      // [27.5.2.2.2] buffer management and positioning\n      ///@{\n      /**\n       *  @brief  Entry points for derived buffer functions.\n       *\n       *  The public versions of @c pubfoo dispatch to the protected\n       *  derived @c foo member functions, passing the arguments (if any)\n       *  and returning the result unchanged.\n      */\n      basic_streambuf*\n      pubsetbuf(char_type* __s, streamsize __n)\n      { return this->setbuf(__s, __n); }\n\n      /**\n       *  @brief  Alters the stream position.\n       *  @param  __off  Offset.\n       *  @param  __way  Value for ios_base::seekdir.\n       *  @param  __mode Value for ios_base::openmode.\n       *\n       *  Calls virtual seekoff function.\n      */\n      pos_type\n      pubseekoff(off_type __off, ios_base::seekdir __way,\n\t\t ios_base::openmode __mode = ios_base::in | ios_base::out)\n      { return this->seekoff(__off, __way, __mode); }\n\n      /**\n       *  @brief  Alters the stream position.\n       *  @param  __sp  Position\n       *  @param  __mode Value for ios_base::openmode.\n       *\n       *  Calls virtual seekpos function.\n      */\n      pos_type\n      pubseekpos(pos_type __sp,\n\t\t ios_base::openmode __mode = ios_base::in | ios_base::out)\n      { return this->seekpos(__sp, __mode); }\n\n      /**\n       *  @brief  Calls virtual sync function.\n      */\n      int\n      pubsync() { return this->sync(); }\n      ///@}\n\n      // [27.5.2.2.3] get area\n      /**\n       *  @brief  Looking ahead into the stream.\n       *  @return  The number of characters available.\n       *\n       *  If a read position is available, returns the number of characters\n       *  available for reading before the buffer must be refilled.\n       *  Otherwise returns the derived @c showmanyc().\n      */\n      streamsize\n      in_avail()\n      {\n\tconst streamsize __ret = this->egptr() - this->gptr();\n\treturn __ret ? __ret : this->showmanyc();\n      }\n\n      /**\n       *  @brief  Getting the next character.\n       *  @return  The next character, or eof.\n       *\n       *  Calls @c sbumpc(), and if that function returns\n       *  @c traits::eof(), so does this function.  Otherwise, @c sgetc().\n      */\n      int_type\n      snextc()\n      {\n\tint_type __ret = traits_type::eof();\n\tif (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),\n\t\t\t\t\t\t       __ret), true))\n\t  __ret = this->sgetc();\n\treturn __ret;\n      }\n\n      /**\n       *  @brief  Getting the next character.\n       *  @return  The next character, or eof.\n       *\n       *  If the input read position is available, returns that character\n       *  and increments the read pointer, otherwise calls and returns\n       *  @c uflow().\n      */\n      int_type\n      sbumpc()\n      {\n\tint_type __ret;\n\tif (__builtin_expect(this->gptr() < this->egptr(), true))\n\t  {\n\t    __ret = traits_type::to_int_type(*this->gptr());\n\t    this->gbump(1);\n\t  }\n\telse\n\t  __ret = this->uflow();\n\treturn __ret;\n      }\n\n      /**\n       *  @brief  Getting the next character.\n       *  @return  The next character, or eof.\n       *\n       *  If the input read position is available, returns that character,\n       *  otherwise calls and returns @c underflow().  Does not move the\n       *  read position after fetching the character.\n      */\n      int_type\n      sgetc()\n      {\n\tint_type __ret;\n\tif (__builtin_expect(this->gptr() < this->egptr(), true))\n\t  __ret = traits_type::to_int_type(*this->gptr());\n\telse\n\t  __ret = this->underflow();\n\treturn __ret;\n      }\n\n      /**\n       *  @brief  Entry point for xsgetn.\n       *  @param  __s  A buffer area.\n       *  @param  __n  A count.\n       *\n       *  Returns xsgetn(__s,__n).  The effect is to fill @a __s[0] through\n       *  @a __s[__n-1] with characters from the input sequence, if possible.\n      */\n      streamsize\n      sgetn(char_type* __s, streamsize __n)\n      { return this->xsgetn(__s, __n); }\n\n      // [27.5.2.2.4] putback\n      /**\n       *  @brief  Pushing characters back into the input stream.\n       *  @param  __c  The character to push back.\n       *  @return  The previous character, if possible.\n       *\n       *  Similar to sungetc(), but @a __c is pushed onto the stream\n       *  instead of <em>the previous character.</em> If successful,\n       *  the next character fetched from the input stream will be @a\n       *  __c.\n      */\n      int_type\n      sputbackc(char_type __c)\n      {\n\tint_type __ret;\n\tconst bool __testpos = this->eback() < this->gptr();\n\tif (__builtin_expect(!__testpos ||\n\t\t\t     !traits_type::eq(__c, this->gptr()[-1]), false))\n\t  __ret = this->pbackfail(traits_type::to_int_type(__c));\n\telse\n\t  {\n\t    this->gbump(-1);\n\t    __ret = traits_type::to_int_type(*this->gptr());\n\t  }\n\treturn __ret;\n      }\n\n      /**\n       *  @brief  Moving backwards in the input stream.\n       *  @return  The previous character, if possible.\n       *\n       *  If a putback position is available, this function decrements\n       *  the input pointer and returns that character.  Otherwise,\n       *  calls and returns pbackfail().  The effect is to @a unget\n       *  the last character @a gotten.\n      */\n      int_type\n      sungetc()\n      {\n\tint_type __ret;\n\tif (__builtin_expect(this->eback() < this->gptr(), true))\n\t  {\n\t    this->gbump(-1);\n\t    __ret = traits_type::to_int_type(*this->gptr());\n\t  }\n\telse\n\t  __ret = this->pbackfail();\n\treturn __ret;\n      }\n\n      // [27.5.2.2.5] put area\n      /**\n       *  @brief  Entry point for all single-character output functions.\n       *  @param  __c  A character to output.\n       *  @return  @a __c, if possible.\n       *\n       *  One of two public output functions.\n       *\n       *  If a write position is available for the output sequence (i.e.,\n       *  the buffer is not full), stores @a __c in that position, increments\n       *  the position, and returns @c traits::to_int_type(__c).  If a write\n       *  position is not available, returns @c overflow(__c).\n      */\n      int_type\n      sputc(char_type __c)\n      {\n\tint_type __ret;\n\tif (__builtin_expect(this->pptr() < this->epptr(), true))\n\t  {\n\t    *this->pptr() = __c;\n\t    this->pbump(1);\n\t    __ret = traits_type::to_int_type(__c);\n\t  }\n\telse\n\t  __ret = this->overflow(traits_type::to_int_type(__c));\n\treturn __ret;\n      }\n\n      /**\n       *  @brief  Entry point for all single-character output functions.\n       *  @param  __s  A buffer read area.\n       *  @param  __n  A count.\n       *\n       *  One of two public output functions.\n       *\n       *\n       *  Returns xsputn(__s,__n).  The effect is to write @a __s[0] through\n       *  @a __s[__n-1] to the output sequence, if possible.\n      */\n      streamsize\n      sputn(const char_type* __s, streamsize __n)\n      { return this->xsputn(__s, __n); }\n\n    protected:\n      /**\n       *  @brief  Base constructor.\n       *\n       *  Only called from derived constructors, and sets up all the\n       *  buffer data to zero, including the pointers described in the\n       *  basic_streambuf class description.  Note that, as a result,\n       *  - the class starts with no read nor write positions available,\n       *  - this is not an error\n      */\n      basic_streambuf()\n      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),\n      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),\n      _M_buf_locale(locale())\n      { }\n\n      // [27.5.2.3.1] get area access\n      ///@{\n      /**\n       *  @brief  Access to the get area.\n       *\n       *  These functions are only available to other protected functions,\n       *  including derived classes.\n       *\n       *  - eback() returns the beginning pointer for the input sequence\n       *  - gptr() returns the next pointer for the input sequence\n       *  - egptr() returns the end pointer for the input sequence\n      */\n      char_type*\n      eback() const { return _M_in_beg; }\n\n      char_type*\n      gptr()  const { return _M_in_cur;  }\n\n      char_type*\n      egptr() const { return _M_in_end; }\n      ///@}\n\n      /**\n       *  @brief  Moving the read position.\n       *  @param  __n  The delta by which to move.\n       *\n       *  This just advances the read position without returning any data.\n      */\n      void\n      gbump(int __n) { _M_in_cur += __n; }\n\n      /**\n       *  @brief  Setting the three read area pointers.\n       *  @param  __gbeg  A pointer.\n       *  @param  __gnext  A pointer.\n       *  @param  __gend  A pointer.\n       *  @post  @a __gbeg == @c eback(), @a __gnext == @c gptr(), and\n       *         @a __gend == @c egptr()\n      */\n      void\n      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)\n      {\n\t_M_in_beg = __gbeg;\n\t_M_in_cur = __gnext;\n\t_M_in_end = __gend;\n      }\n\n      // [27.5.2.3.2] put area access\n      ///@{\n      /**\n       *  @brief  Access to the put area.\n       *\n       *  These functions are only available to other protected functions,\n       *  including derived classes.\n       *\n       *  - pbase() returns the beginning pointer for the output sequence\n       *  - pptr() returns the next pointer for the output sequence\n       *  - epptr() returns the end pointer for the output sequence\n      */\n      char_type*\n      pbase() const { return _M_out_beg; }\n\n      char_type*\n      pptr() const { return _M_out_cur; }\n\n      char_type*\n      epptr() const { return _M_out_end; }\n      ///@}\n\n      /**\n       *  @brief  Moving the write position.\n       *  @param  __n  The delta by which to move.\n       *\n       *  This just advances the write position without returning any data.\n      */\n      void\n      pbump(int __n) { _M_out_cur += __n; }\n\n      /**\n       *  @brief  Setting the three write area pointers.\n       *  @param  __pbeg  A pointer.\n       *  @param  __pend  A pointer.\n       *  @post  @a __pbeg == @c pbase(), @a __pbeg == @c pptr(), and\n       *         @a __pend == @c epptr()\n      */\n      void\n      setp(char_type* __pbeg, char_type* __pend)\n      {\n\t_M_out_beg = _M_out_cur = __pbeg;\n\t_M_out_end = __pend;\n      }\n\n      // [27.5.2.4] virtual functions\n      // [27.5.2.4.1] locales\n      /**\n       *  @brief  Changes translations.\n       *  @param  __loc  A new locale.\n       *\n       *  Translations done during I/O which depend on the current\n       *  locale are changed by this call.  The standard adds,\n       *  <em>Between invocations of this function a class derived\n       *  from streambuf can safely cache results of calls to locale\n       *  functions and to members of facets so obtained.</em>\n       *\n       *  @note  Base class version does nothing.\n      */\n      virtual void\n      imbue(const locale& __loc _IsUnused)\n      { }\n\n      // [27.5.2.4.2] buffer management and positioning\n      /**\n       *  @brief  Manipulates the buffer.\n       *\n       *  Each derived class provides its own appropriate behavior.  See\n       *  the next-to-last paragraph of\n       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering\n       *  for more on this function.\n       *\n       *  @note  Base class version does nothing, returns @c this.\n      */\n      virtual basic_streambuf<char_type,_Traits>*\n      setbuf(char_type*, streamsize)\n      {\treturn this; }\n\n      /**\n       *  @brief  Alters the stream positions.\n       *\n       *  Each derived class provides its own appropriate behavior.\n       *  @note  Base class version does nothing, returns a @c pos_type\n       *         that represents an invalid stream position.\n      */\n      virtual pos_type\n      seekoff(off_type, ios_base::seekdir,\n\t      ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)\n      { return pos_type(off_type(-1)); }\n\n      /**\n       *  @brief  Alters the stream positions.\n       *\n       *  Each derived class provides its own appropriate behavior.\n       *  @note  Base class version does nothing, returns a @c pos_type\n       *         that represents an invalid stream position.\n      */\n      virtual pos_type\n      seekpos(pos_type,\n\t      ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)\n      { return pos_type(off_type(-1)); }\n\n      /**\n       *  @brief  Synchronizes the buffer arrays with the controlled sequences.\n       *  @return  -1 on failure.\n       *\n       *  Each derived class provides its own appropriate behavior,\n       *  including the definition of @a failure.\n       *  @note  Base class version does nothing, returns zero.\n      */\n      virtual int\n      sync() { return 0; }\n\n      // [27.5.2.4.3] get area\n      /**\n       *  @brief  Investigating the data available.\n       *  @return  An estimate of the number of characters available in the\n       *           input sequence, or -1.\n       *\n       *  <em>If it returns a positive value, then successive calls to\n       *  @c underflow() will not return @c traits::eof() until at\n       *  least that number of characters have been supplied.  If @c\n       *  showmanyc() returns -1, then calls to @c underflow() or @c\n       *  uflow() will fail.</em> [27.5.2.4.3]/1\n       *\n       *  @note  Base class version does nothing, returns zero.\n       *  @note  The standard adds that <em>the intention is not only that the\n       *         calls [to underflow or uflow] will not return @c eof() but\n       *         that they will return immediately.</em>\n       *  @note  The standard adds that <em>the morphemes of @c showmanyc are\n       *         @b es-how-many-see, not @b show-manic.</em>\n      */\n      virtual streamsize\n      showmanyc() { return 0; }\n\n      /**\n       *  @brief  Multiple character extraction.\n       *  @param  __s  A buffer area.\n       *  @param  __n  Maximum number of characters to assign.\n       *  @return  The number of characters assigned.\n       *\n       *  Fills @a __s[0] through @a __s[__n-1] with characters from the input\n       *  sequence, as if by @c sbumpc().  Stops when either @a __n characters\n       *  have been copied, or when @c traits::eof() would be copied.\n       *\n       *  It is expected that derived classes provide a more efficient\n       *  implementation by overriding this definition.\n      */\n      virtual streamsize\n      xsgetn(char_type* __s, streamsize __n);\n\n      /**\n       *  @brief  Fetches more data from the controlled sequence.\n       *  @return  The first character from the <em>pending sequence</em>.\n       *\n       *  Informally, this function is called when the input buffer is\n       *  exhausted (or does not exist, as buffering need not actually be\n       *  done).  If a buffer exists, it is @a refilled.  In either case, the\n       *  next available character is returned, or @c traits::eof() to\n       *  indicate a null pending sequence.\n       *\n       *  For a formal definition of the pending sequence, see a good text\n       *  such as Langer & Kreft, or [27.5.2.4.3]/7-14.\n       *\n       *  A functioning input streambuf can be created by overriding only\n       *  this function (no buffer area will be used).  For an example, see\n       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html\n       *\n       *  @note  Base class version does nothing, returns eof().\n      */\n      virtual int_type\n      underflow()\n      { return traits_type::eof(); }\n\n      /**\n       *  @brief  Fetches more data from the controlled sequence.\n       *  @return  The first character from the <em>pending sequence</em>.\n       *\n       *  Informally, this function does the same thing as @c underflow(),\n       *  and in fact is required to call that function.  It also returns\n       *  the new character, like @c underflow() does.  However, this\n       *  function also moves the read position forward by one.\n      */\n      virtual int_type\n      uflow()\n      {\n\tint_type __ret = traits_type::eof();\n\tconst bool __testeof = traits_type::eq_int_type(this->underflow(),\n\t\t\t\t\t\t\t__ret);\n\tif (!__testeof)\n\t  {\n\t    __ret = traits_type::to_int_type(*this->gptr());\n\t    this->gbump(1);\n\t  }\n\treturn __ret;\n      }\n\n      // [27.5.2.4.4] putback\n      /**\n       *  @brief  Tries to back up the input sequence.\n       *  @param  __c  The character to be inserted back into the sequence.\n       *  @return  eof() on failure, <em>some other value</em> on success\n       *  @post  The constraints of @c gptr(), @c eback(), and @c pptr()\n       *         are the same as for @c underflow().\n       *\n       *  @note  Base class version does nothing, returns eof().\n      */\n      virtual int_type\n      pbackfail(int_type __c _IsUnused  = traits_type::eof())\n      { return traits_type::eof(); }\n\n      // Put area:\n      /**\n       *  @brief  Multiple character insertion.\n       *  @param  __s  A buffer area.\n       *  @param  __n  Maximum number of characters to write.\n       *  @return  The number of characters written.\n       *\n       *  Writes @a __s[0] through @a __s[__n-1] to the output sequence, as if\n       *  by @c sputc().  Stops when either @a n characters have been\n       *  copied, or when @c sputc() would return @c traits::eof().\n       *\n       *  It is expected that derived classes provide a more efficient\n       *  implementation by overriding this definition.\n      */\n      virtual streamsize\n      xsputn(const char_type* __s, streamsize __n);\n\n      /**\n       *  @brief  Consumes data from the buffer; writes to the\n       *          controlled sequence.\n       *  @param  __c  An additional character to consume.\n       *  @return  eof() to indicate failure, something else (usually\n       *           @a __c, or not_eof())\n       *\n       *  Informally, this function is called when the output buffer\n       *  is full (or does not exist, as buffering need not actually\n       *  be done).  If a buffer exists, it is @a consumed, with\n       *  <em>some effect</em> on the controlled sequence.\n       *  (Typically, the buffer is written out to the sequence\n       *  verbatim.)  In either case, the character @a c is also\n       *  written out, if @a __c is not @c eof().\n       *\n       *  For a formal definition of this function, see a good text\n       *  such as Langer & Kreft, or [27.5.2.4.5]/3-7.\n       *\n       *  A functioning output streambuf can be created by overriding only\n       *  this function (no buffer area will be used).\n       *\n       *  @note  Base class version does nothing, returns eof().\n      */\n      virtual int_type\n      overflow(int_type __c _IsUnused  = traits_type::eof())\n      { return traits_type::eof(); }\n\n#if _GLIBCXX_USE_DEPRECATED && __cplusplus <= 201402L\n    // Annex D.6 (removed in C++17)\n    public:\n      /**\n       *  @brief  Tosses a character.\n       *\n       *  Advances the read pointer, ignoring the character that would have\n       *  been read.\n       *\n       *  See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html\n       */\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::basic_streambuf::sbumpc\")\n      void\n      stossc()\n      {\n\tif (this->gptr() < this->egptr())\n\t  this->gbump(1);\n\telse\n\t  this->uflow();\n      }\n#endif\n\n      // Also used by specializations for char and wchar_t in src.\n      void\n      __safe_gbump(streamsize __n) { _M_in_cur += __n; }\n\n      void\n      __safe_pbump(streamsize __n) { _M_out_cur += __n; }\n\n#if __cplusplus < 201103L\n    private:\n#else\n    protected:\n#endif\n      basic_streambuf(const basic_streambuf&);\n\n      basic_streambuf&\n      operator=(const basic_streambuf&);\n\n#if __cplusplus >= 201103L\n      void\n      swap(basic_streambuf& __sb)\n      {\n\tstd::swap(_M_in_beg, __sb._M_in_beg);\n\tstd::swap(_M_in_cur, __sb._M_in_cur);\n\tstd::swap(_M_in_end, __sb._M_in_end);\n\tstd::swap(_M_out_beg, __sb._M_out_beg);\n\tstd::swap(_M_out_cur, __sb._M_out_cur);\n\tstd::swap(_M_out_end, __sb._M_out_end);\n\tstd::swap(_M_buf_locale, __sb._M_buf_locale);\n      }\n#endif\n    };\n\n#if __cplusplus >= 201103L\n  template<typename _CharT, typename _Traits>\n    std::basic_streambuf<_CharT, _Traits>::\n    basic_streambuf(const basic_streambuf&) = default;\n\n  template<typename _CharT, typename _Traits>\n    std::basic_streambuf<_CharT, _Traits>&\n    std::basic_streambuf<_CharT, _Traits>::\n    operator=(const basic_streambuf&) = default;\n#endif\n\n  // Explicit specialization declarations, defined in src/streambuf.cc.\n  template<>\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<char>* __sbin,\n\t\t\t  basic_streambuf<char>* __sbout, bool& __ineof);\n#ifdef _GLIBCXX_USE_WCHAR_T\n  template<>\n    streamsize\n    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,\n\t\t\t  basic_streambuf<wchar_t>* __sbout, bool& __ineof);\n#endif\n\n#undef _IsUnused\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#include <bits/streambuf.tcc>\n\n#endif /* _GLIBCXX_STREAMBUF */\n"}],"crc32":234121651,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]