[{"ops":[{"insert":"/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997-2021 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 3, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nUnder Section 7 of GPL version 3, you are granted additional\npermissions described in the GCC Runtime Library Exception, version\n3.1, as published by the Free Software Foundation.\n\nYou should have received a copy of the GNU General Public License and\na copy of the GCC Runtime Library Exception along with this program;\nsee the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n<http://www.gnu.org/licenses/>.  */\n\n#ifndef _GLIBCXX_GCC_GTHR_POSIX_H\n#define _GLIBCXX_GCC_GTHR_POSIX_H\n\n/* POSIX threads specific definitions.\n   Easy, since the interface is just one-to-one mapping.  */\n\n#define __GTHREADS 1\n#define __GTHREADS_CXX0X 1\n\n#include <pthread.h>\n\n#if ((defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)) \\\n     || !defined(_GTHREAD_USE_MUTEX_TIMEDLOCK))\n# include <unistd.h>\n# if defined(_POSIX_TIMEOUTS) && _POSIX_TIMEOUTS >= 0\n#  define _GTHREAD_USE_MUTEX_TIMEDLOCK 1\n# else\n#  define _GTHREAD_USE_MUTEX_TIMEDLOCK 0\n# endif\n#endif\n\ntypedef pthread_t __gthread_t;\ntypedef pthread_key_t __gthread_key_t;\ntypedef pthread_once_t __gthread_once_t;\ntypedef pthread_mutex_t __gthread_mutex_t;\ntypedef pthread_mutex_t __gthread_recursive_mutex_t;\ntypedef pthread_cond_t __gthread_cond_t;\ntypedef struct timespec __gthread_time_t;\n\n/* POSIX like conditional variables are supported.  Please look at comments\n   in gthr.h for details. */\n#define __GTHREAD_HAS_COND\t1\n\n#define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n#if defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER)\n#define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER\n#elif defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)\n#define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n#else\n#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n#endif\n#define __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER\n#define __GTHREAD_TIME_INIT {0,0}\n\n#ifdef _GTHREAD_USE_MUTEX_INIT_FUNC\n# undef __GTHREAD_MUTEX_INIT\n#endif\n#ifdef _GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC\n# undef __GTHREAD_RECURSIVE_MUTEX_INIT\n# undef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION\n# define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n#endif\n#ifdef _GTHREAD_USE_COND_INIT_FUNC\n# undef __GTHREAD_COND_INIT\n# define __GTHREAD_COND_INIT_FUNCTION __gthread_cond_init_function\n#endif\n\n#if __GXX_WEAK__ && _GLIBCXX_GTHREAD_USE_WEAK\n# ifndef __gthrw_pragma\n#  define __gthrw_pragma(pragma)\n# endif\n# define __gthrw2(name,name2,type) \\\n  static __typeof(type) name \\\n    __attribute__ ((__weakref__(#name2), __copy__ (type))); \\\n  __gthrw_pragma(weak type)\n# define __gthrw_(name) __gthrw_ ## name\n#else\n# define __gthrw2(name,name2,type)\n# define __gthrw_(name) name\n#endif\n\n/* Typically, __gthrw_foo is a weak reference to symbol foo.  */\n#define __gthrw(name) __gthrw2(__gthrw_ ## name,name,name)\n\n__gthrw(pthread_once)\n__gthrw(pthread_getspecific)\n__gthrw(pthread_setspecific)\n\n__gthrw(pthread_create)\n__gthrw(pthread_join)\n__gthrw(pthread_equal)\n__gthrw(pthread_self)\n__gthrw(pthread_detach)\n#ifndef __BIONIC__\n__gthrw(pthread_cancel)\n#endif\n__gthrw(sched_yield)\n\n__gthrw(pthread_mutex_lock)\n__gthrw(pthread_mutex_trylock)\n#if _GTHREAD_USE_MUTEX_TIMEDLOCK\n__gthrw(pthread_mutex_timedlock)\n#endif\n__gthrw(pthread_mutex_unlock)\n__gthrw(pthread_mutex_init)\n__gthrw(pthread_mutex_destroy)\n\n__gthrw(pthread_cond_init)\n__gthrw(pthread_cond_broadcast)\n__gthrw(pthread_cond_signal)\n__gthrw(pthread_cond_wait)\n__gthrw(pthread_cond_timedwait)\n__gthrw(pthread_cond_destroy)\n\n__gthrw(pthread_key_create)\n__gthrw(pthread_key_delete)\n__gthrw(pthread_mutexattr_init)\n__gthrw(pthread_mutexattr_settype)\n__gthrw(pthread_mutexattr_destroy)\n\n\n#if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n/* Objective-C.  */\n__gthrw(pthread_exit)\n#ifdef _POSIX_PRIORITY_SCHEDULING\n#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n__gthrw(sched_get_priority_max)\n__gthrw(sched_get_priority_min)\n#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n#endif /* _POSIX_PRIORITY_SCHEDULING */\n__gthrw(pthread_attr_destroy)\n__gthrw(pthread_attr_init)\n__gthrw(pthread_attr_setdetachstate)\n#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n__gthrw(pthread_getschedparam)\n__gthrw(pthread_setschedparam)\n#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n#endif /* _LIBOBJC || _LIBOBJC_WEAK */\n\n#if __GXX_WEAK__ && _GLIBCXX_GTHREAD_USE_WEAK\n\n/* On Solaris 2.6 up to 9, the libc exposes a POSIX threads interface even if\n   -pthreads is not specified.  The functions are dummies and most return an\n   error value.  However pthread_once returns 0 without invoking the routine\n   it is passed so we cannot pretend that the interface is active if -pthreads\n   is not specified.  On Solaris 2.5.1, the interface is not exposed at all so\n   we need to play the usual game with weak symbols.  On Solaris 10 and up, a\n   working interface is always exposed.  On FreeBSD 6 and later, libc also\n   exposes a dummy POSIX threads interface, similar to what Solaris 2.6 up\n   to 9 does.  FreeBSD >= 700014 even provides a pthread_cancel stub in libc,\n   which means the alternate __gthread_active_p below cannot be used there.  */\n\n#if defined(__FreeBSD__) || (defined(__sun) && defined(__svr4__))\n\nstatic volatile int __gthread_active = -1;\n\nstatic void\n__gthread_trigger (void)\n{\n  __gthread_active = 1;\n}\n\nstatic inline int\n__gthread_active_p (void)\n{\n  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;\n  static pthread_once_t __gthread_active_once = PTHREAD_ONCE_INIT;\n\n  /* Avoid reading __gthread_active twice on the main code path.  */\n  int __gthread_active_latest_value = __gthread_active;\n\n  /* This test is not protected to avoid taking a lock on the main code\n     path so every update of __gthread_active in a threaded program must\n     be atomic with regard to the result of the test.  */\n  if (__builtin_expect (__gthread_active_latest_value < 0, 0))\n    {\n      if (__gthrw_(pthread_once))\n\t{\n\t  /* If this really is a threaded program, then we must ensure that\n\t     __gthread_active has been set to 1 before exiting this block.  */\n\t  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);\n\t  __gthrw_(pthread_once) (&__gthread_active_once, __gthread_trigger);\n\t  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);\n\t}\n\n      /* Make sure we'll never enter this block again.  */\n      if (__gthread_active < 0)\n\t__gthread_active = 0;\n\n      __gthread_active_latest_value = __gthread_active;\n    }\n\n  return __gthread_active_latest_value != 0;\n}\n\n#else /* neither FreeBSD nor Solaris */\n\n/* For a program to be multi-threaded the only thing that it certainly must\n   be using is pthread_create.  However, there may be other libraries that\n   intercept pthread_create with their own definitions to wrap pthreads\n   functionality for some purpose.  In those cases, pthread_create being\n   defined might not necessarily mean that libpthread is actually linked\n   in.\n\n   For the GNU C library, we can use a known internal name.  This is always\n   available in the ABI, but no other library would define it.  That is\n   ideal, since any public pthread function might be intercepted just as\n   pthread_create might be.  __pthread_key_create is an \"internal\"\n   implementation symbol, but it is part of the public exported ABI.  Also,\n   it's among the symbols that the static libpthread.a always links in\n   whenever pthread_create is used, so there is no danger of a false\n   negative result in any statically-linked, multi-threaded program.\n\n   For others, we choose pthread_cancel as a function that seems unlikely\n   to be redefined by an interceptor library.  The bionic (Android) C\n   library does not provide pthread_cancel, so we do use pthread_create\n   there (and interceptor libraries lose).  */\n\n#ifdef __GLIBC__\n__gthrw2(__gthrw_(__pthread_key_create),\n\t __pthread_key_create,\n\t pthread_key_create)\n# define GTHR_ACTIVE_PROXY\t__gthrw_(__pthread_key_create)\n#elif defined (__BIONIC__)\n# define GTHR_ACTIVE_PROXY\t__gthrw_(pthread_create)\n#else\n# define GTHR_ACTIVE_PROXY\t__gthrw_(pthread_cancel)\n#endif\n\nstatic inline int\n__gthread_active_p (void)\n{\n  static void *const __gthread_active_ptr\n    = __extension__ (void *) &GTHR_ACTIVE_PROXY;\n  return __gthread_active_ptr != 0;\n}\n\n#endif /* FreeBSD or Solaris */\n\n#else /* not __GXX_WEAK__ */\n\n/* Similar to Solaris, HP-UX 11 for PA-RISC provides stubs for pthread\n   calls in shared flavors of the HP-UX C library.  Most of the stubs\n   have no functionality.  The details are described in the \"libc cumulative\n   patch\" for each subversion of HP-UX 11.  There are two special interfaces\n   provided for checking whether an application is linked to a shared pthread\n   library or not.  However, these interfaces aren't available in early\n   libpthread libraries.  We also need a test that works for archive\n   libraries.  We can't use pthread_once as some libc versions call the\n   init function.  We also can't use pthread_create or pthread_attr_init\n   as these create a thread and thereby prevent changing the default stack\n   size.  The function pthread_default_stacksize_np is available in both\n   the archive and shared versions of libpthread.   It can be used to\n   determine the default pthread stack size.  There is a stub in some\n   shared libc versions which returns a zero size if pthreads are not\n   active.  We provide an equivalent stub to handle cases where libc\n   doesn't provide one.  */\n\n#if defined(__hppa__) && defined(__hpux__)\n\nstatic volatile int __gthread_active = -1;\n\nstatic inline int\n__gthread_active_p (void)\n{\n  /* Avoid reading __gthread_active twice on the main code path.  */\n  int __gthread_active_latest_value = __gthread_active;\n  size_t __s;\n\n  if (__builtin_expect (__gthread_active_latest_value < 0, 0))\n    {\n      pthread_default_stacksize_np (0, &__s);\n      __gthread_active = __s ? 1 : 0;\n      __gthread_active_latest_value = __gthread_active;\n    }\n\n  return __gthread_active_latest_value != 0;\n}\n\n#else /* not hppa-hpux */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  return 1;\n}\n\n#endif /* hppa-hpux */\n\n#endif /* __GXX_WEAK__ */\n\n#ifdef _LIBOBJC\n\n/* This is the config.h file in libobjc/ */\n#include <config.h>\n\n#ifdef HAVE_SCHED_H\n# include <sched.h>\n#endif\n\n/* Key structure for maintaining thread specific storage */\nstatic pthread_key_t _objc_thread_storage;\nstatic pthread_attr_t _objc_thread_attribs;\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nstatic inline int\n__gthread_objc_init_thread_system (void)\n{\n  if (__gthread_active_p ())\n    {\n      /* Initialize the thread storage key.  */\n      if (__gthrw_(pthread_key_create) (&_objc_thread_storage, NULL) == 0)\n\t{\n\t  /* The normal default detach state for threads is\n\t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n\t   * when you think they should.  */\n\t  if (__gthrw_(pthread_attr_init) (&_objc_thread_attribs) == 0\n\t      && __gthrw_(pthread_attr_setdetachstate) (&_objc_thread_attribs,\n\t\t\t\t\t      PTHREAD_CREATE_DETACHED) == 0)\n\t    return 0;\n\t}\n    }\n\n  return -1;\n}\n\n/* Close the threads subsystem.  */\nstatic inline int\n__gthread_objc_close_thread_system (void)\n{\n  if (__gthread_active_p ()\n      && __gthrw_(pthread_key_delete) (_objc_thread_storage) == 0\n      && __gthrw_(pthread_attr_destroy) (&_objc_thread_attribs) == 0)\n    return 0;\n\n  return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_detach (void (*func)(void *), void *arg)\n{\n  objc_thread_t thread_id;\n  pthread_t new_thread_handle;\n\n  if (!__gthread_active_p ())\n    return NULL;\n\n  if (!(__gthrw_(pthread_create) (&new_thread_handle, &_objc_thread_attribs,\n\t\t\t\t  (void *) func, arg)))\n    thread_id = (objc_thread_t) new_thread_handle;\n  else\n    thread_id = NULL;\n\n  return thread_id;\n}\n\n/* Set the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_set_priority (int priority)\n{\n  if (!__gthread_active_p ())\n    return -1;\n  else\n    {\n#ifdef _POSIX_PRIORITY_SCHEDULING\n#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n      pthread_t thread_id = __gthrw_(pthread_self) ();\n      int policy;\n      struct sched_param params;\n      int priority_min, priority_max;\n\n      if (__gthrw_(pthread_getschedparam) (thread_id, &policy, &params) == 0)\n\t{\n\t  if ((priority_max = __gthrw_(sched_get_priority_max) (policy)) == -1)\n\t    return -1;\n\n\t  if ((priority_min = __gthrw_(sched_get_priority_min) (policy)) == -1)\n\t    return -1;\n\n\t  if (priority > priority_max)\n\t    priority = priority_max;\n\t  else if (priority < priority_min)\n\t    priority = priority_min;\n\t  params.sched_priority = priority;\n\n\t  /*\n\t   * The solaris 7 and several other man pages incorrectly state that\n\t   * this should be a pointer to policy but pthread.h is universally\n\t   * at odds with this.\n\t   */\n\t  if (__gthrw_(pthread_setschedparam) (thread_id, policy, &params) == 0)\n\t    return 0;\n\t}\n#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n#endif /* _POSIX_PRIORITY_SCHEDULING */\n      return -1;\n    }\n}\n\n/* Return the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_get_priority (void)\n{\n#ifdef _POSIX_PRIORITY_SCHEDULING\n#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n  if (__gthread_active_p ())\n    {\n      int policy;\n      struct sched_param params;\n\n      if (__gthrw_(pthread_getschedparam) (__gthrw_(pthread_self) (), &policy, &params) == 0)\n\treturn params.sched_priority;\n      else\n\treturn -1;\n    }\n  else\n#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n#endif /* _POSIX_PRIORITY_SCHEDULING */\n    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n}\n\n/* Yield our process time to another thread.  */\nstatic inline void\n__gthread_objc_thread_yield (void)\n{\n  if (__gthread_active_p ())\n    __gthrw_(sched_yield) ();\n}\n\n/* Terminate the current thread.  */\nstatic inline int\n__gthread_objc_thread_exit (void)\n{\n  if (__gthread_active_p ())\n    /* exit the thread */\n    __gthrw_(pthread_exit) (&__objc_thread_exit_status);\n\n  /* Failed if we reached here */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_id (void)\n{\n  if (__gthread_active_p ())\n    return (objc_thread_t) __gthrw_(pthread_self) ();\n  else\n    return (objc_thread_t) 1;\n}\n\n/* Sets the thread's local storage pointer.  */\nstatic inline int\n__gthread_objc_thread_set_data (void *value)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_setspecific) (_objc_thread_storage, value);\n  else\n    {\n      thread_local_storage = value;\n      return 0;\n    }\n}\n\n/* Returns the thread's local storage pointer.  */\nstatic inline void *\n__gthread_objc_thread_get_data (void)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_getspecific) (_objc_thread_storage);\n  else\n    return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_allocate (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n\n      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex->backend, NULL))\n\t{\n\t  objc_free (mutex->backend);\n\t  mutex->backend = NULL;\n\t  return -1;\n\t}\n    }\n\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      int count;\n\n      /*\n       * Posix Threads specifically require that the thread be unlocked\n       * for __gthrw_(pthread_mutex_destroy) to work.\n       */\n\n      do\n\t{\n\t  count = __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend);\n\t  if (count < 0)\n\t    return -1;\n\t}\n      while (count);\n\n      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex->backend))\n\treturn -1;\n\n      objc_free (mutex->backend);\n      mutex->backend = NULL;\n    }\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_lock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && __gthrw_(pthread_mutex_lock) ((pthread_mutex_t *) mutex->backend) != 0)\n    {\n      return -1;\n    }\n\n  return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_trylock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex->backend) != 0)\n    {\n      return -1;\n    }\n\n  return 0;\n}\n\n/* Unlock the mutex */\nstatic inline int\n__gthread_objc_mutex_unlock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend) != 0)\n    {\n      return -1;\n    }\n\n  return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nstatic inline int\n__gthread_objc_condition_allocate (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    {\n      condition->backend = objc_malloc (sizeof (pthread_cond_t));\n\n      if (__gthrw_(pthread_cond_init) ((pthread_cond_t *) condition->backend, NULL))\n\t{\n\t  objc_free (condition->backend);\n\t  condition->backend = NULL;\n\t  return -1;\n\t}\n    }\n\n  return 0;\n}\n\n/* Deallocate a condition.  */\nstatic inline int\n__gthread_objc_condition_deallocate (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    {\n      if (__gthrw_(pthread_cond_destroy) ((pthread_cond_t *) condition->backend))\n\treturn -1;\n\n      objc_free (condition->backend);\n      condition->backend = NULL;\n    }\n  return 0;\n}\n\n/* Wait on the condition */\nstatic inline int\n__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_cond_wait) ((pthread_cond_t *) condition->backend,\n\t\t\t      (pthread_mutex_t *) mutex->backend);\n  else\n    return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_broadcast (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_cond_broadcast) ((pthread_cond_t *) condition->backend);\n  else\n    return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_signal (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_cond_signal) ((pthread_cond_t *) condition->backend);\n  else\n    return 0;\n}\n\n#else /* _LIBOBJC */\n\nstatic inline int\n__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),\n\t\t  void *__args)\n{\n  return __gthrw_(pthread_create) (__threadid, NULL, __func, __args);\n}\n\nstatic inline int\n__gthread_join (__gthread_t __threadid, void **__value_ptr)\n{\n  return __gthrw_(pthread_join) (__threadid, __value_ptr);\n}\n\nstatic inline int\n__gthread_detach (__gthread_t __threadid)\n{\n  return __gthrw_(pthread_detach) (__threadid);\n}\n\nstatic inline int\n__gthread_equal (__gthread_t __t1, __gthread_t __t2)\n{\n  return __gthrw_(pthread_equal) (__t1, __t2);\n}\n\nstatic inline __gthread_t\n__gthread_self (void)\n{\n  return __gthrw_(pthread_self) ();\n}\n\nstatic inline int\n__gthread_yield (void)\n{\n  return __gthrw_(sched_yield) ();\n}\n\nstatic inline int\n__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_once) (__once, __func);\n  else\n    return -1;\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n{\n  return __gthrw_(pthread_key_create) (__key, __dtor);\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t __key)\n{\n  return __gthrw_(pthread_key_delete) (__key);\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t __key)\n{\n  return __gthrw_(pthread_getspecific) (__key);\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n{\n  return __gthrw_(pthread_setspecific) (__key, __ptr);\n}\n\nstatic inline void\n__gthread_mutex_init_function (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    __gthrw_(pthread_mutex_init) (__mutex, NULL);\n}\n\nstatic inline int\n__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_mutex_destroy) (__mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_mutex_lock) (__mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_mutex_trylock) (__mutex);\n  else\n    return 0;\n}\n\n#if _GTHREAD_USE_MUTEX_TIMEDLOCK\nstatic inline int\n__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,\n\t\t\t   const __gthread_time_t *__abs_timeout)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_mutex_timedlock) (__mutex, __abs_timeout);\n  else\n    return 0;\n}\n#endif\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    return __gthrw_(pthread_mutex_unlock) (__mutex);\n  else\n    return 0;\n}\n\n#if !defined( PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP) \\\n  || defined(_GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC)\nstatic inline int\n__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n{\n  if (__gthread_active_p ())\n    {\n      pthread_mutexattr_t __attr;\n      int __r;\n\n      __r = __gthrw_(pthread_mutexattr_init) (&__attr);\n      if (!__r)\n\t__r = __gthrw_(pthread_mutexattr_settype) (&__attr,\n\t\t\t\t\t\t   PTHREAD_MUTEX_RECURSIVE);\n      if (!__r)\n\t__r = __gthrw_(pthread_mutex_init) (__mutex, &__attr);\n      if (!__r)\n\t__r = __gthrw_(pthread_mutexattr_destroy) (&__attr);\n      return __r;\n    }\n  return 0;\n}\n#endif\n\nstatic inline int\n__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_mutex_lock (__mutex);\n}\n\nstatic inline int\n__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_mutex_trylock (__mutex);\n}\n\n#if _GTHREAD_USE_MUTEX_TIMEDLOCK\nstatic inline int\n__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,\n\t\t\t\t     const __gthread_time_t *__abs_timeout)\n{\n  return __gthread_mutex_timedlock (__mutex, __abs_timeout);\n}\n#endif\n\nstatic inline int\n__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_mutex_unlock (__mutex);\n}\n\nstatic inline int\n__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_mutex_destroy (__mutex);\n}\n\n#ifdef _GTHREAD_USE_COND_INIT_FUNC\nstatic inline void\n__gthread_cond_init_function (__gthread_cond_t *__cond)\n{\n  if (__gthread_active_p ())\n    __gthrw_(pthread_cond_init) (__cond, NULL);\n}\n#endif\n\nstatic inline int\n__gthread_cond_broadcast (__gthread_cond_t *__cond)\n{\n  return __gthrw_(pthread_cond_broadcast) (__cond);\n}\n\nstatic inline int\n__gthread_cond_signal (__gthread_cond_t *__cond)\n{\n  return __gthrw_(pthread_cond_signal) (__cond);\n}\n\nstatic inline int\n__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)\n{\n  return __gthrw_(pthread_cond_wait) (__cond, __mutex);\n}\n\nstatic inline int\n__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,\n\t\t\t  const __gthread_time_t *__abs_timeout)\n{\n  return __gthrw_(pthread_cond_timedwait) (__cond, __mutex, __abs_timeout);\n}\n\nstatic inline int\n__gthread_cond_wait_recursive (__gthread_cond_t *__cond,\n\t\t\t       __gthread_recursive_mutex_t *__mutex)\n{\n  return __gthread_cond_wait (__cond, __mutex);\n}\n\nstatic inline int\n__gthread_cond_destroy (__gthread_cond_t* __cond)\n{\n  return __gthrw_(pthread_cond_destroy) (__cond);\n}\n\n#endif /* _LIBOBJC */\n\n#endif /* ! _GLIBCXX_GCC_GTHR_POSIX_H */\n"}],"crc32":3428379265,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]