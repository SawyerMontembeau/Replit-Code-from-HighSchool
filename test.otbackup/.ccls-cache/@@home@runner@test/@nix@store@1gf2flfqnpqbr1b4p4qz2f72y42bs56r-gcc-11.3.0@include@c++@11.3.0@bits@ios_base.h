[{"ops":[{"insert":"// Iostreams base classes -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/ios_base.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{ios}\n */\n\n//\n// ISO C++ 14882: 27.4  Iostreams base classes\n//\n\n#ifndef _IOS_BASE_H\n#define _IOS_BASE_H 1\n\n#pragma GCC system_header\n\n#include <ext/atomicity.h>\n#include <bits/localefwd.h>\n#include <bits/locale_classes.h>\n\n#if __cplusplus < 201103L\n# include <stdexcept>\n#else\n# include <system_error>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // The following definitions of bitmask types are enums, not ints,\n  // as permitted (but not required) in the standard, in order to provide\n  // better type safety in iostream calls.  A side effect is that in C++98\n  // expressions involving them are not compile-time constants.\n  enum _Ios_Fmtflags \n    { \n      _S_boolalpha \t= 1L << 0,\n      _S_dec \t\t= 1L << 1,\n      _S_fixed \t\t= 1L << 2,\n      _S_hex \t\t= 1L << 3,\n      _S_internal \t= 1L << 4,\n      _S_left \t\t= 1L << 5,\n      _S_oct \t\t= 1L << 6,\n      _S_right \t\t= 1L << 7,\n      _S_scientific \t= 1L << 8,\n      _S_showbase \t= 1L << 9,\n      _S_showpoint \t= 1L << 10,\n      _S_showpos \t= 1L << 11,\n      _S_skipws \t= 1L << 12,\n      _S_unitbuf \t= 1L << 13,\n      _S_uppercase \t= 1L << 14,\n      _S_adjustfield \t= _S_left | _S_right | _S_internal,\n      _S_basefield \t= _S_dec | _S_oct | _S_hex,\n      _S_floatfield \t= _S_scientific | _S_fixed,\n      _S_ios_fmtflags_end = 1L << 16,\n      _S_ios_fmtflags_max = __INT_MAX__,\n      _S_ios_fmtflags_min = ~__INT_MAX__\n    };\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags\n  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags\n  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags\n  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags\n  operator~(_Ios_Fmtflags __a)\n  { return _Ios_Fmtflags(~static_cast<int>(__a)); }\n\n  inline const _Ios_Fmtflags&\n  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n  { return __a = __a | __b; }\n\n  inline const _Ios_Fmtflags&\n  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n  { return __a = __a & __b; }\n\n  inline const _Ios_Fmtflags&\n  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n  { return __a = __a ^ __b; }\n\n\n  enum _Ios_Openmode \n    { \n      _S_app \t\t= 1L << 0,\n      _S_ate \t\t= 1L << 1,\n      _S_bin \t\t= 1L << 2,\n      _S_in \t\t= 1L << 3,\n      _S_out \t\t= 1L << 4,\n      _S_trunc \t\t= 1L << 5,\n      _S_ios_openmode_end = 1L << 16,\n      _S_ios_openmode_max = __INT_MAX__,\n      _S_ios_openmode_min = ~__INT_MAX__\n    };\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Openmode\n  operator&(_Ios_Openmode __a, _Ios_Openmode __b)\n  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Openmode\n  operator|(_Ios_Openmode __a, _Ios_Openmode __b)\n  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Openmode\n  operator^(_Ios_Openmode __a, _Ios_Openmode __b)\n  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Openmode\n  operator~(_Ios_Openmode __a)\n  { return _Ios_Openmode(~static_cast<int>(__a)); }\n\n  inline const _Ios_Openmode&\n  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)\n  { return __a = __a | __b; }\n\n  inline const _Ios_Openmode&\n  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)\n  { return __a = __a & __b; }\n\n  inline const _Ios_Openmode&\n  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)\n  { return __a = __a ^ __b; }\n\n\n  enum _Ios_Iostate\n    { \n      _S_goodbit \t\t= 0,\n      _S_badbit \t\t= 1L << 0,\n      _S_eofbit \t\t= 1L << 1,\n      _S_failbit\t\t= 1L << 2,\n      _S_ios_iostate_end = 1L << 16,\n      _S_ios_iostate_max = __INT_MAX__,\n      _S_ios_iostate_min = ~__INT_MAX__\n    };\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Iostate\n  operator&(_Ios_Iostate __a, _Ios_Iostate __b)\n  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Iostate\n  operator|(_Ios_Iostate __a, _Ios_Iostate __b)\n  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Iostate\n  operator^(_Ios_Iostate __a, _Ios_Iostate __b)\n  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n\n  inline _GLIBCXX_CONSTEXPR _Ios_Iostate\n  operator~(_Ios_Iostate __a)\n  { return _Ios_Iostate(~static_cast<int>(__a)); }\n\n  inline const _Ios_Iostate&\n  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)\n  { return __a = __a | __b; }\n\n  inline const _Ios_Iostate&\n  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)\n  { return __a = __a & __b; }\n\n  inline const  _Ios_Iostate&\n  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)\n  { return __a = __a ^ __b; }\n\n\n  enum _Ios_Seekdir \n    { \n      _S_beg = 0,\n      _S_cur = _GLIBCXX_STDIO_SEEK_CUR,\n      _S_end = _GLIBCXX_STDIO_SEEK_END,\n      _S_ios_seekdir_end = 1L << 16 \n    };\n\n#if __cplusplus >= 201103L\n  /// I/O error code\n  enum class io_errc { stream = 1 };\n\n  template <> struct is_error_code_enum<io_errc> : public true_type { };\n\n  const error_category& iostream_category() noexcept;\n\n  inline error_code\n  make_error_code(io_errc __e) noexcept\n  { return error_code(static_cast<int>(__e), iostream_category()); }\n\n  inline error_condition\n  make_error_condition(io_errc __e) noexcept\n  { return error_condition(static_cast<int>(__e), iostream_category()); }\n#endif\n\n  // 27.4.2  Class ios_base\n  /**\n   *  @brief  The base of the I/O class hierarchy.\n   *  @ingroup io\n   *\n   *  This class defines everything that can be defined about I/O that does\n   *  not depend on the type of characters being input or output.  Most\n   *  people will only see @c ios_base when they need to specify the full\n   *  name of the various I/O flags (e.g., the openmodes).\n  */\n  class ios_base\n  {\n#if _GLIBCXX_USE_CXX11_ABI\n#if __cplusplus < 201103L\n    // Type that is layout-compatible with std::system_error\n    struct system_error : std::runtime_error\n    {\n      // Type that is layout-compatible with std::error_code\n      struct error_code\n      {\n\terror_code() { }\n      private:\n\tint\t\t_M_value;\n\tconst void*\t_M_cat;\n      } _M_code;\n    };\n#endif\n#endif\n  public:\n\n    /** \n     *  @brief These are thrown to indicate problems with io.\n     *  @ingroup exceptions\n     *\n     *  27.4.2.1.1  Class ios_base::failure\n     */\n#if _GLIBCXX_USE_CXX11_ABI\n    class _GLIBCXX_ABI_TAG_CXX11 failure : public system_error\n    {\n    public:\n      explicit\n      failure(const string& __str);\n\n#if __cplusplus >= 201103L\n      explicit\n      failure(const string&, const error_code&);\n\n      explicit\n      failure(const char*, const error_code& = io_errc::stream);\n#endif\n\n      virtual\n      ~failure() throw();\n\n      virtual const char*\n      what() const throw();\n    };\n#else\n    class failure : public exception\n    {\n    public:\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 48.  Use of non-existent exception constructor\n      explicit\n      failure(const string& __str) throw();\n\n      // This declaration is not useless:\n      // http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Vague-Linkage.html\n      virtual\n      ~failure() throw();\n\n      virtual const char*\n      what() const throw();\n\n#if __cplusplus >= 201103L\n      // Define the new members required by C++11,\n      // even though the error_code cannot be stored.\n\n      explicit\n      failure(const string& __s, const error_code&) noexcept\n      : failure(__s)\n      { }\n\n      explicit\n      failure(const char* __s, const error_code& = error_code{})\n      : failure(string(__s))\n      { }\n\n      // Stand-in for system_error::code() but returning by value.\n      error_code code() const noexcept { return error_code{}; }\n#endif\n\n    private:\n      string _M_msg;\n    };\n#endif\n\n    // 27.4.2.1.2  Type ios_base::fmtflags\n    /**\n     *  @brief This is a bitmask type.\n     *\n     *  @c @a _Ios_Fmtflags is implementation-defined, but it is valid to\n     *  perform bitwise operations on these values and expect the Right\n     *  Thing to happen.  Defined objects of type fmtflags are:\n     *  - boolalpha\n     *  - dec\n     *  - fixed\n     *  - hex\n     *  - internal\n     *  - left\n     *  - oct\n     *  - right\n     *  - scientific\n     *  - showbase\n     *  - showpoint\n     *  - showpos\n     *  - skipws\n     *  - unitbuf\n     *  - uppercase\n     *  - adjustfield\n     *  - basefield\n     *  - floatfield\n    */\n    typedef _Ios_Fmtflags fmtflags;\n\n    /// Insert/extract @c bool in alphabetic rather than numeric format.\n    static const fmtflags boolalpha =   _S_boolalpha;\n\n    /// Converts integer input or generates integer output in decimal base.\n    static const fmtflags dec =         _S_dec;\n\n    /// Generate floating-point output in fixed-point notation.\n    static const fmtflags fixed =       _S_fixed;\n\n    /// Converts integer input or generates integer output in hexadecimal base.\n    static const fmtflags hex =         _S_hex;\n\n    /// Adds fill characters at a designated internal point in certain\n    /// generated output, or identical to @c right if no such point is\n    /// designated.\n    static const fmtflags internal =    _S_internal;\n\n    /// Adds fill characters on the right (final positions) of certain\n    /// generated output.  (I.e., the thing you print is flush left.)\n    static const fmtflags left =        _S_left;\n\n    /// Converts integer input or generates integer output in octal base.\n    static const fmtflags oct =         _S_oct;\n\n    /// Adds fill characters on the left (initial positions) of certain\n    /// generated output.  (I.e., the thing you print is flush right.)\n    static const fmtflags right =       _S_right;\n\n    /// Generates floating-point output in scientific notation.\n    static const fmtflags scientific =  _S_scientific;\n\n    /// Generates a prefix indicating the numeric base of generated integer\n    /// output.\n    static const fmtflags showbase =    _S_showbase;\n\n    /// Generates a decimal-point character unconditionally in generated\n    /// floating-point output.\n    static const fmtflags showpoint =   _S_showpoint;\n\n    /// Generates a + sign in non-negative generated numeric output.\n    static const fmtflags showpos =     _S_showpos;\n\n    /// Skips leading white space before certain input operations.\n    static const fmtflags skipws =      _S_skipws;\n\n    /// Flushes output after each output operation.\n    static const fmtflags unitbuf =     _S_unitbuf;\n\n    /// Replaces certain lowercase letters with their uppercase equivalents\n    /// in generated output.\n    static const fmtflags uppercase =   _S_uppercase;\n\n    /// A mask of left|right|internal.  Useful for the 2-arg form of @c setf.\n    static const fmtflags adjustfield = _S_adjustfield;\n\n    /// A mask of dec|oct|hex.  Useful for the 2-arg form of @c setf.\n    static const fmtflags basefield =   _S_basefield;\n\n    /// A mask of scientific|fixed.  Useful for the 2-arg form of @c setf.\n    static const fmtflags floatfield =  _S_floatfield;\n\n    // 27.4.2.1.3  Type ios_base::iostate\n    /**\n     *  @brief This is a bitmask type.\n     *\n     *  @c @a _Ios_Iostate is implementation-defined, but it is valid to\n     *  perform bitwise operations on these values and expect the Right\n     *  Thing to happen.  Defined objects of type iostate are:\n     *  - badbit\n     *  - eofbit\n     *  - failbit\n     *  - goodbit\n    */\n    typedef _Ios_Iostate iostate;\n\n    /// Indicates a loss of integrity in an input or output sequence (such\n    /// as an irrecoverable read error from a file).\n    static const iostate badbit =\t_S_badbit;\n\n    /// Indicates that an input operation reached the end of an input sequence.\n    static const iostate eofbit =\t_S_eofbit;\n\n    /// Indicates that an input operation failed to read the expected\n    /// characters, or that an output operation failed to generate the\n    /// desired characters.\n    static const iostate failbit =\t_S_failbit;\n\n    /// Indicates all is well.\n    static const iostate goodbit =\t_S_goodbit;\n\n    // 27.4.2.1.4  Type ios_base::openmode\n    /**\n     *  @brief This is a bitmask type.\n     *\n     *  @c @a _Ios_Openmode is implementation-defined, but it is valid to\n     *  perform bitwise operations on these values and expect the Right\n     *  Thing to happen.  Defined objects of type openmode are:\n     *  - app\n     *  - ate\n     *  - binary\n     *  - in\n     *  - out\n     *  - trunc\n    */\n    typedef _Ios_Openmode openmode;\n\n    /// Seek to end before each write.\n    static const openmode app =\t\t_S_app;\n\n    /// Open and seek to end immediately after opening.\n    static const openmode ate =\t\t_S_ate;\n\n    /// Perform input and output in binary mode (as opposed to text mode).\n    /// This is probably not what you think it is; see\n    /// https://gcc.gnu.org/onlinedocs/libstdc++/manual/fstreams.html#std.io.filestreams.binary\n    static const openmode binary =\t_S_bin;\n\n    /// Open for input.  Default for @c ifstream and fstream.\n    static const openmode in =\t\t_S_in;\n\n    /// Open for output.  Default for @c ofstream and fstream.\n    static const openmode out =\t\t_S_out;\n\n    /// Truncate an existing stream when opening.  Default for @c ofstream.\n    static const openmode trunc =\t_S_trunc;\n\n    // 27.4.2.1.5  Type ios_base::seekdir\n    /**\n     *  @brief This is an enumerated type.\n     *\n     *  @c @a _Ios_Seekdir is implementation-defined.  Defined values\n     *  of type seekdir are:\n     *  - beg\n     *  - cur, equivalent to @c SEEK_CUR in the C standard library.\n     *  - end, equivalent to @c SEEK_END in the C standard library.\n    */\n    typedef _Ios_Seekdir seekdir;\n\n    /// Request a seek relative to the beginning of the stream.\n    static const seekdir beg =\t\t_S_beg;\n\n    /// Request a seek relative to the current position within the sequence.\n    static const seekdir cur =\t\t_S_cur;\n\n    /// Request a seek relative to the current end of the sequence.\n    static const seekdir end =\t\t_S_end;\n\n#if __cplusplus <= 201402L\n    // Annex D.6 (removed in C++17)\n    typedef int io_state\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::iostate\");\n    typedef int open_mode\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::openmode\");\n    typedef int seek_dir\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::seekdir\");\n\n    typedef std::streampos streampos\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::streampos\");\n    typedef std::streamoff streamoff\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::streamoff\");\n#endif\n\n    // Callbacks;\n    /**\n     *  @brief  The set of events that may be passed to an event callback.\n     *\n     *  erase_event is used during ~ios() and copyfmt().  imbue_event is used\n     *  during imbue().  copyfmt_event is used during copyfmt().\n    */\n    enum event\n    {\n      erase_event,\n      imbue_event,\n      copyfmt_event\n    };\n\n    /**\n     *  @brief  The type of an event callback function.\n     *  @param  __e  One of the members of the event enum.\n     *  @param  __b  Reference to the ios_base object.\n     *  @param  __i  The integer provided when the callback was registered.\n     *\n     *  Event callbacks are user defined functions that get called during\n     *  several ios_base and basic_ios functions, specifically imbue(),\n     *  copyfmt(), and ~ios().\n    */\n    typedef void (*event_callback) (event __e, ios_base& __b, int __i);\n\n    /**\n     *  @brief  Add the callback __fn with parameter __index.\n     *  @param  __fn  The function to add.\n     *  @param  __index  The integer to pass to the function when invoked.\n     *\n     *  Registers a function as an event callback with an integer parameter to\n     *  be passed to the function when invoked.  Multiple copies of the\n     *  function are allowed.  If there are multiple callbacks, they are\n     *  invoked in the order they were registered.\n    */\n    void\n    register_callback(event_callback __fn, int __index);\n\n  protected:\n    streamsize\t\t_M_precision;\n    streamsize\t\t_M_width;\n    fmtflags\t\t_M_flags;\n    iostate\t\t_M_exception;\n    iostate\t\t_M_streambuf_state;\n\n    // 27.4.2.6  Members for callbacks\n    // 27.4.2.6  ios_base callbacks\n    struct _Callback_list\n    {\n      // Data Members\n      _Callback_list*\t\t_M_next;\n      ios_base::event_callback\t_M_fn;\n      int\t\t\t_M_index;\n      _Atomic_word\t\t_M_refcount;  // 0 means one reference.\n\n      _Callback_list(ios_base::event_callback __fn, int __index,\n\t\t     _Callback_list* __cb)\n      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }\n\n      void\n      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n      // 0 => OK to delete.\n      int\n      _M_remove_reference() \n      {\n        // Be race-detector-friendly.  For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_refcount);\n        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);\n        if (__res == 0)\n          {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_refcount);\n          }\n        return __res;\n      }\n    };\n\n     _Callback_list*\t_M_callbacks;\n\n    void\n    _M_call_callbacks(event __ev) throw();\n\n    void\n    _M_dispose_callbacks(void) throw();\n\n    // 27.4.2.5  Members for iword/pword storage\n    struct _Words\n    {\n      void*\t_M_pword;\n      long\t_M_iword;\n      _Words() : _M_pword(0), _M_iword(0) { }\n    };\n\n    // Only for failed iword/pword calls.\n    _Words\t\t_M_word_zero;\n\n    // Guaranteed storage.\n    // The first 5 iword and pword slots are reserved for internal use.\n    enum { _S_local_word_size = 8 };\n    _Words\t\t_M_local_word[_S_local_word_size];\n\n    // Allocated storage.\n    int\t\t\t_M_word_size;\n    _Words*\t\t_M_word;\n\n    _Words&\n    _M_grow_words(int __index, bool __iword);\n\n    // Members for locale and locale caching.\n    locale\t\t_M_ios_locale;\n\n    void\n    _M_init() throw();\n\n  public:\n\n    // 27.4.2.1.6  Class ios_base::Init\n    // Used to initialize standard streams. In theory, g++ could use\n    // -finit-priority to order this stuff correctly without going\n    // through these machinations.\n    class Init\n    {\n      friend class ios_base;\n    public:\n      Init();\n      ~Init();\n\n#if __cplusplus >= 201103L\n      Init(const Init&) = default;\n      Init& operator=(const Init&) = default;\n#endif\n\n    private:\n      static _Atomic_word\t_S_refcount;\n      static bool\t\t_S_synced_with_stdio;\n    };\n\n    // [27.4.2.2] fmtflags state functions\n    /**\n     *  @brief  Access to format flags.\n     *  @return  The format control flags for both input and output.\n    */\n    fmtflags\n    flags() const\n    { return _M_flags; }\n\n    /**\n     *  @brief  Setting new format flags all at once.\n     *  @param  __fmtfl  The new flags to set.\n     *  @return  The previous format control flags.\n     *\n     *  This function overwrites all the format flags with @a __fmtfl.\n    */\n    fmtflags\n    flags(fmtflags __fmtfl)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags = __fmtfl;\n      return __old;\n    }\n\n    /**\n     *  @brief  Setting new format flags.\n     *  @param  __fmtfl  Additional flags to set.\n     *  @return  The previous format control flags.\n     *\n     *  This function sets additional flags in format control.  Flags that\n     *  were previously set remain set.\n    */\n    fmtflags\n    setf(fmtflags __fmtfl)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags |= __fmtfl;\n      return __old;\n    }\n\n    /**\n     *  @brief  Setting new format flags.\n     *  @param  __fmtfl  Additional flags to set.\n     *  @param  __mask  The flags mask for @a fmtfl.\n     *  @return  The previous format control flags.\n     *\n     *  This function clears @a mask in the format flags, then sets\n     *  @a fmtfl @c & @a mask.  An example mask is @c ios_base::adjustfield.\n    */\n    fmtflags\n    setf(fmtflags __fmtfl, fmtflags __mask)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags &= ~__mask;\n      _M_flags |= (__fmtfl & __mask);\n      return __old;\n    }\n\n    /**\n     *  @brief  Clearing format flags.\n     *  @param  __mask  The flags to unset.\n     *\n     *  This function clears @a __mask in the format flags.\n    */\n    void\n    unsetf(fmtflags __mask)\n    { _M_flags &= ~__mask; }\n\n    /**\n     *  @brief  Flags access.\n     *  @return  The precision to generate on certain output operations.\n     *\n     *  Be careful if you try to give a definition of @a precision here; see\n     *  DR 189.\n    */\n    streamsize\n    precision() const\n    { return _M_precision; }\n\n    /**\n     *  @brief  Changing flags.\n     *  @param  __prec  The new precision value.\n     *  @return  The previous value of precision().\n    */\n    streamsize\n    precision(streamsize __prec)\n    {\n      streamsize __old = _M_precision;\n      _M_precision = __prec;\n      return __old;\n    }\n\n    /**\n     *  @brief  Flags access.\n     *  @return  The minimum field width to generate on output operations.\n     *\n     *  <em>Minimum field width</em> refers to the number of characters.\n    */\n    streamsize\n    width() const\n    { return _M_width; }\n\n    /**\n     *  @brief  Changing flags.\n     *  @param  __wide  The new width value.\n     *  @return  The previous value of width().\n    */\n    streamsize\n    width(streamsize __wide)\n    {\n      streamsize __old = _M_width;\n      _M_width = __wide;\n      return __old;\n    }\n\n    // [27.4.2.4] ios_base static members\n    /**\n     *  @brief  Interaction with the standard C I/O objects.\n     *  @param  __sync  Whether to synchronize or not.\n     *  @return  True if the standard streams were previously synchronized.\n     *\n     *  The synchronization referred to is @e only that between the standard\n     *  C facilities (e.g., stdout) and the standard C++ objects (e.g.,\n     *  cout).  User-declared streams are unaffected.  See\n     *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/fstreams.html#std.io.filestreams.binary\n    */\n    static bool\n    sync_with_stdio(bool __sync = true);\n\n    // [27.4.2.3] ios_base locale functions\n    /**\n     *  @brief  Setting a new locale.\n     *  @param  __loc  The new locale.\n     *  @return  The previous locale.\n     *\n     *  Sets the new locale for this stream, and then invokes each callback\n     *  with imbue_event.\n    */\n    locale\n    imbue(const locale& __loc) throw();\n\n    /**\n     *  @brief  Locale access\n     *  @return  A copy of the current locale.\n     *\n     *  If @c imbue(loc) has previously been called, then this function\n     *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),\n     *  the global C++ locale.\n    */\n    locale\n    getloc() const\n    { return _M_ios_locale; }\n\n    /**\n     *  @brief  Locale access\n     *  @return  A reference to the current locale.\n     *\n     *  Like getloc above, but returns a reference instead of\n     *  generating a copy.\n    */\n    const locale&\n    _M_getloc() const\n    { return _M_ios_locale; }\n\n    // [27.4.2.5] ios_base storage functions\n    /**\n     *  @brief  Access to unique indices.\n     *  @return  An integer different from all previous calls.\n     *\n     *  This function returns a unique integer every time it is called.  It\n     *  can be used for any purpose, but is primarily intended to be a unique\n     *  index for the iword and pword functions.  The expectation is that an\n     *  application calls xalloc in order to obtain an index in the iword and\n     *  pword arrays that can be used without fear of conflict.\n     *\n     *  The implementation maintains a static variable that is incremented and\n     *  returned on each invocation.  xalloc is guaranteed to return an index\n     *  that is safe to use in the iword and pword arrays.\n    */\n    static int\n    xalloc() throw();\n\n    /**\n     *  @brief  Access to integer array.\n     *  @param  __ix  Index into the array.\n     *  @return  A reference to an integer associated with the index.\n     *\n     *  The iword function provides access to an array of integers that can be\n     *  used for any purpose.  The array grows as required to hold the\n     *  supplied index.  All integers in the array are initialized to 0.\n     *\n     *  The implementation reserves several indices.  You should use xalloc to\n     *  obtain an index that is safe to use.  Also note that since the array\n     *  can grow dynamically, it is not safe to hold onto the reference.\n    */\n    long&\n    iword(int __ix)\n    {\n      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)\n\t\t\t? _M_word[__ix] : _M_grow_words(__ix, true);\n      return __word._M_iword;\n    }\n\n    /**\n     *  @brief  Access to void pointer array.\n     *  @param  __ix  Index into the array.\n     *  @return  A reference to a void* associated with the index.\n     *\n     *  The pword function provides access to an array of pointers that can be\n     *  used for any purpose.  The array grows as required to hold the\n     *  supplied index.  All pointers in the array are initialized to 0.\n     *\n     *  The implementation reserves several indices.  You should use xalloc to\n     *  obtain an index that is safe to use.  Also note that since the array\n     *  can grow dynamically, it is not safe to hold onto the reference.\n    */\n    void*&\n    pword(int __ix)\n    {\n      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)\n\t\t\t? _M_word[__ix] : _M_grow_words(__ix, false);\n      return __word._M_pword;\n    }\n\n    // Destructor\n    /**\n     *  Invokes each callback with erase_event.  Destroys local storage.\n     *\n     *  Note that the ios_base object for the standard streams never gets\n     *  destroyed.  As a result, any callbacks registered with the standard\n     *  streams will not get invoked with erase_event (unless copyfmt is\n     *  used).\n    */\n    virtual ~ios_base();\n\n  protected:\n    ios_base() throw ();\n\n#if __cplusplus < 201103L\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 50.  Copy constructor and assignment operator of ios_base\n  private:\n    ios_base(const ios_base&);\n\n    ios_base&\n    operator=(const ios_base&);\n#else\n  public:\n    ios_base(const ios_base&) = delete;\n\n    ios_base&\n    operator=(const ios_base&) = delete;\n\n  protected:\n    void\n    _M_move(ios_base&) noexcept;\n\n    void\n    _M_swap(ios_base& __rhs) noexcept;\n#endif\n  };\n\n  // [27.4.5.1] fmtflags manipulators\n  /// Calls base.setf(ios_base::boolalpha).\n  inline ios_base&\n  boolalpha(ios_base& __base)\n  {\n    __base.setf(ios_base::boolalpha);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::boolalpha).\n  inline ios_base&\n  noboolalpha(ios_base& __base)\n  {\n    __base.unsetf(ios_base::boolalpha);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::showbase).\n  inline ios_base&\n  showbase(ios_base& __base)\n  {\n    __base.setf(ios_base::showbase);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::showbase).\n  inline ios_base&\n  noshowbase(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showbase);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::showpoint).\n  inline ios_base&\n  showpoint(ios_base& __base)\n  {\n    __base.setf(ios_base::showpoint);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::showpoint).\n  inline ios_base&\n  noshowpoint(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showpoint);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::showpos).\n  inline ios_base&\n  showpos(ios_base& __base)\n  {\n    __base.setf(ios_base::showpos);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::showpos).\n  inline ios_base&\n  noshowpos(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showpos);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::skipws).\n  inline ios_base&\n  skipws(ios_base& __base)\n  {\n    __base.setf(ios_base::skipws);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::skipws).\n  inline ios_base&\n  noskipws(ios_base& __base)\n  {\n    __base.unsetf(ios_base::skipws);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::uppercase).\n  inline ios_base&\n  uppercase(ios_base& __base)\n  {\n    __base.setf(ios_base::uppercase);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::uppercase).\n  inline ios_base&\n  nouppercase(ios_base& __base)\n  {\n    __base.unsetf(ios_base::uppercase);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::unitbuf).\n  inline ios_base&\n  unitbuf(ios_base& __base)\n  {\n     __base.setf(ios_base::unitbuf);\n     return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::unitbuf).\n  inline ios_base&\n  nounitbuf(ios_base& __base)\n  {\n     __base.unsetf(ios_base::unitbuf);\n     return __base;\n  }\n\n  // [27.4.5.2] adjustfield manipulators\n  /// Calls base.setf(ios_base::internal, ios_base::adjustfield).\n  inline ios_base&\n  internal(ios_base& __base)\n  {\n     __base.setf(ios_base::internal, ios_base::adjustfield);\n     return __base;\n  }\n\n  /// Calls base.setf(ios_base::left, ios_base::adjustfield).\n  inline ios_base&\n  left(ios_base& __base)\n  {\n    __base.setf(ios_base::left, ios_base::adjustfield);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::right, ios_base::adjustfield).\n  inline ios_base&\n  right(ios_base& __base)\n  {\n    __base.setf(ios_base::right, ios_base::adjustfield);\n    return __base;\n  }\n\n  // [27.4.5.3] basefield manipulators\n  /// Calls base.setf(ios_base::dec, ios_base::basefield).\n  inline ios_base&\n  dec(ios_base& __base)\n  {\n    __base.setf(ios_base::dec, ios_base::basefield);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::hex, ios_base::basefield).\n  inline ios_base&\n  hex(ios_base& __base)\n  {\n    __base.setf(ios_base::hex, ios_base::basefield);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::oct, ios_base::basefield).\n  inline ios_base&\n  oct(ios_base& __base)\n  {\n    __base.setf(ios_base::oct, ios_base::basefield);\n    return __base;\n  }\n\n  // [27.4.5.4] floatfield manipulators\n  /// Calls base.setf(ios_base::fixed, ios_base::floatfield).\n  inline ios_base&\n  fixed(ios_base& __base)\n  {\n    __base.setf(ios_base::fixed, ios_base::floatfield);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::scientific, ios_base::floatfield).\n  inline ios_base&\n  scientific(ios_base& __base)\n  {\n    __base.setf(ios_base::scientific, ios_base::floatfield);\n    return __base;\n  }\n\n#if __cplusplus >= 201103L\n  // New C++11 floatfield manipulators\n\n  /// Calls\n  /// base.setf(ios_base::fixed|ios_base::scientific, ios_base::floatfield)\n  inline ios_base&\n  hexfloat(ios_base& __base)\n  {\n    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __base;\n  }\n\n  /// Calls @c base.unsetf(ios_base::floatfield)\n  inline ios_base&\n  defaultfloat(ios_base& __base)\n  {\n    __base.unsetf(ios_base::floatfield);\n    return __base;\n  }\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif /* _IOS_BASE_H */\n"}],"crc32":3555102282,"timestamp":1704214356,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]