[{"ops":[{"insert":"// <system_error> -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file include/system_error\n *  This is a Standard C++ Library header.\n */\n\n#ifndef _GLIBCXX_SYSTEM_ERROR\n#define _GLIBCXX_SYSTEM_ERROR 1\n\n#pragma GCC system_header\n\n#if __cplusplus < 201103L\n# include <bits/c++0x_warning.h>\n#else\n\n#include <bits/c++config.h>\n#include <bits/error_constants.h>\n#include <iosfwd>\n#include <stdexcept>\n#if __cplusplus > 201703L\n# include <compare>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /** @addtogroup diagnostics\n   * @{\n   */\n\n  class error_code;\n  class error_condition;\n  class system_error;\n\n  /// is_error_code_enum\n  template<typename _Tp>\n    struct is_error_code_enum : public false_type { };\n\n  /// is_error_condition_enum\n  template<typename _Tp>\n    struct is_error_condition_enum : public false_type { };\n\n  template<>\n    struct is_error_condition_enum<errc>\n    : public true_type { };\n\n#if __cplusplus > 201402L\n  template <typename _Tp>\n    inline constexpr bool is_error_code_enum_v =\n      is_error_code_enum<_Tp>::value;\n  template <typename _Tp>\n    inline constexpr bool is_error_condition_enum_v =\n      is_error_condition_enum<_Tp>::value;\n#endif // C++17\n  /// @}\n\n  inline namespace _V2 {\n\n  /** @addtogroup diagnostics\n   * @{\n   */\n\n  /** Abstract base class for types defining a category of error codes.\n   *\n   * An error category defines a context that give meaning to the integer\n   * stored in an `error_code` or `error_condition` object. For example,\n   * the standard `errno` constants such a `EINVAL` and `ENOMEM` are\n   * associated with the \"generic\" category and other OS-specific error\n   * numbers are associated with the \"system\" category, but a user-defined\n   * category might give different meanings to the same numerical values.\n   *\n   * @since C++11\n   */\n  class error_category\n  {\n  public:\n    constexpr error_category() noexcept = default;\n\n    virtual ~error_category();\n\n    error_category(const error_category&) = delete;\n    error_category& operator=(const error_category&) = delete;\n\n    virtual const char*\n    name() const noexcept = 0;\n\n    // We need two different virtual functions here, one returning a\n    // COW string and one returning an SSO string. Their positions in the\n    // vtable must be consistent for dynamic dispatch to work, but which one\n    // the name \"message()\" finds depends on which ABI the caller is using.\n#if _GLIBCXX_USE_CXX11_ABI\n  private:\n    _GLIBCXX_DEFAULT_ABI_TAG\n    virtual __cow_string\n    _M_message(int) const;\n\n  public:\n    _GLIBCXX_DEFAULT_ABI_TAG\n    virtual string\n    message(int) const = 0;\n#else\n    virtual string\n    message(int) const = 0;\n\n  private:\n    virtual __sso_string\n    _M_message(int) const;\n#endif\n\n  public:\n    virtual error_condition\n    default_error_condition(int __i) const noexcept;\n\n    virtual bool\n    equivalent(int __i, const error_condition& __cond) const noexcept;\n\n    virtual bool\n    equivalent(const error_code& __code, int __i) const noexcept;\n\n    bool\n    operator==(const error_category& __other) const noexcept\n    { return this == &__other; }\n\n#if __cpp_lib_three_way_comparison\n    strong_ordering\n    operator<=>(const error_category& __rhs) const noexcept\n    { return std::compare_three_way()(this, &__rhs); }\n#else\n    bool\n    operator!=(const error_category& __other) const noexcept\n    { return this != &__other; }\n\n    bool\n    operator<(const error_category& __other) const noexcept\n    { return less<const error_category*>()(this, &__other); }\n#endif\n  };\n\n  // DR 890.\n\n  /// Error category for `errno` error codes.\n  _GLIBCXX_CONST const error_category& generic_category() noexcept;\n\n  /// Error category for other error codes defined by the OS.\n  _GLIBCXX_CONST const error_category& system_category() noexcept;\n\n  /// @}\n  } // end inline namespace\n\n  /** @addtogroup diagnostics\n   * @{\n   */\n\n  error_code make_error_code(errc) noexcept;\n\n  /** Class error_code\n   *\n   * This class is a value type storing an integer error number and a\n   * category that gives meaning to the error number. Typically this is done\n   * close the the point where the error happens, to capture the original\n   * error value.\n   *\n   * An `error_code` object can be used to store the original error value\n   * emitted by some subsystem, with a category relevant to the subsystem.\n   * For example, errors from POSIX library functions can be represented by\n   * an `errno` value and the \"generic\" category, but errors from an HTTP\n   * library might be represented by an HTTP response status code (e.g. 404)\n   * and a custom category defined by the library.\n   *\n   * @since C++11\n   * @ingroup diagnostics\n   */\n  class error_code\n  {\n  public:\n    error_code() noexcept\n    : _M_value(0), _M_cat(&system_category()) { }\n\n    error_code(int __v, const error_category& __cat) noexcept\n    : _M_value(__v), _M_cat(&__cat) { }\n\n    template<typename _ErrorCodeEnum, typename = typename\n\t     enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>\n      error_code(_ErrorCodeEnum __e) noexcept\n      { *this = make_error_code(__e); }\n\n    void\n    assign(int __v, const error_category& __cat) noexcept\n    {\n      _M_value = __v;\n      _M_cat = &__cat;\n    }\n\n    void\n    clear() noexcept\n    { assign(0, system_category()); }\n\n    // DR 804.\n    template<typename _ErrorCodeEnum>\n      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,\n\t\t\t error_code&>::type\n      operator=(_ErrorCodeEnum __e) noexcept\n      { return *this = make_error_code(__e); }\n\n    int\n    value() const noexcept { return _M_value; }\n\n    const error_category&\n    category() const noexcept { return *_M_cat; }\n\n    error_condition\n    default_error_condition() const noexcept;\n\n    _GLIBCXX_DEFAULT_ABI_TAG\n    string\n    message() const\n    { return category().message(value()); }\n\n    explicit operator bool() const noexcept\n    { return _M_value != 0; }\n\n    // DR 804.\n  private:\n    int            \t\t_M_value;\n    const error_category* \t_M_cat;\n  };\n\n  // 19.4.2.6 non-member functions\n\n  /// @relates error_code @{\n\n  inline error_code\n  make_error_code(errc __e) noexcept\n  { return error_code(static_cast<int>(__e), generic_category()); }\n\n#if __cpp_lib_three_way_comparison\n  inline strong_ordering\n  operator<=>(const error_code& __lhs, const error_code& __rhs) noexcept\n  {\n    if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)\n      return __c;\n    return __lhs.value() <=> __rhs.value();\n  }\n#else\n  inline bool\n  operator<(const error_code& __lhs, const error_code& __rhs) noexcept\n  {\n    return (__lhs.category() < __rhs.category()\n\t    || (__lhs.category() == __rhs.category()\n\t\t&& __lhs.value() < __rhs.value()));\n  }\n#endif\n\n  template<typename _CharT, typename _Traits>\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)\n    { return (__os << __e.category().name() << ':' << __e.value()); }\n\n  /// @}\n\n  error_condition make_error_condition(errc) noexcept;\n\n  /** Class error_condition\n   *\n   * This class represents error conditions that may be visible at an API\n   * boundary. Different `error_code` values that can occur within a library\n   * or module might map to the same `error_condition`.\n   *\n   * An `error_condition` represents something that the program can test for,\n   * and subsequently take appropriate action.\n   *\n   * @since C++11\n   */\n  class error_condition\n  {\n  public:\n    error_condition() noexcept\n    : _M_value(0), _M_cat(&generic_category()) { }\n\n    error_condition(int __v, const error_category& __cat) noexcept\n    : _M_value(__v), _M_cat(&__cat) { }\n\n    template<typename _ErrorConditionEnum, typename = typename\n\t enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>\n      error_condition(_ErrorConditionEnum __e) noexcept\n      { *this = make_error_condition(__e); }\n\n    void\n    assign(int __v, const error_category& __cat) noexcept\n    {\n      _M_value = __v;\n      _M_cat = &__cat;\n    }\n\n    // DR 804.\n    template<typename _ErrorConditionEnum>\n      typename enable_if<is_error_condition_enum\n\t\t\t <_ErrorConditionEnum>::value, error_condition&>::type\n      operator=(_ErrorConditionEnum __e) noexcept\n      { return *this = make_error_condition(__e); }\n\n    void\n    clear() noexcept\n    { assign(0, generic_category()); }\n\n    // 19.4.3.4 observers\n    int\n    value() const noexcept { return _M_value; }\n\n    const error_category&\n    category() const noexcept { return *_M_cat; }\n\n    _GLIBCXX_DEFAULT_ABI_TAG\n    string\n    message() const\n    { return category().message(value()); }\n\n    explicit operator bool() const noexcept\n    { return _M_value != 0; }\n\n    // DR 804.\n  private:\n    int \t\t\t_M_value;\n    const error_category* \t_M_cat;\n  };\n\n  // 19.4.3.6 non-member functions\n\n  /// Create an `error_condition` representing a standard `errc` condition.\n  /// @relates error_condition\n  inline error_condition\n  make_error_condition(errc __e) noexcept\n  { return error_condition(static_cast<int>(__e), generic_category()); }\n\n  // 19.4.4 Comparison operators\n\n  /// @relates error_code\n  inline bool\n  operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n  { return (__lhs.category() == __rhs.category()\n\t    && __lhs.value() == __rhs.value()); }\n\n  /// @relates error_code\n  inline bool\n  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept\n  {\n    return (__lhs.category().equivalent(__lhs.value(), __rhs)\n\t    || __rhs.category().equivalent(__lhs, __rhs.value()));\n  }\n\n  /// @relates error_condition\n  inline bool\n  operator==(const error_condition& __lhs,\n\t     const error_condition& __rhs) noexcept\n  {\n    return (__lhs.category() == __rhs.category()\n\t    && __lhs.value() == __rhs.value());\n  }\n\n#if __cpp_lib_three_way_comparison\n  /// Define an ordering for error_condition objects.\n  /// @relates error_condition\n  inline strong_ordering\n  operator<=>(const error_condition& __lhs,\n\t      const error_condition& __rhs) noexcept\n  {\n    if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)\n      return __c;\n    return __lhs.value() <=> __rhs.value();\n  }\n#else\n  /// Define an ordering for error_condition objects.\n  /// @relates error_condition\n  inline bool\n  operator<(const error_condition& __lhs,\n\t    const error_condition& __rhs) noexcept\n  {\n    return (__lhs.category() < __rhs.category()\n\t    || (__lhs.category() == __rhs.category()\n\t\t&& __lhs.value() < __rhs.value()));\n  }\n\n  /// @relates error_condition\n  inline bool\n  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept\n  {\n    return (__rhs.category().equivalent(__rhs.value(), __lhs)\n\t    || __lhs.category().equivalent(__rhs, __lhs.value()));\n  }\n\n  /// @relates error_code\n  inline bool\n  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept\n  { return !(__lhs == __rhs); }\n\n  /// @relates error_code\n  inline bool\n  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept\n  { return !(__lhs == __rhs); }\n\n  /// @relates error_condition\n  inline bool\n  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept\n  { return !(__lhs == __rhs); }\n\n  /// @relates error_condition\n  inline bool\n  operator!=(const error_condition& __lhs,\n\t     const error_condition& __rhs) noexcept\n  { return !(__lhs == __rhs); }\n#endif // three_way_comparison\n  /// @}\n\n  /**\n   * @brief An exception type that includes an `error_code` value.\n   *\n   * Typically used to report errors from the operating system and other\n   * low-level APIs.\n   *\n   * @since C++11\n   * @ingroup exceptions\n   */\n  class system_error : public std::runtime_error\n  {\n  private:\n    error_code \t_M_code;\n\n  public:\n    system_error(error_code __ec = error_code())\n    : runtime_error(__ec.message()), _M_code(__ec) { }\n\n    system_error(error_code __ec, const string& __what)\n    : runtime_error(__what + \": \" + __ec.message()), _M_code(__ec) { }\n\n    system_error(error_code __ec, const char* __what)\n    : runtime_error(__what + (\": \" + __ec.message())), _M_code(__ec) { }\n\n    system_error(int __v, const error_category& __ecat, const char* __what)\n    : system_error(error_code(__v, __ecat), __what) { }\n\n    system_error(int __v, const error_category& __ecat)\n    : runtime_error(error_code(__v, __ecat).message()),\n      _M_code(__v, __ecat) { }\n\n    system_error(int __v, const error_category& __ecat, const string& __what)\n    : runtime_error(__what + \": \" + error_code(__v, __ecat).message()),\n      _M_code(__v, __ecat) { }\n\n#if __cplusplus >= 201103L\n    system_error (const system_error &) = default;\n    system_error &operator= (const system_error &) = default;\n#endif\n\n    virtual ~system_error() noexcept;\n\n    const error_code&\n    code() const noexcept { return _M_code; }\n  };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#include <bits/functional_hash.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#ifndef _GLIBCXX_COMPATIBILITY_CXX0X\n  // DR 1182.\n  /// std::hash specialization for error_code.\n  /// @relates error_code\n  template<>\n    struct hash<error_code>\n    : public __hash_base<size_t, error_code>\n    {\n      size_t\n      operator()(const error_code& __e) const noexcept\n      {\n\tconst size_t __tmp = std::_Hash_impl::hash(__e.value());\n\treturn std::_Hash_impl::__hash_combine(&__e.category(), __tmp);\n      }\n    };\n#endif // _GLIBCXX_COMPATIBILITY_CXX0X\n\n#if __cplusplus >= 201703L\n  // DR 2686.\n  /// std::hash specialization for error_condition.\n  /// @relates error_condition\n  template<>\n    struct hash<error_condition>\n    : public __hash_base<size_t, error_condition>\n    {\n      size_t\n      operator()(const error_condition& __e) const noexcept\n      {\n\tconst size_t __tmp = std::_Hash_impl::hash(__e.value());\n\treturn std::_Hash_impl::__hash_combine(&__e.category(), __tmp);\n      }\n    };\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // C++11\n\n#endif // _GLIBCXX_SYSTEM_ERROR\n"}],"crc32":3022387288,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]