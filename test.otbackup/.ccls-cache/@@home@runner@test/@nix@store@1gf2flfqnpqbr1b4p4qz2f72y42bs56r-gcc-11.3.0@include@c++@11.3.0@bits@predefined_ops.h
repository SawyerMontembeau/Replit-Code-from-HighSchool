[{"ops":[{"insert":"// Default predicates for internal use -*- C++ -*-\n\n// Copyright (C) 2013-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file predefined_ops.h\n *  This is an internal header file, included by other library headers.\n *  You should not attempt to use it directly. @headername{algorithm}\n */\n\n#ifndef _GLIBCXX_PREDEFINED_OPS_H\n#define _GLIBCXX_PREDEFINED_OPS_H\t1\n\n#include <bits/move.h>\n\nnamespace __gnu_cxx\n{\nnamespace __ops\n{\n  struct _Iter_less_iter\n  {\n    template<typename _Iterator1, typename _Iterator2>\n      _GLIBCXX14_CONSTEXPR\n      bool\n      operator()(_Iterator1 __it1, _Iterator2 __it2) const\n      { return *__it1 < *__it2; }\n  };\n\n  _GLIBCXX14_CONSTEXPR\n  inline _Iter_less_iter\n  __iter_less_iter()\n  { return _Iter_less_iter(); }\n\n  struct _Iter_less_val\n  {\n#if __cplusplus >= 201103L\n    constexpr _Iter_less_val() = default;\n#else\n    _Iter_less_val() { }\n#endif\n\n    _GLIBCXX20_CONSTEXPR\n    explicit\n    _Iter_less_val(_Iter_less_iter) { }\n\n    template<typename _Iterator, typename _Value>\n      _GLIBCXX20_CONSTEXPR\n      bool\n      operator()(_Iterator __it, _Value& __val) const\n      { return *__it < __val; }\n  };\n\n  _GLIBCXX20_CONSTEXPR\n  inline _Iter_less_val\n  __iter_less_val()\n  { return _Iter_less_val(); }\n\n  _GLIBCXX20_CONSTEXPR\n  inline _Iter_less_val\n  __iter_comp_val(_Iter_less_iter)\n  { return _Iter_less_val(); }\n\n  struct _Val_less_iter\n  {\n#if __cplusplus >= 201103L\n    constexpr _Val_less_iter() = default;\n#else\n    _Val_less_iter() { }\n#endif\n\n    _GLIBCXX20_CONSTEXPR\n    explicit\n    _Val_less_iter(_Iter_less_iter) { }\n\n    template<typename _Value, typename _Iterator>\n      _GLIBCXX20_CONSTEXPR\n      bool\n      operator()(_Value& __val, _Iterator __it) const\n      { return __val < *__it; }\n  };\n\n  _GLIBCXX20_CONSTEXPR\n  inline _Val_less_iter\n  __val_less_iter()\n  { return _Val_less_iter(); }\n\n  _GLIBCXX20_CONSTEXPR\n  inline _Val_less_iter\n  __val_comp_iter(_Iter_less_iter)\n  { return _Val_less_iter(); }\n\n  struct _Iter_equal_to_iter\n  {\n    template<typename _Iterator1, typename _Iterator2>\n      _GLIBCXX20_CONSTEXPR\n      bool\n      operator()(_Iterator1 __it1, _Iterator2 __it2) const\n      { return *__it1 == *__it2; }\n  };\n\n  _GLIBCXX20_CONSTEXPR\n  inline _Iter_equal_to_iter\n  __iter_equal_to_iter()\n  { return _Iter_equal_to_iter(); }\n\n  struct _Iter_equal_to_val\n  {\n    template<typename _Iterator, typename _Value>\n      _GLIBCXX20_CONSTEXPR\n      bool\n      operator()(_Iterator __it, _Value& __val) const\n      { return *__it == __val; }\n  };\n\n  _GLIBCXX20_CONSTEXPR\n  inline _Iter_equal_to_val\n  __iter_equal_to_val()\n  { return _Iter_equal_to_val(); }\n\n  _GLIBCXX20_CONSTEXPR\n  inline _Iter_equal_to_val\n  __iter_comp_val(_Iter_equal_to_iter)\n  { return _Iter_equal_to_val(); }\n\n  template<typename _Compare>\n    struct _Iter_comp_iter\n    {\n      _Compare _M_comp;\n\n      explicit _GLIBCXX14_CONSTEXPR\n      _Iter_comp_iter(_Compare __comp)\n\t: _M_comp(_GLIBCXX_MOVE(__comp))\n      { }\n\n      template<typename _Iterator1, typename _Iterator2>\n        _GLIBCXX14_CONSTEXPR\n        bool\n        operator()(_Iterator1 __it1, _Iterator2 __it2)\n        { return bool(_M_comp(*__it1, *__it2)); }\n    };\n\n  template<typename _Compare>\n    _GLIBCXX14_CONSTEXPR\n    inline _Iter_comp_iter<_Compare>\n    __iter_comp_iter(_Compare __comp)\n    { return _Iter_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }\n\n  template<typename _Compare>\n    struct _Iter_comp_val\n    {\n      _Compare _M_comp;\n\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Iter_comp_val(_Compare __comp)\n\t: _M_comp(_GLIBCXX_MOVE(__comp))\n      { }\n\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)\n\t: _M_comp(__comp._M_comp)\n      { }\n\n#if __cplusplus >= 201103L\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)\n\t: _M_comp(std::move(__comp._M_comp))\n      { }\n#endif\n\n      template<typename _Iterator, typename _Value>\n\t_GLIBCXX20_CONSTEXPR\n\tbool\n\toperator()(_Iterator __it, _Value& __val)\n\t{ return bool(_M_comp(*__it, __val)); }\n    };\n\n  template<typename _Compare>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iter_comp_val<_Compare>\n    __iter_comp_val(_Compare __comp)\n    { return _Iter_comp_val<_Compare>(_GLIBCXX_MOVE(__comp)); }\n\n  template<typename _Compare>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iter_comp_val<_Compare>\n    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)\n    { return _Iter_comp_val<_Compare>(_GLIBCXX_MOVE(__comp)); }\n\n  template<typename _Compare>\n    struct _Val_comp_iter\n    {\n      _Compare _M_comp;\n\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Val_comp_iter(_Compare __comp)\n\t: _M_comp(_GLIBCXX_MOVE(__comp))\n      { }\n\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)\n\t: _M_comp(__comp._M_comp)\n      { }\n\n#if __cplusplus >= 201103L\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)\n\t: _M_comp(std::move(__comp._M_comp))\n      { }\n#endif\n\n      template<typename _Value, typename _Iterator>\n\t_GLIBCXX20_CONSTEXPR\n\tbool\n\toperator()(_Value& __val, _Iterator __it)\n\t{ return bool(_M_comp(__val, *__it)); }\n    };\n\n  template<typename _Compare>\n    _GLIBCXX20_CONSTEXPR\n    inline _Val_comp_iter<_Compare>\n    __val_comp_iter(_Compare __comp)\n    { return _Val_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }\n\n  template<typename _Compare>\n    _GLIBCXX20_CONSTEXPR\n    inline _Val_comp_iter<_Compare>\n    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)\n    { return _Val_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }\n\n  template<typename _Value>\n    struct _Iter_equals_val\n    {\n      _Value& _M_value;\n\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Iter_equals_val(_Value& __value)\n\t: _M_value(__value)\n      { }\n\n      template<typename _Iterator>\n\t_GLIBCXX20_CONSTEXPR\n\tbool\n\toperator()(_Iterator __it)\n\t{ return *__it == _M_value; }\n    };\n\n  template<typename _Value>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iter_equals_val<_Value>\n    __iter_equals_val(_Value& __val)\n    { return _Iter_equals_val<_Value>(__val); }\n\n  template<typename _Iterator1>\n    struct _Iter_equals_iter\n    {\n      _Iterator1 _M_it1;\n\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Iter_equals_iter(_Iterator1 __it1)\n\t: _M_it1(__it1)\n      { }\n\n      template<typename _Iterator2>\n\t_GLIBCXX20_CONSTEXPR\n\tbool\n\toperator()(_Iterator2 __it2)\n\t{ return *__it2 == *_M_it1; }\n    };\n\n  template<typename _Iterator>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iter_equals_iter<_Iterator>\n    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)\n    { return _Iter_equals_iter<_Iterator>(__it); }\n\n  template<typename _Predicate>\n    struct _Iter_pred\n    {\n      _Predicate _M_pred;\n\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Iter_pred(_Predicate __pred)\n\t: _M_pred(_GLIBCXX_MOVE(__pred))\n      { }\n\n      template<typename _Iterator>\n\t_GLIBCXX20_CONSTEXPR\n\tbool\n\toperator()(_Iterator __it)\n\t{ return bool(_M_pred(*__it)); }\n    };\n\n  template<typename _Predicate>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iter_pred<_Predicate>\n    __pred_iter(_Predicate __pred)\n    { return _Iter_pred<_Predicate>(_GLIBCXX_MOVE(__pred)); }\n\n  template<typename _Compare, typename _Value>\n    struct _Iter_comp_to_val\n    {\n      _Compare _M_comp;\n      _Value& _M_value;\n\n      _GLIBCXX20_CONSTEXPR\n      _Iter_comp_to_val(_Compare __comp, _Value& __value)\n\t: _M_comp(_GLIBCXX_MOVE(__comp)), _M_value(__value)\n      { }\n\n      template<typename _Iterator>\n\t_GLIBCXX20_CONSTEXPR\n\tbool\n\toperator()(_Iterator __it)\n\t{ return bool(_M_comp(*__it, _M_value)); }\n    };\n\n  template<typename _Compare, typename _Value>\n    _Iter_comp_to_val<_Compare, _Value>\n    _GLIBCXX20_CONSTEXPR\n    __iter_comp_val(_Compare __comp, _Value &__val)\n    {\n      return _Iter_comp_to_val<_Compare, _Value>(_GLIBCXX_MOVE(__comp), __val);\n    }\n\n  template<typename _Compare, typename _Iterator1>\n    struct _Iter_comp_to_iter\n    {\n      _Compare _M_comp;\n      _Iterator1 _M_it1;\n\n      _GLIBCXX20_CONSTEXPR\n      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)\n\t: _M_comp(_GLIBCXX_MOVE(__comp)), _M_it1(__it1)\n      { }\n\n      template<typename _Iterator2>\n\t_GLIBCXX20_CONSTEXPR\n\tbool\n\toperator()(_Iterator2 __it2)\n\t{ return bool(_M_comp(*__it2, *_M_it1)); }\n    };\n\n  template<typename _Compare, typename _Iterator>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iter_comp_to_iter<_Compare, _Iterator>\n    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)\n    {\n      return _Iter_comp_to_iter<_Compare, _Iterator>(\n\t  _GLIBCXX_MOVE(__comp._M_comp), __it);\n    }\n\n  template<typename _Predicate>\n    struct _Iter_negate\n    {\n      _Predicate _M_pred;\n\n      _GLIBCXX20_CONSTEXPR\n      explicit\n      _Iter_negate(_Predicate __pred)\n\t: _M_pred(_GLIBCXX_MOVE(__pred))\n      { }\n\n      template<typename _Iterator>\n\t_GLIBCXX20_CONSTEXPR\n\tbool\n\toperator()(_Iterator __it)\n\t{ return !bool(_M_pred(*__it)); }\n    };\n\n  template<typename _Predicate>\n    _GLIBCXX20_CONSTEXPR\n    inline _Iter_negate<_Predicate>\n    __negate(_Iter_pred<_Predicate> __pred)\n    { return _Iter_negate<_Predicate>(_GLIBCXX_MOVE(__pred._M_pred)); }\n\n} // namespace __ops\n} // namespace __gnu_cxx\n\n#endif\n"}],"crc32":1289846024,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]