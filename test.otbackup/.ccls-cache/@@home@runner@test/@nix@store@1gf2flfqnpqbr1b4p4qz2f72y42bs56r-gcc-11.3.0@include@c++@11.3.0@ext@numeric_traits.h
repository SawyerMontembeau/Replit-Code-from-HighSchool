[{"ops":[{"insert":"// -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the terms\n// of the GNU General Public License as published by the Free Software\n// Foundation; either version 3, or (at your option) any later\n// version.\n\n// This library is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file ext/numeric_traits.h\n *  This file is a GNU extension to the Standard C++ Library.\n */\n\n#ifndef _EXT_NUMERIC_TRAITS\n#define _EXT_NUMERIC_TRAITS 1\n\n#pragma GCC system_header\n\n#include <bits/cpp_type_traits.h>\n#include <ext/type_traits.h>\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // Compile time constants for builtin types.\n  // In C++98 std::numeric_limits member functions are not constant expressions\n  // (that changed in C++11 with the addition of 'constexpr').\n  // Even for C++11, this header is smaller than <limits> and can be used\n  // when only is_signed, digits, min, or max values are needed for integers,\n  // or is_signed, digits10, max_digits10, or max_exponent10 for floats.\n\n  // Unlike __is_integer (and std::is_integral) this trait is true for\n  // non-standard built-in integer types such as __int128 and __int20.\n  template<typename _Tp>\n    struct __is_integer_nonstrict\n    : public std::__is_integer<_Tp>\n    {\n      using std::__is_integer<_Tp>::__value;\n\n      // The number of bits in the value representation.\n      enum { __width = __value ? sizeof(_Tp) * __CHAR_BIT__ : 0 };\n    };\n\n  template<typename _Value>\n    struct __numeric_traits_integer\n    {\n#if __cplusplus >= 201103L\n      static_assert(__is_integer_nonstrict<_Value>::__value,\n\t\t    \"invalid specialization\");\n#endif\n\n      // NB: these two are also available in std::numeric_limits as compile\n      // time constants, but <limits> is big and we can avoid including it.\n      static const bool __is_signed = (_Value)(-1) < 0;\n      static const int __digits\n\t= __is_integer_nonstrict<_Value>::__width - __is_signed;\n\n      // The initializers must be constants so that __max and __min are too.\n      static const _Value __max = __is_signed\n\t? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)\n\t: ~(_Value)0;\n      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;\n    };\n\n  template<typename _Value>\n    const _Value __numeric_traits_integer<_Value>::__min;\n\n  template<typename _Value>\n    const _Value __numeric_traits_integer<_Value>::__max;\n\n  template<typename _Value>\n    const bool __numeric_traits_integer<_Value>::__is_signed;\n\n  template<typename _Value>\n    const int __numeric_traits_integer<_Value>::__digits;\n\n  // Enable __numeric_traits_integer for types where the __is_integer_nonstrict\n  // primary template doesn't give the right answer.\n#define _GLIBCXX_INT_N_TRAITS(T, WIDTH)\t\t\t\\\n  template<> struct __is_integer_nonstrict<T>\t\t\\\n  {\t\t\t\t\t\t\t\\\n    enum { __value = 1 };\t\t\t\t\\\n    typedef std::__true_type __type;\t\t\t\\\n    enum { __width = WIDTH };\t\t\t\t\\\n  };\t\t\t\t\t\t\t\\\n  template<> struct __is_integer_nonstrict<unsigned T>\t\\\n  {\t\t\t\t\t\t\t\\\n    enum { __value = 1 };\t\t\t\t\\\n    typedef std::__true_type __type;\t\t\t\\\n    enum { __width = WIDTH };\t\t\t\t\\\n  };\n\n  // We need to specify the width for some __intNN types because they\n  // have padding bits, e.g. the object representation of __int20 has 32 bits,\n  // but its width (number of bits in the value representation) is only 20.\n#if defined __GLIBCXX_TYPE_INT_N_0 && __GLIBCXX_BITSIZE_INT_N_0 % __CHAR_BIT__\n  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_0, __GLIBCXX_BITSIZE_INT_N_0)\n#endif\n#if defined __GLIBCXX_TYPE_INT_N_1 && __GLIBCXX_BITSIZE_INT_N_1 % __CHAR_BIT__\n  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_1, __GLIBCXX_BITSIZE_INT_N_1)\n#endif\n#if defined __GLIBCXX_TYPE_INT_N_2 && __GLIBCXX_BITSIZE_INT_N_2 % __CHAR_BIT__\n  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_2, __GLIBCXX_BITSIZE_INT_N_2)\n#endif\n#if defined __GLIBCXX_TYPE_INT_N_3 && __GLIBCXX_BITSIZE_INT_N_3 % __CHAR_BIT__\n  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_3, __GLIBCXX_BITSIZE_INT_N_3)\n#endif\n\n#if defined __STRICT_ANSI__ && defined __SIZEOF_INT128__\n  // In strict modes __is_integer<__int128> is false,\n  // but we still want to define __numeric_traits_integer<__int128>.\n  _GLIBCXX_INT_N_TRAITS(__int128, 128)\n#endif\n\n#undef _GLIBCXX_INT_N_TRAITS\n\n#if __cplusplus >= 201103L\n  /// Convenience alias for __numeric_traits<integer-type>.\n  template<typename _Tp>\n    using __int_traits = __numeric_traits_integer<_Tp>;\n#endif\n\n#define __glibcxx_floating(_Tp, _Fval, _Dval, _LDval) \\\n  (std::__are_same<_Tp, float>::__value ? _Fval \\\n   : std::__are_same<_Tp, double>::__value ? _Dval : _LDval)\n\n#define __glibcxx_max_digits10(_Tp) \\\n  (2 + __glibcxx_floating(_Tp, __FLT_MANT_DIG__, __DBL_MANT_DIG__, \\\n\t\t\t  __LDBL_MANT_DIG__) * 643L / 2136)\n\n#define __glibcxx_digits10(_Tp) \\\n  __glibcxx_floating(_Tp, __FLT_DIG__, __DBL_DIG__, __LDBL_DIG__)\n\n#define __glibcxx_max_exponent10(_Tp) \\\n  __glibcxx_floating(_Tp, __FLT_MAX_10_EXP__, __DBL_MAX_10_EXP__, \\\n\t\t     __LDBL_MAX_10_EXP__)\n\n  // N.B. this only supports float, double and long double (no __float128 etc.)\n  template<typename _Value>\n    struct __numeric_traits_floating\n    {\n      // Only floating point types. See N1822.\n      static const int __max_digits10 = __glibcxx_max_digits10(_Value);\n\n      // See above comment...\n      static const bool __is_signed = true;\n      static const int __digits10 = __glibcxx_digits10(_Value);\n      static const int __max_exponent10 = __glibcxx_max_exponent10(_Value);\n    };\n\n  template<typename _Value>\n    const int __numeric_traits_floating<_Value>::__max_digits10;\n\n  template<typename _Value>\n    const bool __numeric_traits_floating<_Value>::__is_signed;\n\n  template<typename _Value>\n    const int __numeric_traits_floating<_Value>::__digits10;\n\n  template<typename _Value>\n    const int __numeric_traits_floating<_Value>::__max_exponent10;\n\n#undef __glibcxx_floating\n#undef __glibcxx_max_digits10\n#undef __glibcxx_digits10\n#undef __glibcxx_max_exponent10\n\n  template<typename _Value>\n    struct __numeric_traits\n    : public __numeric_traits_integer<_Value>\n    { };\n\n  template<>\n    struct __numeric_traits<float>\n    : public __numeric_traits_floating<float>\n    { };\n\n  template<>\n    struct __numeric_traits<double>\n    : public __numeric_traits_floating<double>\n    { };\n\n  template<>\n    struct __numeric_traits<long double>\n    : public __numeric_traits_floating<long double>\n    { };\n\n#ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n# if defined __LONG_DOUBLE_IEEE128__\n  // long double is __ieee128, define traits for __ibm128\n  template<>\n    struct __numeric_traits_floating<__ibm128>\n    {\n      static const int __max_digits10 = 33;\n      static const bool __is_signed = true;\n      static const int __digits10 = 31;\n      static const int __max_exponent10 = 308;\n    };\n  template<>\n    struct __numeric_traits<__ibm128>\n    : public __numeric_traits_floating<__ibm128>\n    { };\n# elif defined __LONG_DOUBLE_IBM128__\n  // long double is __ibm128, define traits for __ieee128\n  template<>\n    struct __numeric_traits_floating<__ieee128>\n    {\n      static const int __max_digits10 = 36;\n      static const bool __is_signed = true;\n      static const int __digits10 = 33;\n      static const int __max_exponent10 = 4932;\n    };\n  template<>\n    struct __numeric_traits<__ieee128>\n    : public __numeric_traits_floating<__ieee128>\n    { };\n# endif\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif\n"}],"crc32":3942247389,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]