[{"ops":[{"insert":"// istream classes -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/istream.tcc\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{istream}\n */\n\n//\n// ISO C++ 14882: 27.6.1  Input streams\n//\n\n#ifndef _ISTREAM_TCC\n#define _ISTREAM_TCC 1\n\n#pragma GCC system_header\n\n#include <bits/cxxabi_forced.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>::sentry::\n    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)\n    {\n      ios_base::iostate __err = ios_base::goodbit;\n      if (__in.good())\n\t__try\n\t  {\n\t    if (__in.tie())\n\t      __in.tie()->flush();\n\t    if (!__noskip && bool(__in.flags() & ios_base::skipws))\n\t      {\n\t\tconst __int_type __eof = traits_type::eof();\n\t\t__streambuf_type* __sb = __in.rdbuf();\n\t\t__int_type __c = __sb->sgetc();\n\n\t\tconst __ctype_type& __ct = __check_facet(__in._M_ctype);\n\t\twhile (!traits_type::eq_int_type(__c, __eof)\n\t\t       && __ct.is(ctype_base::space,\n\t\t\t\t  traits_type::to_char_type(__c)))\n\t\t  __c = __sb->snextc();\n\n\t\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t\t// 195. Should basic_istream::sentry's constructor ever\n\t\t// set eofbit?\n\t\tif (traits_type::eq_int_type(__c, __eof))\n\t\t  __err |= ios_base::eofbit;\n\t      }\n\t  }\n\t__catch(__cxxabiv1::__forced_unwind&)\n\t  {\n\t    __in._M_setstate(ios_base::badbit);\n\t    __throw_exception_again;\n\t  }\n\t__catch(...)\n\t  { __in._M_setstate(ios_base::badbit); }\n\n      if (__in.good() && __err == ios_base::goodbit)\n\t_M_ok = true;\n      else\n\t{\n\t  __err |= ios_base::failbit;\n\t  __in.setstate(__err);\n\t}\n    }\n\n  template<typename _CharT, typename _Traits>\n    template<typename _ValueT>\n      basic_istream<_CharT, _Traits>&\n      basic_istream<_CharT, _Traits>::\n      _M_extract(_ValueT& __v)\n      {\n\tsentry __cerb(*this, false);\n\tif (__cerb)\n\t  {\n\t    ios_base::iostate __err = ios_base::goodbit;\n\t    __try\n\t      {\n\t\tconst __num_get_type& __ng = __check_facet(this->_M_num_get);\n\t\t__ng.get(*this, 0, *this, __err, __v);\n\t      }\n\t    __catch(__cxxabiv1::__forced_unwind&)\n\t      {\n\t\tthis->_M_setstate(ios_base::badbit);\n\t\t__throw_exception_again;\n\t      }\n\t    __catch(...)\n\t      { this->_M_setstate(ios_base::badbit); }\n\t    if (__err)\n\t      this->setstate(__err);\n\t  }\n\treturn *this;\n      }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    operator>>(short& __n)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 118. basic_istream uses nonexistent num_get member functions.\n      sentry __cerb(*this, false);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      long __l;\n\t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n\t      __ng.get(*this, 0, *this, __err, __l);\n\n\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t      // 696. istream::operator>>(int&) broken.\n\t      if (__l < __gnu_cxx::__numeric_traits<short>::__min)\n\t\t{\n\t\t  __err |= ios_base::failbit;\n\t\t  __n = __gnu_cxx::__numeric_traits<short>::__min;\n\t\t}\n\t      else if (__l > __gnu_cxx::__numeric_traits<short>::__max)\n\t\t{\n\t\t  __err |= ios_base::failbit;\n\t\t  __n = __gnu_cxx::__numeric_traits<short>::__max;\n\t\t}\n\t      else\n\t\t__n = short(__l);\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    operator>>(int& __n)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 118. basic_istream uses nonexistent num_get member functions.\n      sentry __cerb(*this, false);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      long __l;\n\t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n\t      __ng.get(*this, 0, *this, __err, __l);\n\n\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t      // 696. istream::operator>>(int&) broken.\n\t      if (__l < __gnu_cxx::__numeric_traits<int>::__min)\n\t\t{\n\t\t  __err |= ios_base::failbit;\n\t\t  __n = __gnu_cxx::__numeric_traits<int>::__min;\n\t\t}\n\t      else if (__l > __gnu_cxx::__numeric_traits<int>::__max)\n\t\t{\n\t\t  __err |= ios_base::failbit;\t      \n\t\t  __n = __gnu_cxx::__numeric_traits<int>::__max;\n\t\t}\n\t      else\n\t\t__n = int(__l);\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    operator>>(__streambuf_type* __sbout)\n    {\n      ios_base::iostate __err = ios_base::goodbit;\n      sentry __cerb(*this, false);\n      if (__cerb && __sbout)\n\t{\n\t  __try\n\t    {\n\t      bool __ineof;\n\t      if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))\n\t\t__err |= ios_base::failbit;\n\t      if (__ineof)\n\t\t__err |= ios_base::eofbit;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::failbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::failbit); }\n\t}\n      else if (!__sbout)\n\t__err |= ios_base::failbit;\n      if (__err)\n\tthis->setstate(__err);\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    typename basic_istream<_CharT, _Traits>::int_type\n    basic_istream<_CharT, _Traits>::\n    get(void)\n    {\n      const int_type __eof = traits_type::eof();\n      int_type __c = __eof;\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base::goodbit;\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  __try\n\t    {\n\t      __c = this->rdbuf()->sbumpc();\n\t      // 27.6.1.1 paragraph 3\n\t      if (!traits_type::eq_int_type(__c, __eof))\n\t\t_M_gcount = 1;\n\t      else\n\t\t__err |= ios_base::eofbit;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t}\n      if (!_M_gcount)\n\t__err |= ios_base::failbit;\n      if (__err)\n\tthis->setstate(__err);\n      return __c;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    get(char_type& __c)\n    {\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base::goodbit;\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  __try\n\t    {\n\t      const int_type __cb = this->rdbuf()->sbumpc();\n\t      // 27.6.1.1 paragraph 3\n\t      if (!traits_type::eq_int_type(__cb, traits_type::eof()))\n\t\t{\n\t\t  _M_gcount = 1;\n\t\t  __c = traits_type::to_char_type(__cb);\n\t\t}\n\t      else\n\t\t__err |= ios_base::eofbit;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t}\n      if (!_M_gcount)\n\t__err |= ios_base::failbit;\n      if (__err)\n\tthis->setstate(__err);\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    get(char_type* __s, streamsize __n, char_type __delim)\n    {\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base::goodbit;\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  __try\n\t    {\n\t      const int_type __idelim = traits_type::to_int_type(__delim);\n\t      const int_type __eof = traits_type::eof();\n\t      __streambuf_type* __sb = this->rdbuf();\n\t      int_type __c = __sb->sgetc();\n\n\t      while (_M_gcount + 1 < __n\n\t\t     && !traits_type::eq_int_type(__c, __eof)\n\t\t     && !traits_type::eq_int_type(__c, __idelim))\n\t\t{\n\t\t  *__s++ = traits_type::to_char_type(__c);\n\t\t  ++_M_gcount;\n\t\t  __c = __sb->snextc();\n\t\t}\n\t      if (traits_type::eq_int_type(__c, __eof))\n\t\t__err |= ios_base::eofbit;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t}\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 243. get and getline when sentry reports failure.\n      if (__n > 0)\n\t*__s = char_type();\n      if (!_M_gcount)\n\t__err |= ios_base::failbit;\n      if (__err)\n\tthis->setstate(__err);\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    get(__streambuf_type& __sb, char_type __delim)\n    {\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base::goodbit;\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  __try\n\t    {\n\t      const int_type __idelim = traits_type::to_int_type(__delim);\n\t      const int_type __eof = traits_type::eof();\n\t      __streambuf_type* __this_sb = this->rdbuf();\n\t      int_type __c = __this_sb->sgetc();\n\t      char_type __c2 = traits_type::to_char_type(__c);\n\t      unsigned long long __gcount = 0;\n\n\t      while (!traits_type::eq_int_type(__c, __eof)\n\t\t     && !traits_type::eq_int_type(__c, __idelim)\n\t\t     && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))\n\t\t{\n\t\t  ++__gcount;\n\t\t  __c = __this_sb->snextc();\n\t\t  __c2 = traits_type::to_char_type(__c);\n\t\t}\n\t      if (traits_type::eq_int_type(__c, __eof))\n\t\t__err |= ios_base::eofbit;\n\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t      // 3464. istream::gcount() can overflow\n\t      if (__gcount <= __gnu_cxx::__numeric_traits<streamsize>::__max)\n\t\t_M_gcount = __gcount;\n\t      else\n\t\t_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t}\n      if (!_M_gcount)\n\t__err |= ios_base::failbit;\n      if (__err)\n\tthis->setstate(__err);\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    getline(char_type* __s, streamsize __n, char_type __delim)\n    {\n      _M_gcount = 0;\n      ios_base::iostate __err = ios_base::goodbit;\n      sentry __cerb(*this, true);\n      if (__cerb)\n        {\n          __try\n            {\n              const int_type __idelim = traits_type::to_int_type(__delim);\n              const int_type __eof = traits_type::eof();\n              __streambuf_type* __sb = this->rdbuf();\n              int_type __c = __sb->sgetc();\n\n              while (_M_gcount + 1 < __n\n                     && !traits_type::eq_int_type(__c, __eof)\n                     && !traits_type::eq_int_type(__c, __idelim))\n                {\n                  *__s++ = traits_type::to_char_type(__c);\n                  __c = __sb->snextc();\n                  ++_M_gcount;\n                }\n              if (traits_type::eq_int_type(__c, __eof))\n                __err |= ios_base::eofbit;\n              else\n                {\n                  if (traits_type::eq_int_type(__c, __idelim))\n                    {\n                      __sb->sbumpc();\n                      ++_M_gcount;\n                    }\n                  else\n                    __err |= ios_base::failbit;\n                }\n            }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n          __catch(...)\n            { this->_M_setstate(ios_base::badbit); }\n        }\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 243. get and getline when sentry reports failure.\n      if (__n > 0)\n\t*__s = char_type();\n      if (!_M_gcount)\n        __err |= ios_base::failbit;\n      if (__err)\n        this->setstate(__err);\n      return *this;\n    }\n\n  // We provide three overloads, since the first two are much simpler\n  // than the general case. Also, the latter two can thus adopt the\n  // same \"batchy\" strategy used by getline above.\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    ignore(void)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      const int_type __eof = traits_type::eof();\n\t      __streambuf_type* __sb = this->rdbuf();\n\n\t      if (traits_type::eq_int_type(__sb->sbumpc(), __eof))\n\t\t__err |= ios_base::eofbit;\n\t      else\n\t\t_M_gcount = 1;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    ignore(streamsize __n)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb && __n > 0)\n        {\n          ios_base::iostate __err = ios_base::goodbit;\n          __try\n            {\n              const int_type __eof = traits_type::eof();\n              __streambuf_type* __sb = this->rdbuf();\n              int_type __c = __sb->sgetc();\n\n\t      // N.B. On LFS-enabled platforms streamsize is still 32 bits\n\t      // wide: if we want to implement the standard mandated behavior\n\t      // for n == max() (see 27.6.1.3/24) we are at risk of signed\n\t      // integer overflow: thus these contortions. Also note that,\n\t      // by definition, when more than 2G chars are actually ignored,\n\t      // _M_gcount (the return value of gcount, that is) cannot be\n\t      // really correct, being unavoidably too small.\n\t      bool __large_ignore = false;\n\t      while (true)\n\t\t{\n\t\t  while (_M_gcount < __n\n\t\t\t && !traits_type::eq_int_type(__c, __eof))\n\t\t    {\n\t\t      ++_M_gcount;\n\t\t      __c = __sb->snextc();\n\t\t    }\n\t\t  if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max\n\t\t      && !traits_type::eq_int_type(__c, __eof))\n\t\t    {\n\t\t      _M_gcount =\n\t\t\t__gnu_cxx::__numeric_traits<streamsize>::__min;\n\t\t      __large_ignore = true;\n\t\t    }\n\t\t  else\n\t\t    break;\n\t\t}\n\n\t      if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)\n\t\t{\n\t\t  if (__large_ignore)\n\t\t    _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n\n\t\t  if (traits_type::eq_int_type(__c, __eof))\n\t\t    __err |= ios_base::eofbit;\n\t\t}\n\t      else if (_M_gcount < __n)\n\t\t{\n\t\t  if (traits_type::eq_int_type(__c, __eof))\n\t\t    __err |= ios_base::eofbit;\n\t\t}\n            }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n          __catch(...)\n            { this->_M_setstate(ios_base::badbit); }\n          if (__err)\n            this->setstate(__err);\n        }\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    ignore(streamsize __n, int_type __delim)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb && __n > 0)\n        {\n          ios_base::iostate __err = ios_base::goodbit;\n          __try\n            {\n              const int_type __eof = traits_type::eof();\n              __streambuf_type* __sb = this->rdbuf();\n              int_type __c = __sb->sgetc();\n\n\t      // See comment above.\n\t      bool __large_ignore = false;\n\t      while (true)\n\t\t{\n\t\t  while (_M_gcount < __n\n\t\t\t && !traits_type::eq_int_type(__c, __eof)\n\t\t\t && !traits_type::eq_int_type(__c, __delim))\n\t\t    {\n\t\t      ++_M_gcount;\n\t\t      __c = __sb->snextc();\n\t\t    }\n\t\t  if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max\n\t\t      && !traits_type::eq_int_type(__c, __eof)\n\t\t      && !traits_type::eq_int_type(__c, __delim))\n\t\t    {\n\t\t      _M_gcount =\n\t\t\t__gnu_cxx::__numeric_traits<streamsize>::__min;\n\t\t      __large_ignore = true;\n\t\t    }\n\t\t  else\n\t\t    break;\n\t\t}\n\n\t      if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)\n\t\t{\n\t\t  if (__large_ignore)\n\t\t    _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n\n\t\t  if (traits_type::eq_int_type(__c, __eof))\n\t\t    __err |= ios_base::eofbit;\n\t\t  else\n\t\t    {\n\t\t      if (_M_gcount != __n)\n\t\t\t++_M_gcount;\n\t\t      __sb->sbumpc();\n\t\t    }\n\t\t}\n\t      else if (_M_gcount < __n) // implies __c == __delim or EOF\n\t\t{\n\t\t  if (traits_type::eq_int_type(__c, __eof))\n\t\t    __err |= ios_base::eofbit;\n\t\t  else\n\t\t    {\n\t\t      ++_M_gcount;\n\t\t      __sb->sbumpc();\n\t\t    }\n\t\t}\n            }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n          __catch(...)\n            { this->_M_setstate(ios_base::badbit); }\n          if (__err)\n            this->setstate(__err);\n        }\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    typename basic_istream<_CharT, _Traits>::int_type\n    basic_istream<_CharT, _Traits>::\n    peek(void)\n    {\n      int_type __c = traits_type::eof();\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      __c = this->rdbuf()->sgetc();\n\t      if (traits_type::eq_int_type(__c, traits_type::eof()))\n\t\t__err |= ios_base::eofbit;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return __c;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    read(char_type* __s, streamsize __n)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      _M_gcount = this->rdbuf()->sgetn(__s, __n);\n\t      if (_M_gcount != __n)\n\t\t__err |= (ios_base::eofbit | ios_base::failbit);\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    streamsize\n    basic_istream<_CharT, _Traits>::\n    readsome(char_type* __s, streamsize __n)\n    {\n      _M_gcount = 0;\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      // Cannot compare int_type with streamsize generically.\n\t      const streamsize __num = this->rdbuf()->in_avail();\n\t      if (__num > 0)\n\t\t_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));\n\t      else if (__num == -1)\n\t\t__err |= ios_base::eofbit;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return _M_gcount;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    putback(char_type __c)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 60. What is a formatted input function?\n      _M_gcount = 0;\n      // Clear eofbit per N3168.\n      this->clear(this->rdstate() & ~ios_base::eofbit);\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      const int_type __eof = traits_type::eof();\n\t      __streambuf_type* __sb = this->rdbuf();\n\t      if (!__sb\n\t\t  || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))\n\t\t__err |= ios_base::badbit;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    unget(void)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 60. What is a formatted input function?\n      _M_gcount = 0;\n      // Clear eofbit per N3168.\n      this->clear(this->rdstate() & ~ios_base::eofbit);\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      const int_type __eof = traits_type::eof();\n\t      __streambuf_type* __sb = this->rdbuf();\n\t      if (!__sb\n\t\t  || traits_type::eq_int_type(__sb->sungetc(), __eof))\n\t\t__err |= ios_base::badbit;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    int\n    basic_istream<_CharT, _Traits>::\n    sync(void)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR60.  Do not change _M_gcount.\n      int __ret = -1;\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      __streambuf_type* __sb = this->rdbuf();\n\t      if (__sb)\n\t\t{\n\t\t  if (__sb->pubsync() == -1)\n\t\t    __err |= ios_base::badbit;\n\t\t  else\n\t\t    __ret = 0;\n\t\t}\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return __ret;\n    }\n\n  template<typename _CharT, typename _Traits>\n    typename basic_istream<_CharT, _Traits>::pos_type\n    basic_istream<_CharT, _Traits>::\n    tellg(void)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR60.  Do not change _M_gcount.\n      pos_type __ret = pos_type(-1);\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  __try\n\t    {\n\t      if (!this->fail())\n\t\t__ret = this->rdbuf()->pubseekoff(0, ios_base::cur,\n\t\t\t\t\t\t  ios_base::in);\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t}\n      return __ret;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    seekg(pos_type __pos)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR60.  Do not change _M_gcount.\n      // Clear eofbit per N3168.\n      this->clear(this->rdstate() & ~ios_base::eofbit);\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      if (!this->fail())\n\t\t{\n\t\t  // 136.  seekp, seekg setting wrong streams?\n\t\t  const pos_type __p = this->rdbuf()->pubseekpos(__pos,\n\t\t\t\t\t\t\t\t ios_base::in);\n\t\t  \n\t\t  // 129.  Need error indication from seekp() and seekg()\n\t\t  if (__p == pos_type(off_type(-1)))\n\t\t    __err |= ios_base::failbit;\n\t\t}\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    basic_istream<_CharT, _Traits>::\n    seekg(off_type __off, ios_base::seekdir __dir)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // DR60.  Do not change _M_gcount.\n      // Clear eofbit per N3168.\n      this->clear(this->rdstate() & ~ios_base::eofbit);\n      sentry __cerb(*this, true);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      if (!this->fail())\n\t\t{\n\t\t  // 136.  seekp, seekg setting wrong streams?\n\t\t  const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,\n\t\t\t\t\t\t\t\t ios_base::in);\n\t      \n\t\t  // 129.  Need error indication from seekp() and seekg()\n\t\t  if (__p == pos_type(off_type(-1)))\n\t\t    __err |= ios_base::failbit;\n\t\t}\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      this->_M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { this->_M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    this->setstate(__err);\n\t}\n      return *this;\n    }\n\n  // 27.6.1.2.3 Character extraction templates\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)\n    {\n      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n      typedef typename __istream_type::int_type         __int_type;\n\n      typename __istream_type::sentry __cerb(__in, false);\n      if (__cerb)\n\t{\n\t  ios_base::iostate __err = ios_base::goodbit;\n\t  __try\n\t    {\n\t      const __int_type __cb = __in.rdbuf()->sbumpc();\n\t      if (!_Traits::eq_int_type(__cb, _Traits::eof()))\n\t\t__c = _Traits::to_char_type(__cb);\n\t      else\n\t\t__err |= (ios_base::eofbit | ios_base::failbit);\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      __in._M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { __in._M_setstate(ios_base::badbit); }\n\t  if (__err)\n\t    __in.setstate(__err);\n\t}\n      return __in;\n    }\n\n  template<typename _CharT, typename _Traits>\n    void\n    __istream_extract(basic_istream<_CharT, _Traits>& __in, _CharT* __s,\n\t\t      streamsize __num)\n    {\n      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n      typedef basic_streambuf<_CharT, _Traits>          __streambuf_type;\n      typedef typename _Traits::int_type\t\tint_type;\n      typedef _CharT\t\t\t\t\tchar_type;\n      typedef ctype<_CharT>\t\t\t\t__ctype_type;\n\n      streamsize __extracted = 0;\n      ios_base::iostate __err = ios_base::goodbit;\n      typename __istream_type::sentry __cerb(__in, false);\n      if (__cerb)\n\t{\n\t  __try\n\t    {\n\t      // Figure out how many characters to extract.\n\t      streamsize __width = __in.width();\n\t      if (0 < __width && __width < __num)\n\t\t__num = __width;\n\n\t      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());\n\n\t      const int_type __eof = _Traits::eof();\n\t      __streambuf_type* __sb = __in.rdbuf();\n\t      int_type __c = __sb->sgetc();\n\n\t      while (__extracted < __num - 1\n\t\t     && !_Traits::eq_int_type(__c, __eof)\n\t\t     && !__ct.is(ctype_base::space,\n\t\t\t\t _Traits::to_char_type(__c)))\n\t\t{\n\t\t  *__s++ = _Traits::to_char_type(__c);\n\t\t  ++__extracted;\n\t\t  __c = __sb->snextc();\n\t\t}\n\n\t      if (__extracted < __num - 1\n\t\t  && _Traits::eq_int_type(__c, __eof))\n\t\t__err |= ios_base::eofbit;\n\n\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t      // 68.  Extractors for char* should store null at end\n\t      *__s = char_type();\n\t      __in.width(0);\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      __in._M_setstate(ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    { __in._M_setstate(ios_base::badbit); }\n\t}\n      if (!__extracted)\n\t__err |= ios_base::failbit;\n      if (__err)\n\t__in.setstate(__err);\n    }\n\n  // 27.6.1.4 Standard basic_istream manipulators\n  template<typename _CharT, typename _Traits>\n    basic_istream<_CharT, _Traits>&\n    ws(basic_istream<_CharT, _Traits>& __in)\n    {\n      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n      typedef basic_streambuf<_CharT, _Traits>          __streambuf_type;\n      typedef typename __istream_type::int_type\t\t__int_type;\n      typedef ctype<_CharT>\t\t\t\t__ctype_type;\n\n      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());\n      const __int_type __eof = _Traits::eof();\n      __streambuf_type* __sb = __in.rdbuf();\n      __int_type __c = __sb->sgetc();\n\n      while (!_Traits::eq_int_type(__c, __eof)\n\t     && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))\n\t__c = __sb->snextc();\n\n       if (_Traits::eq_int_type(__c, __eof))\n\t __in.setstate(ios_base::eofbit);\n      return __in;\n    }\n\n  // Inhibit implicit instantiations for required instantiations,\n  // which are defined via explicit instantiations elsewhere.\n#if _GLIBCXX_EXTERN_TEMPLATE\n  extern template class basic_istream<char>;\n  extern template istream& ws(istream&);\n  extern template istream& operator>>(istream&, char&);\n  extern template istream& operator>>(istream&, unsigned char&);\n  extern template istream& operator>>(istream&, signed char&);\n\n  extern template istream& istream::_M_extract(unsigned short&);\n  extern template istream& istream::_M_extract(unsigned int&);  \n  extern template istream& istream::_M_extract(long&);\n  extern template istream& istream::_M_extract(unsigned long&);\n  extern template istream& istream::_M_extract(bool&);\n#ifdef _GLIBCXX_USE_LONG_LONG\n  extern template istream& istream::_M_extract(long long&);\n  extern template istream& istream::_M_extract(unsigned long long&);\n#endif\n  extern template istream& istream::_M_extract(float&);\n  extern template istream& istream::_M_extract(double&);\n  extern template istream& istream::_M_extract(long double&);\n  extern template istream& istream::_M_extract(void*&);\n\n  extern template class basic_iostream<char>;\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  extern template class basic_istream<wchar_t>;\n  extern template wistream& ws(wistream&);\n  extern template wistream& operator>>(wistream&, wchar_t&);\n  extern template void __istream_extract(wistream&, wchar_t*, streamsize);\n\n  extern template wistream& wistream::_M_extract(unsigned short&);\n  extern template wistream& wistream::_M_extract(unsigned int&);  \n  extern template wistream& wistream::_M_extract(long&);\n  extern template wistream& wistream::_M_extract(unsigned long&);\n  extern template wistream& wistream::_M_extract(bool&);\n#ifdef _GLIBCXX_USE_LONG_LONG\n  extern template wistream& wistream::_M_extract(long long&);\n  extern template wistream& wistream::_M_extract(unsigned long long&);\n#endif\n  extern template wistream& wistream::_M_extract(float&);\n  extern template wistream& wistream::_M_extract(double&);\n  extern template wistream& wistream::_M_extract(long double&);\n  extern template wistream& wistream::_M_extract(void*&);\n\n  extern template class basic_iostream<wchar_t>;\n#endif\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif\n"}],"crc32":1595780944,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]