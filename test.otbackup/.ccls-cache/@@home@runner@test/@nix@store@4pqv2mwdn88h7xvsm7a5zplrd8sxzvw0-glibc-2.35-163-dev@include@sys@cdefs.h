[{"ops":[{"insert":"/* Copyright (C) 1992-2022 Free Software Foundation, Inc.\n   Copyright The GNU Toolchain Authors.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n#ifndef\t_SYS_CDEFS_H\n#define\t_SYS_CDEFS_H\t1\n\n/* We are almost always included from features.h. */\n#ifndef _FEATURES_H\n# include <features.h>\n#endif\n\n/* The GNU libc does not support any K&R compilers or the traditional mode\n   of ISO C compilers anymore.  Check for some of the combinations not\n   supported anymore.  */\n#if defined __GNUC__ && !defined __STDC__\n# error \"You need a ISO C conforming compiler to use the glibc headers\"\n#endif\n\n/* Some user header file might have defined this before.  */\n#undef\t__P\n#undef\t__PMT\n\n/* Compilers that lack __has_attribute may object to\n       #if defined __has_attribute && __has_attribute (...)\n   even though they do not need to evaluate the right-hand side of the &&.\n   Similarly for __has_builtin, etc.  */\n#if (defined __has_attribute \\\n     && (!defined __clang_minor__ \\\n         || 3 < __clang_major__ + (5 <= __clang_minor__)))\n# define __glibc_has_attribute(attr) __has_attribute (attr)\n#else\n# define __glibc_has_attribute(attr) 0\n#endif\n#ifdef __has_builtin\n# define __glibc_has_builtin(name) __has_builtin (name)\n#else\n# define __glibc_has_builtin(name) 0\n#endif\n#ifdef __has_extension\n# define __glibc_has_extension(ext) __has_extension (ext)\n#else\n# define __glibc_has_extension(ext) 0\n#endif\n\n#if defined __GNUC__ || defined __clang__\n\n/* All functions, except those with callbacks or those that\n   synchronize memory, are leaf functions.  */\n# if __GNUC_PREREQ (4, 6) && !defined _LIBC\n#  define __LEAF , __leaf__\n#  define __LEAF_ATTR __attribute__ ((__leaf__))\n# else\n#  define __LEAF\n#  define __LEAF_ATTR\n# endif\n\n/* GCC can always grok prototypes.  For C++ programs we add throw()\n   to help it optimize the function calls.  But this only works with\n   gcc 2.8.x and egcs.  For gcc 3.4 and up we even mark C functions\n   as non-throwing using a function attribute since programs can use\n   the -fexceptions options for C code as well.  */\n# if !defined __cplusplus \\\n     && (__GNUC_PREREQ (3, 4) || __glibc_has_attribute (__nothrow__))\n#  define __THROW\t__attribute__ ((__nothrow__ __LEAF))\n#  define __THROWNL\t__attribute__ ((__nothrow__))\n#  define __NTH(fct)\t__attribute__ ((__nothrow__ __LEAF)) fct\n#  define __NTHNL(fct)  __attribute__ ((__nothrow__)) fct\n# else\n#  if defined __cplusplus && (__GNUC_PREREQ (2,8) || __clang_major >= 4)\n#   if __cplusplus >= 201103L\n#    define __THROW\tnoexcept (true)\n#   else\n#    define __THROW\tthrow ()\n#   endif\n#   define __THROWNL\t__THROW\n#   define __NTH(fct)\t__LEAF_ATTR fct __THROW\n#   define __NTHNL(fct) fct __THROW\n#  else\n#   define __THROW\n#   define __THROWNL\n#   define __NTH(fct)\tfct\n#   define __NTHNL(fct) fct\n#  endif\n# endif\n\n#else\t/* Not GCC or clang.  */\n\n# if (defined __cplusplus\t\t\t\t\t\t\\\n      || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))\n#  define __inline\tinline\n# else\n#  define __inline\t\t/* No inline functions.  */\n# endif\n\n# define __THROW\n# define __THROWNL\n# define __NTH(fct)\tfct\n\n#endif\t/* GCC || clang.  */\n\n/* These two macros are not used in glibc anymore.  They are kept here\n   only because some other projects expect the macros to be defined.  */\n#define __P(args)\targs\n#define __PMT(args)\targs\n\n/* For these things, GCC behaves the ANSI way normally,\n   and the non-ANSI way under -traditional.  */\n\n#define __CONCAT(x,y)\tx ## y\n#define __STRING(x)\t#x\n\n/* This is not a typedef so `const __ptr_t' does the right thing.  */\n#define __ptr_t void *\n\n\n/* C++ needs to know that types and declarations are C, not C++.  */\n#ifdef\t__cplusplus\n# define __BEGIN_DECLS\textern \"C\" {\n# define __END_DECLS\t}\n#else\n# define __BEGIN_DECLS\n# define __END_DECLS\n#endif\n\n\n/* Fortify support.  */\n#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)\n#define __bos0(ptr) __builtin_object_size (ptr, 0)\n\n/* Use __builtin_dynamic_object_size at _FORTIFY_SOURCE=3 when available.  */\n#if __USE_FORTIFY_LEVEL == 3 && (__glibc_clang_prereq (9, 0)\t\t      \\\n\t\t\t\t || __GNUC_PREREQ (12, 0))\n# define __glibc_objsize0(__o) __builtin_dynamic_object_size (__o, 0)\n# define __glibc_objsize(__o) __builtin_dynamic_object_size (__o, 1)\n#else\n# define __glibc_objsize0(__o) __bos0 (__o)\n# define __glibc_objsize(__o) __bos (__o)\n#endif\n\n/* Compile time conditions to choose between the regular, _chk and _chk_warn\n   variants.  These conditions should get evaluated to constant and optimized\n   away.  */\n\n#define __glibc_safe_len_cond(__l, __s, __osz) ((__l) <= (__osz) / (__s))\n#define __glibc_unsigned_or_positive(__l) \\\n  ((__typeof (__l)) 0 < (__typeof (__l)) -1\t\t\t\t      \\\n   || (__builtin_constant_p (__l) && (__l) > 0))\n\n/* Length is known to be safe at compile time if the __L * __S <= __OBJSZ\n   condition can be folded to a constant and if it is true, or unknown (-1) */\n#define __glibc_safe_or_unknown_len(__l, __s, __osz) \\\n  ((__builtin_constant_p (__osz) && (__osz) == (__SIZE_TYPE__) -1)\t      \\\n   || (__glibc_unsigned_or_positive (__l)\t\t\t\t      \\\n       && __builtin_constant_p (__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), \\\n\t\t\t\t\t\t       (__s), (__osz)))\t      \\\n       && __glibc_safe_len_cond ((__SIZE_TYPE__) (__l), (__s), (__osz))))\n\n/* Conversely, we know at compile time that the length is unsafe if the\n   __L * __S <= __OBJSZ condition can be folded to a constant and if it is\n   false.  */\n#define __glibc_unsafe_len(__l, __s, __osz) \\\n  (__glibc_unsigned_or_positive (__l)\t\t\t\t\t      \\\n   && __builtin_constant_p (__glibc_safe_len_cond ((__SIZE_TYPE__) (__l),     \\\n\t\t\t\t\t\t   __s, __osz))\t\t      \\\n   && !__glibc_safe_len_cond ((__SIZE_TYPE__) (__l), __s, __osz))\n\n/* Fortify function f.  __f_alias, __f_chk and __f_chk_warn must be\n   declared.  */\n\n#define __glibc_fortify(f, __l, __s, __osz, ...) \\\n  (__glibc_safe_or_unknown_len (__l, __s, __osz)\t\t\t      \\\n   ? __ ## f ## _alias (__VA_ARGS__)\t\t\t\t\t      \\\n   : (__glibc_unsafe_len (__l, __s, __osz)\t\t\t\t      \\\n      ? __ ## f ## _chk_warn (__VA_ARGS__, __osz)\t\t\t      \\\n      : __ ## f ## _chk (__VA_ARGS__, __osz)))\t\t\t      \\\n\n/* Fortify function f, where object size argument passed to f is the number of\n   elements and not total size.  */\n\n#define __glibc_fortify_n(f, __l, __s, __osz, ...) \\\n  (__glibc_safe_or_unknown_len (__l, __s, __osz)\t\t\t      \\\n   ? __ ## f ## _alias (__VA_ARGS__)\t\t\t\t\t      \\\n   : (__glibc_unsafe_len (__l, __s, __osz)\t\t\t\t      \\\n      ? __ ## f ## _chk_warn (__VA_ARGS__, (__osz) / (__s))\t\t      \\\n      : __ ## f ## _chk (__VA_ARGS__, (__osz) / (__s))))\t\t      \\\n\n#if __GNUC_PREREQ (4,3)\n# define __warnattr(msg) __attribute__((__warning__ (msg)))\n# define __errordecl(name, msg) \\\n  extern void name (void) __attribute__((__error__ (msg)))\n#else\n# define __warnattr(msg)\n# define __errordecl(name, msg) extern void name (void)\n#endif\n\n/* Support for flexible arrays.\n   Headers that should use flexible arrays only if they're \"real\"\n   (e.g. only if they won't affect sizeof()) should test\n   #if __glibc_c99_flexarr_available.  */\n#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L && !defined __HP_cc\n# define __flexarr\t[]\n# define __glibc_c99_flexarr_available 1\n#elif __GNUC_PREREQ (2,97) || defined __clang__\n/* GCC 2.97 and clang support C99 flexible array members as an extension,\n   even when in C89 mode or compiling C++ (any version).  */\n# define __flexarr\t[]\n# define __glibc_c99_flexarr_available 1\n#elif defined __GNUC__\n/* Pre-2.97 GCC did not support C99 flexible arrays but did have\n   an equivalent extension with slightly different notation.  */\n# define __flexarr\t[0]\n# define __glibc_c99_flexarr_available 1\n#else\n/* Some other non-C99 compiler.  Approximate with [1].  */\n# define __flexarr\t[1]\n# define __glibc_c99_flexarr_available 0\n#endif\n\n\n/* __asm__ (\"xyz\") is used throughout the headers to rename functions\n   at the assembly language level.  This is wrapped by the __REDIRECT\n   macro, in order to support compilers that can do this some other\n   way.  When compilers don't support asm-names at all, we have to do\n   preprocessor tricks instead (which don't have exactly the right\n   semantics, but it's the best we can do).\n\n   Example:\n   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */\n\n#if (defined __GNUC__ && __GNUC__ >= 2) || (__clang_major__ >= 4)\n\n# define __REDIRECT(name, proto, alias) name proto __asm__ (__ASMNAME (#alias))\n# ifdef __cplusplus\n#  define __REDIRECT_NTH(name, proto, alias) \\\n     name proto __THROW __asm__ (__ASMNAME (#alias))\n#  define __REDIRECT_NTHNL(name, proto, alias) \\\n     name proto __THROWNL __asm__ (__ASMNAME (#alias))\n# else\n#  define __REDIRECT_NTH(name, proto, alias) \\\n     name proto __asm__ (__ASMNAME (#alias)) __THROW\n#  define __REDIRECT_NTHNL(name, proto, alias) \\\n     name proto __asm__ (__ASMNAME (#alias)) __THROWNL\n# endif\n# define __ASMNAME(cname)  __ASMNAME2 (__USER_LABEL_PREFIX__, cname)\n# define __ASMNAME2(prefix, cname) __STRING (prefix) cname\n\n/*\n#elif __SOME_OTHER_COMPILER__\n\n# define __REDIRECT(name, proto, alias) name proto; \\\n\t_Pragma(\"let \" #name \" = \" #alias)\n*/\n#endif\n\n/* GCC and clang have various useful declarations that can be made with\n   the '__attribute__' syntax.  All of the ways we use this do fine if\n   they are omitted for compilers that don't understand it.  */\n#if !(defined __GNUC__ || defined __clang__)\n# define __attribute__(xyz)\t/* Ignore */\n#endif\n\n/* At some point during the gcc 2.96 development the `malloc' attribute\n   for functions was introduced.  We don't want to use it unconditionally\n   (although this would be possible) since it generates warnings.  */\n#if __GNUC_PREREQ (2,96) || __glibc_has_attribute (__malloc__)\n# define __attribute_malloc__ __attribute__ ((__malloc__))\n#else\n# define __attribute_malloc__ /* Ignore */\n#endif\n\n/* Tell the compiler which arguments to an allocation function\n   indicate the size of the allocation.  */\n#if __GNUC_PREREQ (4, 3)\n# define __attribute_alloc_size__(params) \\\n  __attribute__ ((__alloc_size__ params))\n#else\n# define __attribute_alloc_size__(params) /* Ignore.  */\n#endif\n\n/* Tell the compiler which argument to an allocation function\n   indicates the alignment of the allocation.  */\n#if __GNUC_PREREQ (4, 9) || __glibc_has_attribute (__alloc_align__)\n# define __attribute_alloc_align__(param) \\\n  __attribute__ ((__alloc_align__ param))\n#else\n# define __attribute_alloc_align__(param) /* Ignore.  */\n#endif\n\n/* At some point during the gcc 2.96 development the `pure' attribute\n   for functions was introduced.  We don't want to use it unconditionally\n   (although this would be possible) since it generates warnings.  */\n#if __GNUC_PREREQ (2,96) || __glibc_has_attribute (__pure__)\n# define __attribute_pure__ __attribute__ ((__pure__))\n#else\n# define __attribute_pure__ /* Ignore */\n#endif\n\n/* This declaration tells the compiler that the value is constant.  */\n#if __GNUC_PREREQ (2,5) || __glibc_has_attribute (__const__)\n# define __attribute_const__ __attribute__ ((__const__))\n#else\n# define __attribute_const__ /* Ignore */\n#endif\n\n#if __GNUC_PREREQ (2,7) || __glibc_has_attribute (__unused__)\n# define __attribute_maybe_unused__ __attribute__ ((__unused__))\n#else\n# define __attribute_maybe_unused__ /* Ignore */\n#endif\n\n/* At some point during the gcc 3.1 development the `used' attribute\n   for functions was introduced.  We don't want to use it unconditionally\n   (although this would be possible) since it generates warnings.  */\n#if __GNUC_PREREQ (3,1) || __glibc_has_attribute (__used__)\n# define __attribute_used__ __attribute__ ((__used__))\n# define __attribute_noinline__ __attribute__ ((__noinline__))\n#else\n# define __attribute_used__ __attribute__ ((__unused__))\n# define __attribute_noinline__ /* Ignore */\n#endif\n\n/* Since version 3.2, gcc allows marking deprecated functions.  */\n#if __GNUC_PREREQ (3,2) || __glibc_has_attribute (__deprecated__)\n# define __attribute_deprecated__ __attribute__ ((__deprecated__))\n#else\n# define __attribute_deprecated__ /* Ignore */\n#endif\n\n/* Since version 4.5, gcc also allows one to specify the message printed\n   when a deprecated function is used.  clang claims to be gcc 4.2, but\n   may also support this feature.  */\n#if __GNUC_PREREQ (4,5) \\\n    || __glibc_has_extension (__attribute_deprecated_with_message__)\n# define __attribute_deprecated_msg__(msg) \\\n\t __attribute__ ((__deprecated__ (msg)))\n#else\n# define __attribute_deprecated_msg__(msg) __attribute_deprecated__\n#endif\n\n/* At some point during the gcc 2.8 development the `format_arg' attribute\n   for functions was introduced.  We don't want to use it unconditionally\n   (although this would be possible) since it generates warnings.\n   If several `format_arg' attributes are given for the same function, in\n   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,\n   all designated arguments are considered.  */\n#if __GNUC_PREREQ (2,8) || __glibc_has_attribute (__format_arg__)\n# define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))\n#else\n# define __attribute_format_arg__(x) /* Ignore */\n#endif\n\n/* At some point during the gcc 2.97 development the `strfmon' format\n   attribute for functions was introduced.  We don't want to use it\n   unconditionally (although this would be possible) since it\n   generates warnings.  */\n#if __GNUC_PREREQ (2,97) || __glibc_has_attribute (__format__)\n# define __attribute_format_strfmon__(a,b) \\\n  __attribute__ ((__format__ (__strfmon__, a, b)))\n#else\n# define __attribute_format_strfmon__(a,b) /* Ignore */\n#endif\n\n/* The nonnull function attribute marks pointer parameters that\n   must not be NULL.  This has the name __nonnull in glibc,\n   and __attribute_nonnull__ in files shared with Gnulib to avoid\n   collision with a different __nonnull in DragonFlyBSD 5.9.  */\n#ifndef __attribute_nonnull__\n# if __GNUC_PREREQ (3,3) || __glibc_has_attribute (__nonnull__)\n#  define __attribute_nonnull__(params) __attribute__ ((__nonnull__ params))\n# else\n#  define __attribute_nonnull__(params)\n# endif\n#endif\n#ifndef __nonnull\n# define __nonnull(params) __attribute_nonnull__ (params)\n#endif\n\n/* The returns_nonnull function attribute marks the return type of the function\n   as always being non-null.  */\n#ifndef __returns_nonnull\n# if __GNUC_PREREQ (4, 9) || __glibc_has_attribute (__returns_nonnull__)\n# define __returns_nonnull __attribute__ ((__returns_nonnull__))\n# else\n# define __returns_nonnull\n# endif\n#endif\n\n/* If fortification mode, we warn about unused results of certain\n   function calls which can lead to problems.  */\n#if __GNUC_PREREQ (3,4) || __glibc_has_attribute (__warn_unused_result__)\n# define __attribute_warn_unused_result__ \\\n   __attribute__ ((__warn_unused_result__))\n# if defined __USE_FORTIFY_LEVEL && __USE_FORTIFY_LEVEL > 0\n#  define __wur __attribute_warn_unused_result__\n# endif\n#else\n# define __attribute_warn_unused_result__ /* empty */\n#endif\n#ifndef __wur\n# define __wur /* Ignore */\n#endif\n\n/* Forces a function to be always inlined.  */\n#if __GNUC_PREREQ (3,2) || __glibc_has_attribute (__always_inline__)\n/* The Linux kernel defines __always_inline in stddef.h (283d7573), and\n   it conflicts with this definition.  Therefore undefine it first to\n   allow either header to be included first.  */\n# undef __always_inline\n# define __always_inline __inline __attribute__ ((__always_inline__))\n#else\n# undef __always_inline\n# define __always_inline __inline\n#endif\n\n/* Associate error messages with the source location of the call site rather\n   than with the source location inside the function.  */\n#if __GNUC_PREREQ (4,3) || __glibc_has_attribute (__artificial__)\n# define __attribute_artificial__ __attribute__ ((__artificial__))\n#else\n# define __attribute_artificial__ /* Ignore */\n#endif\n\n/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99\n   inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__\n   or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions\n   older than 4.3 may define these macros and still not guarantee GNU inlining\n   semantics.\n\n   clang++ identifies itself as gcc-4.2, but has support for GNU inlining\n   semantics, that can be checked for by using the __GNUC_STDC_INLINE_ and\n   __GNUC_GNU_INLINE__ macro definitions.  */\n#if (!defined __cplusplus || __GNUC_PREREQ (4,3) \\\n     || (defined __clang__ && (defined __GNUC_STDC_INLINE__ \\\n\t\t\t       || defined __GNUC_GNU_INLINE__)))\n# if defined __GNUC_STDC_INLINE__ || defined __cplusplus\n#  define __extern_inline extern __inline __attribute__ ((__gnu_inline__))\n#  define __extern_always_inline \\\n  extern __always_inline __attribute__ ((__gnu_inline__))\n# else\n#  define __extern_inline extern __inline\n#  define __extern_always_inline extern __always_inline\n# endif\n#endif\n\n#ifdef __extern_always_inline\n# define __fortify_function __extern_always_inline __attribute_artificial__\n#endif\n\n/* GCC 4.3 and above allow passing all anonymous arguments of an\n   __extern_always_inline function to some other vararg function.  */\n#if __GNUC_PREREQ (4,3)\n# define __va_arg_pack() __builtin_va_arg_pack ()\n# define __va_arg_pack_len() __builtin_va_arg_pack_len ()\n#endif\n\n/* It is possible to compile containing GCC extensions even if GCC is\n   run in pedantic mode if the uses are carefully marked using the\n   `__extension__' keyword.  But this is not generally available before\n   version 2.8.  */\n#if !(__GNUC_PREREQ (2,8) || defined __clang__)\n# define __extension__\t\t/* Ignore */\n#endif\n\n/* __restrict is known in EGCS 1.2 and above, and in clang.\n   It works also in C++ mode (outside of arrays), but only when spelled\n   as '__restrict', not 'restrict'.  */\n#if !(__GNUC_PREREQ (2,92) || __clang_major__ >= 3)\n# if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L\n#  define __restrict\trestrict\n# else\n#  define __restrict\t/* Ignore */\n# endif\n#endif\n\n/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is\n     array_name[restrict]\n   GCC 3.1 and clang support this.\n   This syntax is not usable in C++ mode.  */\n#if (__GNUC_PREREQ (3,1) || __clang_major__ >= 3) && !defined __cplusplus\n# define __restrict_arr\t__restrict\n#else\n# ifdef __GNUC__\n#  define __restrict_arr\t/* Not supported in old GCC.  */\n# else\n#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L\n#   define __restrict_arr\trestrict\n#  else\n/* Some other non-C99 compiler.  */\n#   define __restrict_arr\t/* Not supported.  */\n#  endif\n# endif\n#endif\n\n#if (__GNUC__ >= 3) || __glibc_has_builtin (__builtin_expect)\n# define __glibc_unlikely(cond)\t__builtin_expect ((cond), 0)\n# define __glibc_likely(cond)\t__builtin_expect ((cond), 1)\n#else\n# define __glibc_unlikely(cond)\t(cond)\n# define __glibc_likely(cond)\t(cond)\n#endif\n\n#if (!defined _Noreturn \\\n     && (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) < 201112 \\\n     &&  !(__GNUC_PREREQ (4,7) \\\n           || (3 < __clang_major__ + (5 <= __clang_minor__))))\n# if __GNUC_PREREQ (2,8)\n#  define _Noreturn __attribute__ ((__noreturn__))\n# else\n#  define _Noreturn\n# endif\n#endif\n\n#if __GNUC_PREREQ (8, 0)\n/* Describes a char array whose address can safely be passed as the first\n   argument to strncpy and strncat, as the char array is not necessarily\n   a NUL-terminated string.  */\n# define __attribute_nonstring__ __attribute__ ((__nonstring__))\n#else\n# define __attribute_nonstring__\n#endif\n\n/* Undefine (also defined in libc-symbols.h).  */\n#undef __attribute_copy__\n#if __GNUC_PREREQ (9, 0)\n/* Copies attributes from the declaration or type referenced by\n   the argument.  */\n# define __attribute_copy__(arg) __attribute__ ((__copy__ (arg)))\n#else\n# define __attribute_copy__(arg)\n#endif\n\n#if (!defined _Static_assert && !defined __cplusplus \\\n     && (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) < 201112 \\\n     && (!(__GNUC_PREREQ (4, 6) || __clang_major__ >= 4) \\\n         || defined __STRICT_ANSI__))\n# define _Static_assert(expr, diagnostic) \\\n    extern int (*__Static_assert_function (void)) \\\n      [!!sizeof (struct { int __error_if_negative: (expr) ? 2 : -1; })]\n#endif\n\n/* Gnulib avoids including these, as they don't work on non-glibc or\n   older glibc platforms.  */\n#ifndef __GNULIB_CDEFS\n# include <bits/wordsize.h>\n# include <bits/long-double.h>\n#endif\n\n#if __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 1\n# ifdef __REDIRECT\n\n/* Alias name defined automatically.  */\n#  define __LDBL_REDIR(name, proto) ... unused__ldbl_redir\n#  define __LDBL_REDIR_DECL(name) \\\n  extern __typeof (name) name __asm (__ASMNAME (\"__\" #name \"ieee128\"));\n\n/* Alias name defined automatically, with leading underscores.  */\n#  define __LDBL_REDIR2_DECL(name) \\\n  extern __typeof (__##name) __##name \\\n    __asm (__ASMNAME (\"__\" #name \"ieee128\"));\n\n/* Alias name defined manually.  */\n#  define __LDBL_REDIR1(name, proto, alias) ... unused__ldbl_redir1\n#  define __LDBL_REDIR1_DECL(name, alias) \\\n  extern __typeof (name) name __asm (__ASMNAME (#alias));\n\n#  define __LDBL_REDIR1_NTH(name, proto, alias) \\\n  __REDIRECT_NTH (name, proto, alias)\n#  define __REDIRECT_NTH_LDBL(name, proto, alias) \\\n  __LDBL_REDIR1_NTH (name, proto, __##alias##ieee128)\n\n/* Unused.  */\n#  define __REDIRECT_LDBL(name, proto, alias) ... unused__redirect_ldbl\n#  define __LDBL_REDIR_NTH(name, proto) ... unused__ldbl_redir_nth\n\n# else\n_Static_assert (0, \"IEEE 128-bits long double requires redirection on this platform\");\n# endif\n#elif defined __LONG_DOUBLE_MATH_OPTIONAL && defined __NO_LONG_DOUBLE_MATH\n# define __LDBL_COMPAT 1\n# ifdef __REDIRECT\n#  define __LDBL_REDIR1(name, proto, alias) __REDIRECT (name, proto, alias)\n#  define __LDBL_REDIR(name, proto) \\\n  __LDBL_REDIR1 (name, proto, __nldbl_##name)\n#  define __LDBL_REDIR1_NTH(name, proto, alias) __REDIRECT_NTH (name, proto, alias)\n#  define __LDBL_REDIR_NTH(name, proto) \\\n  __LDBL_REDIR1_NTH (name, proto, __nldbl_##name)\n#  define __LDBL_REDIR2_DECL(name) \\\n  extern __typeof (__##name) __##name __asm (__ASMNAME (\"__nldbl___\" #name));\n#  define __LDBL_REDIR1_DECL(name, alias) \\\n  extern __typeof (name) name __asm (__ASMNAME (#alias));\n#  define __LDBL_REDIR_DECL(name) \\\n  extern __typeof (name) name __asm (__ASMNAME (\"__nldbl_\" #name));\n#  define __REDIRECT_LDBL(name, proto, alias) \\\n  __LDBL_REDIR1 (name, proto, __nldbl_##alias)\n#  define __REDIRECT_NTH_LDBL(name, proto, alias) \\\n  __LDBL_REDIR1_NTH (name, proto, __nldbl_##alias)\n# endif\n#endif\n#if (!defined __LDBL_COMPAT && __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 0) \\\n    || !defined __REDIRECT\n# define __LDBL_REDIR1(name, proto, alias) name proto\n# define __LDBL_REDIR(name, proto) name proto\n# define __LDBL_REDIR1_NTH(name, proto, alias) name proto __THROW\n# define __LDBL_REDIR_NTH(name, proto) name proto __THROW\n# define __LDBL_REDIR2_DECL(name)\n# define __LDBL_REDIR_DECL(name)\n# ifdef __REDIRECT\n#  define __REDIRECT_LDBL(name, proto, alias) __REDIRECT (name, proto, alias)\n#  define __REDIRECT_NTH_LDBL(name, proto, alias) \\\n  __REDIRECT_NTH (name, proto, alias)\n# endif\n#endif\n\n/* __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is\n   intended for use in preprocessor macros.\n\n   Note: MESSAGE must be a _single_ string; concatenation of string\n   literals is not supported.  */\n#if __GNUC_PREREQ (4,8) || __glibc_clang_prereq (3,5)\n# define __glibc_macro_warning1(message) _Pragma (#message)\n# define __glibc_macro_warning(message) \\\n  __glibc_macro_warning1 (GCC warning message)\n#else\n# define __glibc_macro_warning(msg)\n#endif\n\n/* Generic selection (ISO C11) is a C-only feature, available in GCC\n   since version 4.9.  Previous versions do not provide generic\n   selection, even though they might set __STDC_VERSION__ to 201112L,\n   when in -std=c11 mode.  Thus, we must check for !defined __GNUC__\n   when testing __STDC_VERSION__ for generic selection support.\n   On the other hand, Clang also defines __GNUC__, so a clang-specific\n   check is required to enable the use of generic selection.  */\n#if !defined __cplusplus \\\n    && (__GNUC_PREREQ (4, 9) \\\n\t|| __glibc_has_extension (c_generic_selections) \\\n\t|| (!defined __GNUC__ && defined __STDC_VERSION__ \\\n\t    && __STDC_VERSION__ >= 201112L))\n# define __HAVE_GENERIC_SELECTION 1\n#else\n# define __HAVE_GENERIC_SELECTION 0\n#endif\n\n#if __GNUC_PREREQ (10, 0)\n/* Designates a 1-based positional argument ref-index of pointer type\n   that can be used to access size-index elements of the pointed-to\n   array according to access mode, or at least one element when\n   size-index is not provided:\n     access (access-mode, <ref-index> [, <size-index>])  */\n#  define __attr_access(x) __attribute__ ((__access__ x))\n/* For _FORTIFY_SOURCE == 3 we use __builtin_dynamic_object_size, which may\n   use the access attribute to get object sizes from function definition\n   arguments, so we can't use them on functions we fortify.  Drop the object\n   size hints for such functions.  */\n#  if __USE_FORTIFY_LEVEL == 3\n#    define __fortified_attr_access(a, o, s) __attribute__ ((__access__ (a, o)))\n#  else\n#    define __fortified_attr_access(a, o, s) __attr_access ((a, o, s))\n#  endif\n#  if __GNUC_PREREQ (11, 0)\n#    define __attr_access_none(argno) __attribute__ ((__access__ (__none__, argno)))\n#  else\n#    define __attr_access_none(argno)\n#  endif\n#else\n#  define __fortified_attr_access(a, o, s)\n#  define __attr_access(x)\n#  define __attr_access_none(argno)\n#endif\n\n#if __GNUC_PREREQ (11, 0)\n/* Designates dealloc as a function to call to deallocate objects\n   allocated by the declared function.  */\n# define __attr_dealloc(dealloc, argno) \\\n    __attribute__ ((__malloc__ (dealloc, argno)))\n# define __attr_dealloc_free __attr_dealloc (__builtin_free, 1)\n#else\n# define __attr_dealloc(dealloc, argno)\n# define __attr_dealloc_free\n#endif\n\n/* Specify that a function such as setjmp or vfork may return\n   twice.  */\n#if __GNUC_PREREQ (4, 1)\n# define __attribute_returns_twice__ __attribute__ ((__returns_twice__))\n#else\n# define __attribute_returns_twice__ /* Ignore.  */\n#endif\n\n#endif\t /* sys/cdefs.h */\n"}],"crc32":1318422092,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]