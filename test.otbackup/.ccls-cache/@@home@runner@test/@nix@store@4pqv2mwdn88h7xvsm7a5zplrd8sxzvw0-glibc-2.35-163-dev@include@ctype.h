[{"ops":[{"insert":"/* Copyright (C) 1991-2022 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <https://www.gnu.org/licenses/>.  */\n\n/*\n *\tISO C99 Standard 7.4: Character handling\t<ctype.h>\n */\n\n#ifndef\t_CTYPE_H\n#define\t_CTYPE_H\t1\n\n#include <features.h>\n#include <bits/types.h>\n\n__BEGIN_DECLS\n\n#ifndef _ISbit\n/* These are all the characteristics of characters.\n   If there get to be more than 16 distinct characteristics,\n   many things must be changed that use `unsigned short int's.\n\n   The characteristics are stored always in network byte order (big\n   endian).  We define the bit value interpretations here dependent on the\n   machine's byte order.  */\n\n# include <bits/endian.h>\n# if __BYTE_ORDER == __BIG_ENDIAN\n#  define _ISbit(bit)\t(1 << (bit))\n# else /* __BYTE_ORDER == __LITTLE_ENDIAN */\n#  define _ISbit(bit)\t((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))\n# endif\n\nenum\n{\n  _ISupper = _ISbit (0),\t/* UPPERCASE.  */\n  _ISlower = _ISbit (1),\t/* lowercase.  */\n  _ISalpha = _ISbit (2),\t/* Alphabetic.  */\n  _ISdigit = _ISbit (3),\t/* Numeric.  */\n  _ISxdigit = _ISbit (4),\t/* Hexadecimal numeric.  */\n  _ISspace = _ISbit (5),\t/* Whitespace.  */\n  _ISprint = _ISbit (6),\t/* Printing.  */\n  _ISgraph = _ISbit (7),\t/* Graphical.  */\n  _ISblank = _ISbit (8),\t/* Blank (usually SPC and TAB).  */\n  _IScntrl = _ISbit (9),\t/* Control character.  */\n  _ISpunct = _ISbit (10),\t/* Punctuation.  */\n  _ISalnum = _ISbit (11)\t/* Alphanumeric.  */\n};\n#endif /* ! _ISbit  */\n\n/* These are defined in ctype-info.c.\n   The declarations here must match those in localeinfo.h.\n\n   In the thread-specific locale model (see `uselocale' in <locale.h>)\n   we cannot use global variables for these as was done in the past.\n   Instead, the following accessor functions return the address of\n   each variable, which is local to the current thread if multithreaded.\n\n   These point into arrays of 384, so they can be indexed by any `unsigned\n   char' value [0,255]; by EOF (-1); or by any `signed char' value\n   [-128,-1).  ISO C requires that the ctype functions work for `unsigned\n   char' values and for EOF; we also support negative `signed char' values\n   for broken old programs.  The case conversion arrays are of `int's\n   rather than `unsigned char's because tolower (EOF) must be EOF, which\n   doesn't fit into an `unsigned char'.  But today more important is that\n   the arrays are also used for multi-byte character sets.  */\nextern const unsigned short int **__ctype_b_loc (void)\n     __THROW __attribute__ ((__const__));\nextern const __int32_t **__ctype_tolower_loc (void)\n     __THROW __attribute__ ((__const__));\nextern const __int32_t **__ctype_toupper_loc (void)\n     __THROW __attribute__ ((__const__));\n\n\n#ifndef __cplusplus\n# define __isctype(c, type) \\\n  ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)\n#elif defined __USE_EXTERN_INLINES\n# define __isctype_f(type) \\\n  __extern_inline int\t\t\t\t\t\t\t      \\\n  is##type (int __c) __THROW\t\t\t\t\t\t      \\\n  {\t\t\t\t\t\t\t\t\t      \\\n    return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _IS##type; \\\n  }\n#endif\n\n#define\t__isascii(c)\t(((c) & ~0x7f) == 0)\t/* If C is a 7 bit value.  */\n#define\t__toascii(c)\t((c) & 0x7f)\t\t/* Mask off high bits.  */\n\n#define\t__exctype(name)\textern int name (int) __THROW\n\n/* The following names are all functions:\n     int isCHARACTERISTIC(int c);\n   which return nonzero iff C has CHARACTERISTIC.\n   For the meaning of the characteristic names, see the `enum' above.  */\n__exctype (isalnum);\n__exctype (isalpha);\n__exctype (iscntrl);\n__exctype (isdigit);\n__exctype (islower);\n__exctype (isgraph);\n__exctype (isprint);\n__exctype (ispunct);\n__exctype (isspace);\n__exctype (isupper);\n__exctype (isxdigit);\n\n\n/* Return the lowercase version of C.  */\nextern int tolower (int __c) __THROW;\n\n/* Return the uppercase version of C.  */\nextern int toupper (int __c) __THROW;\n\n\n/* ISO C99 introduced one new function.  */\n#ifdef\t__USE_ISOC99\n__exctype (isblank);\n#endif\n\n#ifdef __USE_GNU\n/* Test C for a set of character classes according to MASK.  */\nextern int isctype (int __c, int __mask) __THROW;\n#endif\n\n#if defined __USE_MISC || defined __USE_XOPEN\n\n/* Return nonzero iff C is in the ASCII set\n   (i.e., is no more than 7 bits wide).  */\nextern int isascii (int __c) __THROW;\n\n/* Return the part of C that is in the ASCII set\n   (i.e., the low-order 7 bits of C).  */\nextern int toascii (int __c) __THROW;\n\n/* These are the same as `toupper' and `tolower' except that they do not\n   check the argument for being in the range of a `char'.  */\n__exctype (_toupper);\n__exctype (_tolower);\n#endif /* Use X/Open or use misc.  */\n\n/* This code is needed for the optimized mapping functions.  */\n#define __tobody(c, f, a, args) \\\n  (__extension__\t\t\t\t\t\t\t      \\\n   ({ int __res;\t\t\t\t\t\t\t      \\\n      if (sizeof (c) > 1)\t\t\t\t\t\t      \\\n\t{\t\t\t\t\t\t\t\t      \\\n\t  if (__builtin_constant_p (c))\t\t\t\t\t      \\\n\t    {\t\t\t\t\t\t\t\t      \\\n\t      int __c = (c);\t\t\t\t\t\t      \\\n\t      __res = __c < -128 || __c > 255 ? __c : (a)[__c];\t\t      \\\n\t    }\t\t\t\t\t\t\t\t      \\\n\t  else\t\t\t\t\t\t\t\t      \\\n\t    __res = f args;\t\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n      else\t\t\t\t\t\t\t\t      \\\n\t__res = (a)[(int) (c)];\t\t\t\t\t\t      \\\n      __res; }))\n\n#if !defined __NO_CTYPE\n# ifdef __isctype_f\n__isctype_f (alnum)\n__isctype_f (alpha)\n__isctype_f (cntrl)\n__isctype_f (digit)\n__isctype_f (lower)\n__isctype_f (graph)\n__isctype_f (print)\n__isctype_f (punct)\n__isctype_f (space)\n__isctype_f (upper)\n__isctype_f (xdigit)\n#  ifdef __USE_ISOC99\n__isctype_f (blank)\n#  endif\n# elif defined __isctype\n# define isalnum(c)\t__isctype((c), _ISalnum)\n# define isalpha(c)\t__isctype((c), _ISalpha)\n# define iscntrl(c)\t__isctype((c), _IScntrl)\n# define isdigit(c)\t__isctype((c), _ISdigit)\n# define islower(c)\t__isctype((c), _ISlower)\n# define isgraph(c)\t__isctype((c), _ISgraph)\n# define isprint(c)\t__isctype((c), _ISprint)\n# define ispunct(c)\t__isctype((c), _ISpunct)\n# define isspace(c)\t__isctype((c), _ISspace)\n# define isupper(c)\t__isctype((c), _ISupper)\n# define isxdigit(c)\t__isctype((c), _ISxdigit)\n#  ifdef __USE_ISOC99\n#   define isblank(c)\t__isctype((c), _ISblank)\n#  endif\n# endif\n\n# ifdef __USE_EXTERN_INLINES\n__extern_inline int\n__NTH (tolower (int __c))\n{\n  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;\n}\n\n__extern_inline int\n__NTH (toupper (int __c))\n{\n  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;\n}\n# endif\n\n# if __GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus\n#  define tolower(c)\t__tobody (c, tolower, *__ctype_tolower_loc (), (c))\n#  define toupper(c)\t__tobody (c, toupper, *__ctype_toupper_loc (), (c))\n# endif /* Optimizing gcc */\n\n# if defined __USE_MISC || defined __USE_XOPEN\n#  define isascii(c)\t__isascii (c)\n#  define toascii(c)\t__toascii (c)\n\n#  define _tolower(c)\t((int) (*__ctype_tolower_loc ())[(int) (c)])\n#  define _toupper(c)\t((int) (*__ctype_toupper_loc ())[(int) (c)])\n# endif\n\n#endif /* Not __NO_CTYPE.  */\n\n\n#ifdef __USE_XOPEN2K8\n/* POSIX.1-2008 extended locale interface (see locale.h).  */\n# include <bits/types/locale_t.h>\n\n/* These definitions are similar to the ones above but all functions\n   take as an argument a handle for the locale which shall be used.  */\n#  define __isctype_l(c, type, locale) \\\n  ((locale)->__ctype_b[(int) (c)] & (unsigned short int) type)\n\n# define __exctype_l(name) \t\t\t\t\t\t      \\\n  extern int name (int, locale_t) __THROW\n\n/* The following names are all functions:\n     int isCHARACTERISTIC(int c, locale_t *locale);\n   which return nonzero iff C has CHARACTERISTIC.\n   For the meaning of the characteristic names, see the `enum' above.  */\n__exctype_l (isalnum_l);\n__exctype_l (isalpha_l);\n__exctype_l (iscntrl_l);\n__exctype_l (isdigit_l);\n__exctype_l (islower_l);\n__exctype_l (isgraph_l);\n__exctype_l (isprint_l);\n__exctype_l (ispunct_l);\n__exctype_l (isspace_l);\n__exctype_l (isupper_l);\n__exctype_l (isxdigit_l);\n\n__exctype_l (isblank_l);\n\n\n/* Return the lowercase version of C in locale L.  */\nextern int __tolower_l (int __c, locale_t __l) __THROW;\nextern int tolower_l (int __c, locale_t __l) __THROW;\n\n/* Return the uppercase version of C.  */\nextern int __toupper_l (int __c, locale_t __l) __THROW;\nextern int toupper_l (int __c, locale_t __l) __THROW;\n\n# if __GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus\n#  define __tolower_l(c, locale) \\\n  __tobody (c, __tolower_l, (locale)->__ctype_tolower, (c, locale))\n#  define __toupper_l(c, locale) \\\n  __tobody (c, __toupper_l, (locale)->__ctype_toupper, (c, locale))\n#  define tolower_l(c, locale)\t__tolower_l ((c), (locale))\n#  define toupper_l(c, locale)\t__toupper_l ((c), (locale))\n# endif\t/* Optimizing gcc */\n\n\n# ifndef __NO_CTYPE\n#  define __isalnum_l(c,l)\t__isctype_l((c), _ISalnum, (l))\n#  define __isalpha_l(c,l)\t__isctype_l((c), _ISalpha, (l))\n#  define __iscntrl_l(c,l)\t__isctype_l((c), _IScntrl, (l))\n#  define __isdigit_l(c,l)\t__isctype_l((c), _ISdigit, (l))\n#  define __islower_l(c,l)\t__isctype_l((c), _ISlower, (l))\n#  define __isgraph_l(c,l)\t__isctype_l((c), _ISgraph, (l))\n#  define __isprint_l(c,l)\t__isctype_l((c), _ISprint, (l))\n#  define __ispunct_l(c,l)\t__isctype_l((c), _ISpunct, (l))\n#  define __isspace_l(c,l)\t__isctype_l((c), _ISspace, (l))\n#  define __isupper_l(c,l)\t__isctype_l((c), _ISupper, (l))\n#  define __isxdigit_l(c,l)\t__isctype_l((c), _ISxdigit, (l))\n\n#  define __isblank_l(c,l)\t__isctype_l((c), _ISblank, (l))\n\n#  ifdef __USE_MISC\n#   define __isascii_l(c,l)\t((l), __isascii (c))\n#   define __toascii_l(c,l)\t((l), __toascii (c))\n#  endif\n\n#  define isalnum_l(c,l)\t__isalnum_l ((c), (l))\n#  define isalpha_l(c,l)\t__isalpha_l ((c), (l))\n#  define iscntrl_l(c,l)\t__iscntrl_l ((c), (l))\n#  define isdigit_l(c,l)\t__isdigit_l ((c), (l))\n#  define islower_l(c,l)\t__islower_l ((c), (l))\n#  define isgraph_l(c,l)\t__isgraph_l ((c), (l))\n#  define isprint_l(c,l)\t__isprint_l ((c), (l))\n#  define ispunct_l(c,l)\t__ispunct_l ((c), (l))\n#  define isspace_l(c,l)\t__isspace_l ((c), (l))\n#  define isupper_l(c,l)\t__isupper_l ((c), (l))\n#  define isxdigit_l(c,l)\t__isxdigit_l ((c), (l))\n\n#  define isblank_l(c,l)\t__isblank_l ((c), (l))\n\n#  ifdef __USE_MISC\n#   define isascii_l(c,l)\t__isascii_l ((c), (l))\n#   define toascii_l(c,l)\t__toascii_l ((c), (l))\n#  endif\n\n# endif /* Not __NO_CTYPE.  */\n\n#endif /* Use POSIX 2008.  */\n\n__END_DECLS\n\n#endif /* ctype.h  */\n"}],"crc32":1981312205,"timestamp":1704214355,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]