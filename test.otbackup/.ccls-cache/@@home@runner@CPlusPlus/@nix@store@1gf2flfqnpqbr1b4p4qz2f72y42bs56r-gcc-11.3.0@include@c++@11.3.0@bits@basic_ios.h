[{"ops":[{"insert":"// Iostreams base classes -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/basic_ios.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{ios}\n */\n\n#ifndef _BASIC_IOS_H\n#define _BASIC_IOS_H 1\n\n#pragma GCC system_header\n\n#include <bits/localefwd.h>\n#include <bits/locale_classes.h>\n#include <bits/locale_facets.h>\n#include <bits/streambuf_iterator.h>\n#include <bits/move.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template<typename _Facet>\n    inline const _Facet&\n    __check_facet(const _Facet* __f)\n    {\n      if (!__f)\n\t__throw_bad_cast();\n      return *__f;\n    }\n\n  /**\n   *  @brief Template class basic_ios, virtual base class for all\n   *  stream classes. \n   *  @ingroup io\n   *\n   *  @tparam _CharT  Type of character stream.\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *\n   *  Most of the member functions called dispatched on stream objects\n   *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.\n  */\n  template<typename _CharT, typename _Traits>\n    class basic_ios : public ios_base\n    {\n    public:\n      ///@{\n      /**\n       *  These are standard types.  They permit a standardized way of\n       *  referring to names of (or names dependent on) the template\n       *  parameters, which are specific to the implementation.\n      */\n      typedef _CharT                                 char_type;\n      typedef typename _Traits::int_type             int_type;\n      typedef typename _Traits::pos_type             pos_type;\n      typedef typename _Traits::off_type             off_type;\n      typedef _Traits                                traits_type;\n      ///@}\n\n      ///@{\n      /**\n       *  These are non-standard types.\n      */\n      typedef ctype<_CharT>                          __ctype_type;\n      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >\n\t\t\t\t\t\t     __num_put_type;\n      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >\n\t\t\t\t\t\t     __num_get_type;\n      ///@}\n\n      // Data members:\n    protected:\n      basic_ostream<_CharT, _Traits>*                _M_tie;\n      mutable char_type                              _M_fill;\n      mutable bool                                   _M_fill_init;\n      basic_streambuf<_CharT, _Traits>*              _M_streambuf;\n\n      // Cached use_facet<ctype>, which is based on the current locale info.\n      const __ctype_type*                            _M_ctype;\n      // For ostream.\n      const __num_put_type*                          _M_num_put;\n      // For istream.\n      const __num_get_type*                          _M_num_get;\n\n    public:\n      ///@{\n      /**\n       *  @brief  The quick-and-easy status check.\n       *\n       *  This allows you to write constructs such as\n       *  <code>if (!a_stream) ...</code> and <code>while (a_stream) ...</code>\n      */\n#if __cplusplus >= 201103L\n      explicit operator bool() const\n      { return !this->fail(); }\n#else\n      operator void*() const\n      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }\n#endif\n\n      bool\n      operator!() const\n      { return this->fail(); }\n      ///@}\n\n      /**\n       *  @brief  Returns the error state of the stream buffer.\n       *  @return  A bit pattern (well, isn't everything?)\n       *\n       *  See std::ios_base::iostate for the possible bit values.  Most\n       *  users will call one of the interpreting wrappers, e.g., good().\n      */\n      iostate\n      rdstate() const\n      { return _M_streambuf_state; }\n\n      /**\n       *  @brief  [Re]sets the error state.\n       *  @param  __state  The new state flag(s) to set.\n       *\n       *  See std::ios_base::iostate for the possible bit values.  Most\n       *  users will not need to pass an argument.\n      */\n      void\n      clear(iostate __state = goodbit);\n\n      /**\n       *  @brief  Sets additional flags in the error state.\n       *  @param  __state  The additional state flag(s) to set.\n       *\n       *  See std::ios_base::iostate for the possible bit values.\n      */\n      void\n      setstate(iostate __state)\n      { this->clear(this->rdstate() | __state); }\n\n      // Flip the internal state on for the proper state bits, then\n      // rethrows the propagated exception if bit also set in\n      // exceptions().\n      void\n      _M_setstate(iostate __state)\n      {\n\t// 27.6.1.2.1 Common requirements.\n\t// Turn this on without causing an ios::failure to be thrown.\n\t_M_streambuf_state |= __state;\n\tif (this->exceptions() & __state)\n\t  __throw_exception_again;\n      }\n\n      /**\n       *  @brief  Fast error checking.\n       *  @return  True if no error flags are set.\n       *\n       *  A wrapper around rdstate.\n      */\n      bool\n      good() const\n      { return this->rdstate() == 0; }\n\n      /**\n       *  @brief  Fast error checking.\n       *  @return  True if the eofbit is set.\n       *\n       *  Note that other iostate flags may also be set.\n      */\n      bool\n      eof() const\n      { return (this->rdstate() & eofbit) != 0; }\n\n      /**\n       *  @brief  Fast error checking.\n       *  @return  True if either the badbit or the failbit is set.\n       *\n       *  Checking the badbit in fail() is historical practice.\n       *  Note that other iostate flags may also be set.\n      */\n      bool\n      fail() const\n      { return (this->rdstate() & (badbit | failbit)) != 0; }\n\n      /**\n       *  @brief  Fast error checking.\n       *  @return  True if the badbit is set.\n       *\n       *  Note that other iostate flags may also be set.\n      */\n      bool\n      bad() const\n      { return (this->rdstate() & badbit) != 0; }\n\n      /**\n       *  @brief  Throwing exceptions on errors.\n       *  @return  The current exceptions mask.\n       *\n       *  This changes nothing in the stream.  See the one-argument version\n       *  of exceptions(iostate) for the meaning of the return value.\n      */\n      iostate\n      exceptions() const\n      { return _M_exception; }\n\n      /**\n       *  @brief  Throwing exceptions on errors.\n       *  @param  __except  The new exceptions mask.\n       *\n       *  By default, error flags are set silently.  You can set an\n       *  exceptions mask for each stream; if a bit in the mask becomes set\n       *  in the error flags, then an exception of type\n       *  std::ios_base::failure is thrown.\n       *\n       *  If the error flag is already set when the exceptions mask is\n       *  added, the exception is immediately thrown.  Try running the\n       *  following under GCC 3.1 or later:\n       *  @code\n       *  #include <iostream>\n       *  #include <fstream>\n       *  #include <exception>\n       *\n       *  int main()\n       *  {\n       *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);\n       *\n       *      std::ifstream f (\"/etc/motd\");\n       *\n       *      std::cerr << \"Setting badbit\\n\";\n       *      f.setstate (std::ios_base::badbit);\n       *\n       *      std::cerr << \"Setting exception mask\\n\";\n       *      f.exceptions (std::ios_base::badbit);\n       *  }\n       *  @endcode\n      */\n      void\n      exceptions(iostate __except)\n      {\n        _M_exception = __except;\n        this->clear(_M_streambuf_state);\n      }\n\n      // Constructor/destructor:\n      /**\n       *  @brief  Constructor performs initialization.\n       *\n       *  The parameter is passed by derived streams.\n      */\n      explicit\n      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)\n      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),\n\t_M_ctype(0), _M_num_put(0), _M_num_get(0)\n      { this->init(__sb); }\n\n      /**\n       *  @brief  Empty.\n       *\n       *  The destructor does nothing.  More specifically, it does not\n       *  destroy the streambuf held by rdbuf().\n      */\n      virtual\n      ~basic_ios() { }\n\n      // Members:\n      /**\n       *  @brief  Fetches the current @e tied stream.\n       *  @return  A pointer to the tied stream, or NULL if the stream is\n       *           not tied.\n       *\n       *  A stream may be @e tied (or synchronized) to a second output\n       *  stream.  When this stream performs any I/O, the tied stream is\n       *  first flushed.  For example, @c std::cin is tied to @c std::cout.\n      */\n      basic_ostream<_CharT, _Traits>*\n      tie() const\n      { return _M_tie; }\n\n      /**\n       *  @brief  Ties this stream to an output stream.\n       *  @param  __tiestr  The output stream.\n       *  @return  The previously tied output stream, or NULL if the stream\n       *           was not tied.\n       *\n       *  This sets up a new tie; see tie() for more.\n      */\n      basic_ostream<_CharT, _Traits>*\n      tie(basic_ostream<_CharT, _Traits>* __tiestr)\n      {\n        basic_ostream<_CharT, _Traits>* __old = _M_tie;\n        _M_tie = __tiestr;\n        return __old;\n      }\n\n      /**\n       *  @brief  Accessing the underlying buffer.\n       *  @return  The current stream buffer.\n       *\n       *  This does not change the state of the stream.\n      */\n      basic_streambuf<_CharT, _Traits>*\n      rdbuf() const\n      { return _M_streambuf; }\n\n      /**\n       *  @brief  Changing the underlying buffer.\n       *  @param  __sb  The new stream buffer.\n       *  @return  The previous stream buffer.\n       *\n       *  Associates a new buffer with the current stream, and clears the\n       *  error state.\n       *\n       *  Due to historical accidents which the LWG refuses to correct, the\n       *  I/O library suffers from a design error:  this function is hidden\n       *  in derived classes by overrides of the zero-argument @c rdbuf(),\n       *  which is non-virtual for hysterical raisins.  As a result, you\n       *  must use explicit qualifications to access this function via any\n       *  derived class.  For example:\n       *\n       *  @code\n       *  std::fstream     foo;         // or some other derived type\n       *  std::streambuf*  p = .....;\n       *\n       *  foo.ios::rdbuf(p);            // ios == basic_ios<char>\n       *  @endcode\n      */\n      basic_streambuf<_CharT, _Traits>*\n      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);\n\n      /**\n       *  @brief  Copies fields of __rhs into this.\n       *  @param  __rhs  The source values for the copies.\n       *  @return  Reference to this object.\n       *\n       *  All fields of __rhs are copied into this object except that rdbuf()\n       *  and rdstate() remain unchanged.  All values in the pword and iword\n       *  arrays are copied.  Before copying, each callback is invoked with\n       *  erase_event.  After copying, each (new) callback is invoked with\n       *  copyfmt_event.  The final step is to copy exceptions().\n      */\n      basic_ios&\n      copyfmt(const basic_ios& __rhs);\n\n      /**\n       *  @brief  Retrieves the @a empty character.\n       *  @return  The current fill character.\n       *\n       *  It defaults to a space (' ') in the current locale.\n      */\n      char_type\n      fill() const\n      {\n\tif (!_M_fill_init)\n\t  {\n\t    _M_fill = this->widen(' ');\n\t    _M_fill_init = true;\n\t  }\n\treturn _M_fill;\n      }\n\n      /**\n       *  @brief  Sets a new @a empty character.\n       *  @param  __ch  The new character.\n       *  @return  The previous fill character.\n       *\n       *  The fill character is used to fill out space when P+ characters\n       *  have been requested (e.g., via setw), Q characters are actually\n       *  used, and Q<P.  It defaults to a space (' ') in the current locale.\n      */\n      char_type\n      fill(char_type __ch)\n      {\n\tchar_type __old = this->fill();\n\t_M_fill = __ch;\n\treturn __old;\n      }\n\n      // Locales:\n      /**\n       *  @brief  Moves to a new locale.\n       *  @param  __loc  The new locale.\n       *  @return  The previous locale.\n       *\n       *  Calls @c ios_base::imbue(loc), and if a stream buffer is associated\n       *  with this stream, calls that buffer's @c pubimbue(loc).\n       *\n       *  Additional l10n notes are at\n       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html\n      */\n      locale\n      imbue(const locale& __loc);\n\n      /**\n       *  @brief  Squeezes characters.\n       *  @param  __c  The character to narrow.\n       *  @param  __dfault  The character to narrow.\n       *  @return  The narrowed character.\n       *\n       *  Maps a character of @c char_type to a character of @c char,\n       *  if possible.\n       *\n       *  Returns the result of\n       *  @code\n       *    std::use_facet<ctype<char_type> >(getloc()).narrow(c,dfault)\n       *  @endcode\n       *\n       *  Additional l10n notes are at\n       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html\n      */\n      char\n      narrow(char_type __c, char __dfault) const\n      { return __check_facet(_M_ctype).narrow(__c, __dfault); }\n\n      /**\n       *  @brief  Widens characters.\n       *  @param  __c  The character to widen.\n       *  @return  The widened character.\n       *\n       *  Maps a character of @c char to a character of @c char_type.\n       *\n       *  Returns the result of\n       *  @code\n       *    std::use_facet<ctype<char_type> >(getloc()).widen(c)\n       *  @endcode\n       *\n       *  Additional l10n notes are at\n       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html\n      */\n      char_type\n      widen(char __c) const\n      { return __check_facet(_M_ctype).widen(__c); }\n\n    protected:\n      // 27.4.5.1  basic_ios constructors\n      /**\n       *  @brief  Empty.\n       *\n       *  The default constructor does nothing and is not normally\n       *  accessible to users.\n      */\n      basic_ios()\n      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), \n\t_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)\n      { }\n\n      /**\n       *  @brief  All setup is performed here.\n       *\n       *  This is called from the public constructor.  It is not virtual and\n       *  cannot be redefined.\n      */\n      void\n      init(basic_streambuf<_CharT, _Traits>* __sb);\n\n#if __cplusplus >= 201103L\n      basic_ios(const basic_ios&) = delete;\n      basic_ios& operator=(const basic_ios&) = delete;\n\n      void\n      move(basic_ios& __rhs)\n      {\n\tios_base::_M_move(__rhs);\n\t_M_cache_locale(_M_ios_locale);\n\tthis->tie(__rhs.tie(nullptr));\n\t_M_fill = __rhs._M_fill;\n\t_M_fill_init = __rhs._M_fill_init;\n\t_M_streambuf = nullptr;\n      }\n\n      void\n      move(basic_ios&& __rhs)\n      { this->move(__rhs); }\n\n      void\n      swap(basic_ios& __rhs) noexcept\n      {\n\tios_base::_M_swap(__rhs);\n\t_M_cache_locale(_M_ios_locale);\n\t__rhs._M_cache_locale(__rhs._M_ios_locale);\n\tstd::swap(_M_tie, __rhs._M_tie);\n\tstd::swap(_M_fill, __rhs._M_fill);\n\tstd::swap(_M_fill_init, __rhs._M_fill_init);\n      }\n\n      void\n      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)\n      { _M_streambuf = __sb; }\n#endif\n\n      void\n      _M_cache_locale(const locale& __loc);\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#include <bits/basic_ios.tcc>\n\n#endif /* _BASIC_IOS_H */\n"}],"crc32":2891631377,"timestamp":1702397466,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]