[{"ops":[{"insert":"// Character Traits for use by standard string and iostream -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/char_traits.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{string}\n */\n\n//\n// ISO C++ 14882: 21  Strings library\n//\n\n#ifndef _CHAR_TRAITS_H\n#define _CHAR_TRAITS_H 1\n\n#pragma GCC system_header\n\n#include <bits/stl_algobase.h>  // std::copy, std::fill_n\n#include <bits/postypes.h>      // For streampos\n#include <cwchar>               // For WEOF, wmemmove, wmemset, etc.\n#if __cplusplus > 201703L\n# include <compare>\n#endif\n\n#ifndef _GLIBCXX_ALWAYS_INLINE\n# define _GLIBCXX_ALWAYS_INLINE inline __attribute__((__always_inline__))\n#endif\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @brief  Mapping from character type to associated types.\n   *\n   *  @note This is an implementation class for the generic version\n   *  of char_traits.  It defines int_type, off_type, pos_type, and\n   *  state_type.  By default these are unsigned long, streamoff,\n   *  streampos, and mbstate_t.  Users who need a different set of\n   *  types, but who don't need to change the definitions of any function\n   *  defined in char_traits, can specialize __gnu_cxx::_Char_types\n   *  while leaving __gnu_cxx::char_traits alone. */\n  template<typename _CharT>\n    struct _Char_types\n    {\n      typedef unsigned long   int_type;\n      typedef std::streampos  pos_type;\n      typedef std::streamoff  off_type;\n      typedef std::mbstate_t  state_type;\n    };\n\n\n  /**\n   *  @brief  Base class used to implement std::char_traits.\n   *\n   *  @note For any given actual character type, this definition is\n   *  probably wrong.  (Most of the member functions are likely to be\n   *  right, but the int_type and state_type typedefs, and the eof()\n   *  member function, are likely to be wrong.)  The reason this class\n   *  exists is so users can specialize it.  Classes in namespace std\n   *  may not be specialized for fundamental types, but classes in\n   *  namespace __gnu_cxx may be.\n   *\n   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types\n   *  for advice on how to make use of this class for @a unusual character\n   *  types. Also, check out include/ext/pod_char_traits.h.  \n   */\n  template<typename _CharT>\n    struct char_traits\n    {\n      typedef _CharT                                    char_type;\n      typedef typename _Char_types<_CharT>::int_type    int_type;\n      typedef typename _Char_types<_CharT>::pos_type    pos_type;\n      typedef typename _Char_types<_CharT>::off_type    off_type;\n      typedef typename _Char_types<_CharT>::state_type  state_type;\n#if __cpp_lib_three_way_comparison\n      using comparison_category = std::strong_ordering;\n#endif\n\n      static _GLIBCXX14_CONSTEXPR void\n      assign(char_type& __c1, const char_type& __c2)\n      { __c1 = __c2; }\n\n      static _GLIBCXX_CONSTEXPR bool\n      eq(const char_type& __c1, const char_type& __c2)\n      { return __c1 == __c2; }\n\n      static _GLIBCXX_CONSTEXPR bool\n      lt(const char_type& __c1, const char_type& __c2)\n      { return __c1 < __c2; }\n\n      static _GLIBCXX14_CONSTEXPR int\n      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);\n\n      static _GLIBCXX14_CONSTEXPR std::size_t\n      length(const char_type* __s);\n\n      static _GLIBCXX14_CONSTEXPR const char_type*\n      find(const char_type* __s, std::size_t __n, const char_type& __a);\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      move(char_type* __s1, const char_type* __s2, std::size_t __n);\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      copy(char_type* __s1, const char_type* __s2, std::size_t __n);\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      assign(char_type* __s, std::size_t __n, char_type __a);\n\n      static _GLIBCXX_CONSTEXPR char_type\n      to_char_type(const int_type& __c)\n      { return static_cast<char_type>(__c); }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      to_int_type(const char_type& __c)\n      { return static_cast<int_type>(__c); }\n\n      static _GLIBCXX_CONSTEXPR bool\n      eq_int_type(const int_type& __c1, const int_type& __c2)\n      { return __c1 == __c2; }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      eof()\n      { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      not_eof(const int_type& __c)\n      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }\n    };\n\n  template<typename _CharT>\n    _GLIBCXX14_CONSTEXPR int\n    char_traits<_CharT>::\n    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)\n    {\n      for (std::size_t __i = 0; __i < __n; ++__i)\n\tif (lt(__s1[__i], __s2[__i]))\n\t  return -1;\n\telse if (lt(__s2[__i], __s1[__i]))\n\t  return 1;\n      return 0;\n    }\n\n  template<typename _CharT>\n    _GLIBCXX14_CONSTEXPR std::size_t\n    char_traits<_CharT>::\n    length(const char_type* __p)\n    {\n      std::size_t __i = 0;\n      while (!eq(__p[__i], char_type()))\n        ++__i;\n      return __i;\n    }\n\n  template<typename _CharT>\n    _GLIBCXX14_CONSTEXPR const typename char_traits<_CharT>::char_type*\n    char_traits<_CharT>::\n    find(const char_type* __s, std::size_t __n, const char_type& __a)\n    {\n      for (std::size_t __i = 0; __i < __n; ++__i)\n        if (eq(__s[__i], __a))\n          return __s + __i;\n      return 0;\n    }\n\n  template<typename _CharT>\n    _GLIBCXX20_CONSTEXPR\n    typename char_traits<_CharT>::char_type*\n    char_traits<_CharT>::\n    move(char_type* __s1, const char_type* __s2, std::size_t __n)\n    {\n      if (__n == 0)\n\treturn __s1;\n#if __cpp_lib_is_constant_evaluated\n      if (std::is_constant_evaluated())\n\t{\n\t  if (__s1 == __s2) // unlikely, but saves a lot of work\n\t    return __s1;\n#if __cpp_constexpr_dynamic_alloc\n\t  // The overlap detection below fails due to PR c++/89074,\n\t  // so use a temporary buffer instead.\n\t  char_type* __tmp = new char_type[__n];\n\t  copy(__tmp, __s2, __n);\n\t  copy(__s1, __tmp, __n);\n\t  delete[] __tmp;\n#else\n\t  const auto __end = __s2 + __n - 1;\n\t  bool __overlap = false;\n\t  for (std::size_t __i = 0; __i < __n - 1; ++__i)\n\t    {\n\t      if (__s1 + __i == __end)\n\t\t{\n\t\t  __overlap = true;\n\t\t  break;\n\t\t}\n\t    }\n\t  if (__overlap)\n\t    {\n\t      do\n\t\t{\n\t\t  --__n;\n\t\t  assign(__s1[__n], __s2[__n]);\n\t\t}\n\t      while (__n > 0);\n\t    }\n\t  else\n\t    copy(__s1, __s2, __n);\n#endif\n\t  return __s1;\n\t}\n#endif\n      __builtin_memmove(__s1, __s2, __n * sizeof(char_type));\n      return __s1;\n    }\n\n  template<typename _CharT>\n    _GLIBCXX20_CONSTEXPR\n    typename char_traits<_CharT>::char_type*\n    char_traits<_CharT>::\n    copy(char_type* __s1, const char_type* __s2, std::size_t __n)\n    {\n      // NB: Inline std::copy so no recursive dependencies.\n      std::copy(__s2, __s2 + __n, __s1);\n      return __s1;\n    }\n\n  template<typename _CharT>\n    _GLIBCXX20_CONSTEXPR\n    typename char_traits<_CharT>::char_type*\n    char_traits<_CharT>::\n    assign(char_type* __s, std::size_t __n, char_type __a)\n    {\n      // NB: Inline std::fill_n so no recursive dependencies.\n      std::fill_n(__s, __n, __a);\n      return __s;\n    }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus >= 201703L\n\n#ifdef __cpp_lib_is_constant_evaluated\n// Unofficial macro indicating P1032R1 support in C++20\n# define __cpp_lib_constexpr_char_traits 201811L\n#else\n// Unofficial macro indicating P0426R1 support in C++17\n# define __cpp_lib_constexpr_char_traits 201611L\n#endif\n\n  /**\n   *  @brief Determine whether the characters of a NULL-terminated\n   *  string are known at compile time.\n   *  @param  __s  The string.\n   *\n   *  Assumes that _CharT is a built-in character type.\n   */\n  template<typename _CharT>\n    _GLIBCXX_ALWAYS_INLINE constexpr bool\n    __constant_string_p(const _CharT* __s)\n    {\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED\n      (void) __s;\n      // In constexpr contexts all strings should be constant.\n      return __builtin_is_constant_evaluated();\n#else\n      while (__builtin_constant_p(*__s) && *__s)\n\t__s++;\n      return __builtin_constant_p(*__s);\n#endif\n    }\n\n  /**\n   *  @brief Determine whether the characters of a character array are\n   *  known at compile time.\n   *  @param  __a  The character array.\n   *  @param  __n  Number of characters.\n   *\n   *  Assumes that _CharT is a built-in character type.\n   */\n  template<typename _CharT>\n    _GLIBCXX_ALWAYS_INLINE constexpr bool\n    __constant_char_array_p(const _CharT* __a, size_t __n)\n    {\n#ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED\n      (void) __a;\n      (void) __n;\n      // In constexpr contexts all character arrays should be constant.\n      return __builtin_is_constant_evaluated();\n#else\n      size_t __i = 0;\n      while (__i < __n && __builtin_constant_p(__a[__i]))\n\t__i++;\n      return __i == __n;\n#endif\n    }\n#endif\n\n  // 21.1\n  /**\n   *  @brief  Basis for explicit traits specializations.\n   *\n   *  @note  For any given actual character type, this definition is\n   *  probably wrong.  Since this is just a thin wrapper around\n   *  __gnu_cxx::char_traits, it is possible to achieve a more\n   *  appropriate definition by specializing __gnu_cxx::char_traits.\n   *\n   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types\n   *  for advice on how to make use of this class for @a unusual character\n   *  types. Also, check out include/ext/pod_char_traits.h.\n  */\n  template<class _CharT>\n    struct char_traits : public __gnu_cxx::char_traits<_CharT>\n    { };\n\n\n  /// 21.1.3.1  char_traits specializations\n  template<>\n    struct char_traits<char>\n    {\n      typedef char              char_type;\n      typedef int               int_type;\n      typedef streampos         pos_type;\n      typedef streamoff         off_type;\n      typedef mbstate_t         state_type;\n#if __cpp_lib_three_way_comparison\n      using comparison_category = strong_ordering;\n#endif\n\n      static _GLIBCXX17_CONSTEXPR void\n      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      { __c1 = __c2; }\n\n      static _GLIBCXX_CONSTEXPR bool\n      eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      { return __c1 == __c2; }\n\n      static _GLIBCXX_CONSTEXPR bool\n      lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      {\n\t// LWG 467.\n\treturn (static_cast<unsigned char>(__c1)\n\t\t< static_cast<unsigned char>(__c2));\n      }\n\n      static _GLIBCXX17_CONSTEXPR int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return 0;\n#if __cplusplus >= 201703L\n\tif (__builtin_constant_p(__n)\n\t    && __constant_char_array_p(__s1, __n)\n\t    && __constant_char_array_p(__s2, __n))\n\t  {\n\t    for (size_t __i = 0; __i < __n; ++__i)\n\t      if (lt(__s1[__i], __s2[__i]))\n\t\treturn -1;\n\t      else if (lt(__s2[__i], __s1[__i]))\n\t\treturn 1;\n\t    return 0;\n\t  }\n#endif\n\treturn __builtin_memcmp(__s1, __s2, __n);\n      }\n\n      static _GLIBCXX17_CONSTEXPR size_t\n      length(const char_type* __s)\n      {\n#if __cplusplus >= 201703L\n\tif (__constant_string_p(__s))\n\t  return __gnu_cxx::char_traits<char_type>::length(__s);\n#endif\n\treturn __builtin_strlen(__s);\n      }\n\n      static _GLIBCXX17_CONSTEXPR const char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n\tif (__n == 0)\n\t  return 0;\n#if __cplusplus >= 201703L\n\tif (__builtin_constant_p(__n)\n\t    && __builtin_constant_p(__a)\n\t    && __constant_char_array_p(__s, __n))\n\t  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);\n#endif\n\treturn static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      move(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);\n#endif\n\treturn static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      copy(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);\n#endif\n\treturn static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      assign(char_type* __s, size_t __n, char_type __a)\n      {\n\tif (__n == 0)\n\t  return __s;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);\n#endif\n\treturn static_cast<char_type*>(__builtin_memset(__s, __a, __n));\n      }\n\n      static _GLIBCXX_CONSTEXPR char_type\n      to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT\n      { return static_cast<char_type>(__c); }\n\n      // To keep both the byte 0xff and the eof symbol 0xffffffff\n      // from ending up as 0xffffffff.\n      static _GLIBCXX_CONSTEXPR int_type\n      to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT\n      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }\n\n      static _GLIBCXX_CONSTEXPR bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT\n      { return __c1 == __c2; }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      eof() _GLIBCXX_NOEXCEPT\n      { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT\n      { return (__c == eof()) ? 0 : __c; }\n  };\n\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  /// 21.1.3.2  char_traits specializations\n  template<>\n    struct char_traits<wchar_t>\n    {\n      typedef wchar_t           char_type;\n      typedef wint_t            int_type;\n      typedef streamoff         off_type;\n      typedef wstreampos        pos_type;\n      typedef mbstate_t         state_type;\n#if __cpp_lib_three_way_comparison\n      using comparison_category = strong_ordering;\n#endif\n\n      static _GLIBCXX17_CONSTEXPR void\n      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      { __c1 = __c2; }\n\n      static _GLIBCXX_CONSTEXPR bool\n      eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      { return __c1 == __c2; }\n\n      static _GLIBCXX_CONSTEXPR bool\n      lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      { return __c1 < __c2; }\n\n      static _GLIBCXX17_CONSTEXPR int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return 0;\n#if __cplusplus >= 201703L\n\tif (__builtin_constant_p(__n)\n\t    && __constant_char_array_p(__s1, __n)\n\t    && __constant_char_array_p(__s2, __n))\n\t  return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);\n#endif\n\treturn wmemcmp(__s1, __s2, __n);\n      }\n\n      static _GLIBCXX17_CONSTEXPR size_t\n      length(const char_type* __s)\n      {\n#if __cplusplus >= 201703L\n\tif (__constant_string_p(__s))\n\t  return __gnu_cxx::char_traits<char_type>::length(__s);\n#endif\n\treturn wcslen(__s);\n      }\n\n      static _GLIBCXX17_CONSTEXPR const char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n\tif (__n == 0)\n\t  return 0;\n#if __cplusplus >= 201703L\n\tif (__builtin_constant_p(__n)\n\t    && __builtin_constant_p(__a)\n\t    && __constant_char_array_p(__s, __n))\n\t  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);\n#endif\n\treturn wmemchr(__s, __a, __n);\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      move(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);\n#endif\n\treturn wmemmove(__s1, __s2, __n);\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      copy(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);\n#endif\n\treturn wmemcpy(__s1, __s2, __n);\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      assign(char_type* __s, size_t __n, char_type __a)\n      {\n\tif (__n == 0)\n\t  return __s;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);\n#endif\n\treturn wmemset(__s, __a, __n);\n      }\n\n      static _GLIBCXX_CONSTEXPR char_type\n      to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT\n      { return char_type(__c); }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT\n      { return int_type(__c); }\n\n      static _GLIBCXX_CONSTEXPR bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT\n      { return __c1 == __c2; }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      eof() _GLIBCXX_NOEXCEPT\n      { return static_cast<int_type>(WEOF); }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT\n      { return eq_int_type(__c, eof()) ? 0 : __c; }\n  };\n#endif //_GLIBCXX_USE_WCHAR_T\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template<>\n    struct char_traits<char8_t>\n    {\n      typedef char8_t           char_type;\n      typedef unsigned int      int_type;\n      typedef u8streampos       pos_type;\n      typedef streamoff         off_type;\n      typedef mbstate_t         state_type;\n#if __cpp_lib_three_way_comparison\n      using comparison_category = strong_ordering;\n#endif\n\n      static _GLIBCXX17_CONSTEXPR void\n      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      { __c1 = __c2; }\n\n      static _GLIBCXX_CONSTEXPR bool\n      eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      { return __c1 == __c2; }\n\n      static _GLIBCXX_CONSTEXPR bool\n      lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT\n      { return __c1 < __c2; }\n\n      static _GLIBCXX17_CONSTEXPR int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return 0;\n#if __cplusplus > 201402\n\tif (__builtin_constant_p(__n)\n\t    && __constant_char_array_p(__s1, __n)\n\t    && __constant_char_array_p(__s2, __n))\n\t  return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);\n#endif\n\treturn __builtin_memcmp(__s1, __s2, __n);\n      }\n\n      static _GLIBCXX17_CONSTEXPR size_t\n      length(const char_type* __s)\n      {\n#if __cplusplus > 201402\n\tif (__constant_string_p(__s))\n\t  return __gnu_cxx::char_traits<char_type>::length(__s);\n#endif\n\tsize_t __i = 0;\n\twhile (!eq(__s[__i], char_type()))\n\t  ++__i;\n\treturn __i;\n      }\n\n      static _GLIBCXX17_CONSTEXPR const char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n\tif (__n == 0)\n\t  return 0;\n#if __cplusplus > 201402\n\tif (__builtin_constant_p(__n)\n\t    && __builtin_constant_p(__a)\n\t    && __constant_char_array_p(__s, __n))\n\t  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);\n#endif\n\treturn static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      move(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);\n#endif\n\treturn static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      copy(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);\n#endif\n\treturn static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      assign(char_type* __s, size_t __n, char_type __a)\n      {\n\tif (__n == 0)\n\t  return __s;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);\n#endif\n\treturn static_cast<char_type*>(__builtin_memset(__s, __a, __n));\n      }\n\n      static _GLIBCXX_CONSTEXPR char_type\n      to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT\n      { return char_type(__c); }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT\n      { return int_type(__c); }\n\n      static _GLIBCXX_CONSTEXPR bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT\n      { return __c1 == __c2; }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      eof() _GLIBCXX_NOEXCEPT\n      { return static_cast<int_type>(-1); }\n\n      static _GLIBCXX_CONSTEXPR int_type\n      not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT\n      { return eq_int_type(__c, eof()) ? 0 : __c; }\n    };\n#endif //_GLIBCXX_USE_CHAR8_T\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#if __cplusplus >= 201103L\n\n#include <cstdint>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template<>\n    struct char_traits<char16_t>\n    {\n      typedef char16_t          char_type;\n#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n      typedef uint_least16_t    int_type;\n#elif defined __UINT_LEAST16_TYPE__\n      typedef __UINT_LEAST16_TYPE__\t    int_type;\n#else\n      typedef make_unsigned<char16_t>::type int_type;\n#endif\n      typedef streamoff         off_type;\n      typedef u16streampos      pos_type;\n      typedef mbstate_t         state_type;\n#if __cpp_lib_three_way_comparison\n      using comparison_category = strong_ordering;\n#endif\n\n      static _GLIBCXX17_CONSTEXPR void\n      assign(char_type& __c1, const char_type& __c2) noexcept\n      { __c1 = __c2; }\n\n      static constexpr bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 < __c2; }\n\n      static _GLIBCXX17_CONSTEXPR int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tfor (size_t __i = 0; __i < __n; ++__i)\n\t  if (lt(__s1[__i], __s2[__i]))\n\t    return -1;\n\t  else if (lt(__s2[__i], __s1[__i]))\n\t    return 1;\n\treturn 0;\n      }\n\n      static _GLIBCXX17_CONSTEXPR size_t\n      length(const char_type* __s)\n      {\n\tsize_t __i = 0;\n\twhile (!eq(__s[__i], char_type()))\n\t  ++__i;\n\treturn __i;\n      }\n\n      static _GLIBCXX17_CONSTEXPR const char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n\tfor (size_t __i = 0; __i < __n; ++__i)\n\t  if (eq(__s[__i], __a))\n\t    return __s + __i;\n\treturn 0;\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      move(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);\n#endif\n\treturn (static_cast<char_type*>\n\t\t(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      copy(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);\n#endif\n\treturn (static_cast<char_type*>\n\t\t(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      assign(char_type* __s, size_t __n, char_type __a)\n      {\n\tfor (size_t __i = 0; __i < __n; ++__i)\n\t  assign(__s[__i], __a);\n\treturn __s;\n      }\n\n      static constexpr char_type\n      to_char_type(const int_type& __c) noexcept\n      { return char_type(__c); }\n\n      static constexpr int_type\n      to_int_type(const char_type& __c) noexcept\n      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }\n\n      static constexpr bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr int_type\n      eof() noexcept\n      { return static_cast<int_type>(-1); }\n\n      static constexpr int_type\n      not_eof(const int_type& __c) noexcept\n      { return eq_int_type(__c, eof()) ? 0 : __c; }\n    };\n\n  template<>\n    struct char_traits<char32_t>\n    {\n      typedef char32_t          char_type;\n#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n      typedef uint_least32_t    int_type;\n#elif defined __UINT_LEAST32_TYPE__\n      typedef __UINT_LEAST32_TYPE__\t    int_type;\n#else\n      typedef make_unsigned<char32_t>::type int_type;\n#endif\n      typedef streamoff         off_type;\n      typedef u32streampos      pos_type;\n      typedef mbstate_t         state_type;\n#if __cpp_lib_three_way_comparison\n      using comparison_category = strong_ordering;\n#endif\n\n      static _GLIBCXX17_CONSTEXPR void\n      assign(char_type& __c1, const char_type& __c2) noexcept\n      { __c1 = __c2; }\n\n      static constexpr bool\n      eq(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr bool\n      lt(const char_type& __c1, const char_type& __c2) noexcept\n      { return __c1 < __c2; }\n\n      static _GLIBCXX17_CONSTEXPR int\n      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tfor (size_t __i = 0; __i < __n; ++__i)\n\t  if (lt(__s1[__i], __s2[__i]))\n\t    return -1;\n\t  else if (lt(__s2[__i], __s1[__i]))\n\t    return 1;\n\treturn 0;\n      }\n\n      static _GLIBCXX17_CONSTEXPR size_t\n      length(const char_type* __s)\n      {\n\tsize_t __i = 0;\n\twhile (!eq(__s[__i], char_type()))\n\t  ++__i;\n\treturn __i;\n      }\n\n      static _GLIBCXX17_CONSTEXPR const char_type*\n      find(const char_type* __s, size_t __n, const char_type& __a)\n      {\n\tfor (size_t __i = 0; __i < __n; ++__i)\n\t  if (eq(__s[__i], __a))\n\t    return __s + __i;\n\treturn 0;\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      move(char_type* __s1, const char_type* __s2, size_t __n)\n      {\n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);\n#endif\n\treturn (static_cast<char_type*>\n\t\t(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      copy(char_type* __s1, const char_type* __s2, size_t __n)\n      { \n\tif (__n == 0)\n\t  return __s1;\n#ifdef __cpp_lib_is_constant_evaluated\n\tif (std::is_constant_evaluated())\n\t  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);\n#endif\n\treturn (static_cast<char_type*>\n\t\t(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));\n      }\n\n      static _GLIBCXX20_CONSTEXPR char_type*\n      assign(char_type* __s, size_t __n, char_type __a)\n      {\n\tfor (size_t __i = 0; __i < __n; ++__i)\n\t  assign(__s[__i], __a);\n\treturn __s;\n      }\n\n      static constexpr char_type\n      to_char_type(const int_type& __c) noexcept\n      { return char_type(__c); }\n\n      static constexpr int_type\n      to_int_type(const char_type& __c) noexcept\n      { return int_type(__c); }\n\n      static constexpr bool\n      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept\n      { return __c1 == __c2; }\n\n      static constexpr int_type\n      eof() noexcept\n      { return static_cast<int_type>(-1); }\n\n      static constexpr int_type\n      not_eof(const int_type& __c) noexcept\n      { return eq_int_type(__c, eof()) ? 0 : __c; }\n    };\n\n#if __cpp_lib_three_way_comparison\n  namespace __detail\n  {\n    template<typename _ChTraits>\n      constexpr auto\n      __char_traits_cmp_cat(int __cmp) noexcept\n      {\n\tif constexpr (requires { typename _ChTraits::comparison_category; })\n\t  {\n\t    using _Cat = typename _ChTraits::comparison_category;\n\t    static_assert( !is_void_v<common_comparison_category_t<_Cat>> );\n\t    return static_cast<_Cat>(__cmp <=> 0);\n\t  }\n\telse\n\t  return static_cast<weak_ordering>(__cmp <=> 0);\n      }\n  } // namespace __detail\n#endif // C++20\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif  // C++11\n\n#endif // _CHAR_TRAITS_H\n"}],"crc32":1350196223,"timestamp":1702397466,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]