[{"ops":[{"insert":"// Components for manipulating sequences of characters -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/basic_string.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{string}\n */\n\n//\n// ISO C++ 14882: 21 Strings library\n//\n\n#ifndef _BASIC_STRING_H\n#define _BASIC_STRING_H 1\n\n#pragma GCC system_header\n\n#include <ext/atomicity.h>\n#include <ext/alloc_traits.h>\n#include <debug/debug.h>\n\n#if __cplusplus >= 201103L\n#include <initializer_list>\n#endif\n\n#if __cplusplus >= 201703L\n# include <string_view>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#ifdef __cpp_lib_is_constant_evaluated\n// Support P1032R1 in C++20 (but not P0980R1 yet).\n# define __cpp_lib_constexpr_string 201811L\n#elif __cplusplus >= 201703L\n// Support P0426R1 changes to char_traits in C++17.\n# define __cpp_lib_constexpr_string 201611L\n#elif __cplusplus > 201703L\n#endif\n\n#if _GLIBCXX_USE_CXX11_ABI\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n  /**\n   *  @class basic_string basic_string.h <string>\n   *  @brief  Managing sequences of characters and character-like objects.\n   *\n   *  @ingroup strings\n   *  @ingroup sequences\n   *\n   *  @tparam _CharT  Type of character\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n   *  <a href=\"tables.html#66\">reversible container</a>, and a\n   *  <a href=\"tables.html#67\">sequence</a>.  Of the\n   *  <a href=\"tables.html#68\">optional sequence requirements</a>, only\n   *  @c push_back, @c at, and @c %array access are supported.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_string\n    {\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n\trebind<_CharT>::other _Char_alloc_type;\n      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;\n\n      // Types:\n    public:\n      typedef _Traits\t\t\t\t\ttraits_type;\n      typedef typename _Traits::char_type\t\tvalue_type;\n      typedef _Char_alloc_type\t\t\t\tallocator_type;\n      typedef typename _Alloc_traits::size_type\t\tsize_type;\n      typedef typename _Alloc_traits::difference_type\tdifference_type;\n      typedef typename _Alloc_traits::reference\t\treference;\n      typedef typename _Alloc_traits::const_reference\tconst_reference;\n      typedef typename _Alloc_traits::pointer\t\tpointer;\n      typedef typename _Alloc_traits::const_pointer\tconst_pointer;\n      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;\n      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\n\t\t\t\t\t\t\tconst_iterator;\n      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n\n      ///  Value returned by various member functions when they fail.\n      static const size_type\tnpos = static_cast<size_type>(-1);\n\n    protected:\n      // type used for positions in insert, erase etc.\n#if __cplusplus < 201103L\n      typedef iterator __const_iterator;\n#else\n      typedef const_iterator __const_iterator;\n#endif\n\n    private:\n#if __cplusplus >= 201703L\n      // A helper type for avoiding boiler-plate.\n      typedef basic_string_view<_CharT, _Traits> __sv_type;\n\n      template<typename _Tp, typename _Res>\n\tusing _If_sv = enable_if_t<\n\t  __and_<is_convertible<const _Tp&, __sv_type>,\n\t\t __not_<is_convertible<const _Tp*, const basic_string*>>,\n\t\t __not_<is_convertible<const _Tp&, const _CharT*>>>::value,\n\t  _Res>;\n\n      // Allows an implicit conversion to __sv_type.\n      static __sv_type\n      _S_to_string_view(__sv_type __svt) noexcept\n      { return __svt; }\n\n      // Wraps a string_view by explicit conversion and thus\n      // allows to add an internal constructor that does not\n      // participate in overload resolution when a string_view\n      // is provided.\n      struct __sv_wrapper\n      {\n\texplicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }\n\t__sv_type _M_sv;\n      };\n\n      /**\n       *  @brief  Only internally used: Construct string from a string view\n       *          wrapper.\n       *  @param  __svw  string view wrapper.\n       *  @param  __a  Allocator to use.\n       */\n      explicit\n      basic_string(__sv_wrapper __svw, const _Alloc& __a)\n      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }\n#endif\n\n      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n      struct _Alloc_hider : allocator_type // TODO check __is_final\n      {\n#if __cplusplus < 201103L\n\t_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())\n\t: allocator_type(__a), _M_p(__dat) { }\n#else\n\t_Alloc_hider(pointer __dat, const _Alloc& __a)\n\t: allocator_type(__a), _M_p(__dat) { }\n\n\t_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())\n\t: allocator_type(std::move(__a)), _M_p(__dat) { }\n#endif\n\n\tpointer _M_p; // The actual data.\n      };\n\n      _Alloc_hider\t_M_dataplus;\n      size_type\t\t_M_string_length;\n\n      enum { _S_local_capacity = 15 / sizeof(_CharT) };\n\n      union\n      {\n\t_CharT           _M_local_buf[_S_local_capacity + 1];\n\tsize_type        _M_allocated_capacity;\n      };\n\n      void\n      _M_data(pointer __p)\n      { _M_dataplus._M_p = __p; }\n\n      void\n      _M_length(size_type __length)\n      { _M_string_length = __length; }\n\n      pointer\n      _M_data() const\n      { return _M_dataplus._M_p; }\n\n      pointer\n      _M_local_data()\n      {\n#if __cplusplus >= 201103L\n\treturn std::pointer_traits<pointer>::pointer_to(*_M_local_buf);\n#else\n\treturn pointer(_M_local_buf);\n#endif\n      }\n\n      const_pointer\n      _M_local_data() const\n      {\n#if __cplusplus >= 201103L\n\treturn std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);\n#else\n\treturn const_pointer(_M_local_buf);\n#endif\n      }\n\n      void\n      _M_capacity(size_type __capacity)\n      { _M_allocated_capacity = __capacity; }\n\n      void\n      _M_set_length(size_type __n)\n      {\n\t_M_length(__n);\n\ttraits_type::assign(_M_data()[__n], _CharT());\n      }\n\n      bool\n      _M_is_local() const\n      { return _M_data() == _M_local_data(); }\n\n      // Create & Destroy\n      pointer\n      _M_create(size_type&, size_type);\n\n      void\n      _M_dispose()\n      {\n\tif (!_M_is_local())\n\t  _M_destroy(_M_allocated_capacity);\n      }\n\n      void\n      _M_destroy(size_type __size) throw()\n      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }\n\n      // _M_construct_aux is used to implement the 21.3.1 para 15 which\n      // requires special behaviour if _InIterator is an integral type\n      template<typename _InIterator>\n        void\n        _M_construct_aux(_InIterator __beg, _InIterator __end,\n\t\t\t std::__false_type)\n\t{\n          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;\n          _M_construct(__beg, __end, _Tag());\n\t}\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 438. Ambiguity in the \"do the right thing\" clause\n      template<typename _Integer>\n        void\n        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)\n\t{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }\n\n      void\n      _M_construct_aux_2(size_type __req, _CharT __c)\n      { _M_construct(__req, __c); }\n\n      template<typename _InIterator>\n        void\n        _M_construct(_InIterator __beg, _InIterator __end)\n\t{\n\t  typedef typename std::__is_integer<_InIterator>::__type _Integral;\n\t  _M_construct_aux(__beg, __end, _Integral());\n        }\n\n      // For Input Iterators, used in istreambuf_iterators, etc.\n      template<typename _InIterator>\n        void\n        _M_construct(_InIterator __beg, _InIterator __end,\n\t\t     std::input_iterator_tag);\n\n      // For forward_iterators up to random_access_iterators, used for\n      // string::iterator, _CharT*, etc.\n      template<typename _FwdIterator>\n        void\n        _M_construct(_FwdIterator __beg, _FwdIterator __end,\n\t\t     std::forward_iterator_tag);\n\n      void\n      _M_construct(size_type __req, _CharT __c);\n\n      allocator_type&\n      _M_get_allocator()\n      { return _M_dataplus; }\n\n      const allocator_type&\n      _M_get_allocator() const\n      { return _M_dataplus; }\n\n    private:\n\n#ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST\n      // The explicit instantiations in misc-inst.cc require this due to\n      // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063\n      template<typename _Tp, bool _Requires =\n\t       !__are_same<_Tp, _CharT*>::__value\n\t       && !__are_same<_Tp, const _CharT*>::__value\n\t       && !__are_same<_Tp, iterator>::__value\n\t       && !__are_same<_Tp, const_iterator>::__value>\n\tstruct __enable_if_not_native_iterator\n\t{ typedef basic_string& __type; };\n      template<typename _Tp>\n\tstruct __enable_if_not_native_iterator<_Tp, false> { };\n#endif\n\n      size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n\tif (__pos > this->size())\n\t  __throw_out_of_range_fmt(__N(\"%s: __pos (which is %zu) > \"\n\t\t\t\t       \"this->size() (which is %zu)\"),\n\t\t\t\t   __s, __pos, this->size());\n\treturn __pos;\n      }\n\n      void\n      _M_check_length(size_type __n1, size_type __n2, const char* __s) const\n      {\n\tif (this->max_size() - (this->size() - __n1) < __n2)\n\t  __throw_length_error(__N(__s));\n      }\n\n\n      // NB: _M_limit doesn't check for a bad __pos value.\n      size_type\n      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT\n      {\n\tconst bool __testoff =  __off < this->size() - __pos;\n\treturn __testoff ? __off : this->size() - __pos;\n      }\n\n      // True if _Rep and source do not overlap.\n      bool\n      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT\n      {\n\treturn (less<const _CharT*>()(__s, _M_data())\n\t\t|| less<const _CharT*>()(_M_data() + this->size(), __s));\n      }\n\n      // When __n = 1 way faster than the general multichar\n      // traits_type::copy/move/assign.\n      static void\n      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::copy(__d, __s, __n);\n      }\n\n      static void\n      _S_move(_CharT* __d, const _CharT* __s, size_type __n)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::move(__d, __s, __n);\n      }\n\n      static void\n      _S_assign(_CharT* __d, size_type __n, _CharT __c)\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, __c);\n\telse\n\t  traits_type::assign(__d, __n, __c);\n      }\n\n      // _S_copy_chars is a separate template to permit specialization\n      // to optimize for the common case of pointers as iterators.\n      template<class _Iterator>\n        static void\n        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\n        {\n\t  for (; __k1 != __k2; ++__k1, (void)++__p)\n\t    traits_type::assign(*__p, *__k1); // These types are off.\n\t}\n\n      static void\n      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\n      _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT\n      { _S_copy(__p, __k1, __k2 - __k1); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\n      _GLIBCXX_NOEXCEPT\n      { _S_copy(__p, __k1, __k2 - __k1); }\n\n      static int\n      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT\n      {\n\tconst difference_type __d = difference_type(__n1 - __n2);\n\n\tif (__d > __gnu_cxx::__numeric_traits<int>::__max)\n\t  return __gnu_cxx::__numeric_traits<int>::__max;\n\telse if (__d < __gnu_cxx::__numeric_traits<int>::__min)\n\t  return __gnu_cxx::__numeric_traits<int>::__min;\n\telse\n\t  return int(__d);\n      }\n\n      void\n      _M_assign(const basic_string&);\n\n      void\n      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,\n\t\tsize_type __len2);\n\n      void\n      _M_erase(size_type __pos, size_type __n);\n\n    public:\n      // Construct/copy/destroy:\n      // NB: We overload ctors in some cases instead of using default\n      // arguments, per 17.4.4.4 para. 2 item 2.\n\n      /**\n       *  @brief  Default constructor creates an empty string.\n       */\n      basic_string()\n      _GLIBCXX_NOEXCEPT_IF(is_nothrow_default_constructible<_Alloc>::value)\n      : _M_dataplus(_M_local_data())\n      { _M_set_length(0); }\n\n      /**\n       *  @brief  Construct an empty string using allocator @a a.\n       */\n      explicit\n      basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_set_length(0); }\n\n      /**\n       *  @brief  Construct string with copy of value of @a __str.\n       *  @param  __str  Source string.\n       */\n      basic_string(const basic_string& __str)\n      : _M_dataplus(_M_local_data(),\n\t\t    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))\n      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2583. no way to supply an allocator for basic_string(str, pos)\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tconst _CharT* __start = __str._M_data()\n\t  + __str._M_check(__pos, \"basic_string::basic_string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, npos));\n      }\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n)\n      : _M_dataplus(_M_local_data())\n      {\n\tconst _CharT* __start = __str._M_data()\n\t  + __str._M_check(__pos, \"basic_string::basic_string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, __n));\n      }\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n, const _Alloc& __a)\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tconst _CharT* __start\n\t  = __str._M_data() + __str._M_check(__pos, \"string::string\");\n\t_M_construct(__start, __start + __str._M_limit(__pos, __n));\n      }\n\n      /**\n       *  @brief  Construct string initialized by a character %array.\n       *  @param  __s  Source character %array.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use (default is default allocator).\n       *\n       *  NB: @a __s must have at least @a __n characters, &apos;\\\\0&apos;\n       *  has no special meaning.\n       */\n      basic_string(const _CharT* __s, size_type __n,\n\t\t   const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__s, __s + __n); }\n\n      /**\n       *  @brief  Construct string as copy of a C string.\n       *  @param  __s  Source C string.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n#if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3076. basic_string CTAD ambiguity\n      template<typename = _RequireAllocator<_Alloc>>\n#endif\n      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tconst _CharT* __end = __s ? __s + traits_type::length(__s)\n\t  // We just need a non-null pointer here to get an exception:\n\t  : reinterpret_cast<const _CharT*>(__alignof__(_CharT));\n\t_M_construct(__s, __end, random_access_iterator_tag());\n      }\n\n      /**\n       *  @brief  Construct string as multiple characters.\n       *  @param  __n  Number of characters.\n       *  @param  __c  Character to use.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n#if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3076. basic_string CTAD ambiguity\n      template<typename = _RequireAllocator<_Alloc>>\n#endif\n      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__n, __c); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move construct string.\n       *  @param  __str  Source string.\n       *\n       *  The newly-created string contains the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       */\n      basic_string(basic_string&& __str) noexcept\n      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))\n      {\n\tif (__str._M_is_local())\n\t  {\n\t    traits_type::copy(_M_local_buf, __str._M_local_buf,\n\t\t\t      _S_local_capacity + 1);\n\t  }\n\telse\n\t  {\n\t    _M_data(__str._M_data());\n\t    _M_capacity(__str._M_allocated_capacity);\n\t  }\n\n\t// Must use _M_length() here not _M_set_length() because\n\t// basic_stringbuf relies on writing into unallocated capacity so\n\t// we mess up the contents if we put a '\\0' in the string.\n\t_M_length(__str.length());\n\t__str._M_data(__str._M_local_data());\n\t__str._M_set_length(0);\n      }\n\n      /**\n       *  @brief  Construct string from an initializer %list.\n       *  @param  __l  std::initializer_list of characters.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__l.begin(), __l.end()); }\n\n      basic_string(const basic_string& __str, const _Alloc& __a)\n      : _M_dataplus(_M_local_data(), __a)\n      { _M_construct(__str.begin(), __str.end()); }\n\n      basic_string(basic_string&& __str, const _Alloc& __a)\n      noexcept(_Alloc_traits::_S_always_equal())\n      : _M_dataplus(_M_local_data(), __a)\n      {\n\tif (__str._M_is_local())\n\t  {\n\t    traits_type::copy(_M_local_buf, __str._M_local_buf,\n\t\t\t      _S_local_capacity + 1);\n\t    _M_length(__str.length());\n\t    __str._M_set_length(0);\n\t  }\n\telse if (_Alloc_traits::_S_always_equal()\n\t    || __str.get_allocator() == __a)\n\t  {\n\t    _M_data(__str._M_data());\n\t    _M_length(__str.length());\n\t    _M_capacity(__str._M_allocated_capacity);\n\t    __str._M_data(__str._M_local_buf);\n\t    __str._M_set_length(0);\n\t  }\n\telse\n\t  _M_construct(__str.begin(), __str.end());\n      }\n\n#endif // C++11\n\n      /**\n       *  @brief  Construct string as copy of a range.\n       *  @param  __beg  Start of range.\n       *  @param  __end  End of range.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n#if __cplusplus >= 201103L\n      template<typename _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n#else\n      template<typename _InputIterator>\n#endif\n        basic_string(_InputIterator __beg, _InputIterator __end,\n\t\t     const _Alloc& __a = _Alloc())\n\t: _M_dataplus(_M_local_data(), __a)\n\t{ _M_construct(__beg, __end); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Construct string from a substring of a string_view.\n       *  @param  __t   Source object convertible to string view.\n       *  @param  __pos The index of the first character to copy from __t.\n       *  @param  __n   The number of characters to copy from __t.\n       *  @param  __a   Allocator to use.\n       */\n      template<typename _Tp,\n\t       typename = enable_if_t<is_convertible_v<const _Tp&, __sv_type>>>\n\tbasic_string(const _Tp& __t, size_type __pos, size_type __n,\n\t\t     const _Alloc& __a = _Alloc())\n\t: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }\n\n      /**\n       *  @brief  Construct string from a string_view.\n       *  @param  __t  Source object convertible to string view.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\texplicit\n\tbasic_string(const _Tp& __t, const _Alloc& __a = _Alloc())\n\t: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }\n#endif // C++17\n\n      /**\n       *  @brief  Destroy the string instance.\n       */\n      ~basic_string()\n      { _M_dispose(); }\n\n      /**\n       *  @brief  Assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       */\n      basic_string&\n      operator=(const basic_string& __str)\n      {\n\treturn this->assign(__str);\n      }\n\n      /**\n       *  @brief  Copy contents of @a s into this string.\n       *  @param  __s  Source null-terminated string.\n       */\n      basic_string&\n      operator=(const _CharT* __s)\n      { return this->assign(__s); }\n\n      /**\n       *  @brief  Set value to string of length 1.\n       *  @param  __c  Source character.\n       *\n       *  Assigning to a character makes this string length 1 and\n       *  (*this)[0] == @a c.\n       */\n      basic_string&\n      operator=(_CharT __c)\n      {\n\tthis->assign(1, __c);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       *\n       *  The contents of @a str are moved into this string (without copying).\n       *  @a str is a valid, but unspecified string.\n       */\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2063. Contradictory requirements for string move assignment\n      basic_string&\n      operator=(basic_string&& __str)\n      noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n\tif (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()\n\t    && !_Alloc_traits::_S_always_equal()\n\t    && _M_get_allocator() != __str._M_get_allocator())\n\t  {\n\t    // Destroy existing storage before replacing allocator.\n\t    _M_destroy(_M_allocated_capacity);\n\t    _M_data(_M_local_data());\n\t    _M_set_length(0);\n\t  }\n\t// Replace allocator if POCMA is true.\n\tstd::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());\n\n\tif (__str._M_is_local())\n\t  {\n\t    // We've always got room for a short string, just copy it\n\t    // (unless this is a self-move, because that would violate the\n\t    // char_traits::copy precondition that the ranges don't overlap).\n\t    if (__builtin_expect(std::__addressof(__str) != this, true))\n\t      {\n\t\tif (__str.size())\n\t\t  this->_S_copy(_M_data(), __str._M_data(), __str.size());\n\t\t_M_set_length(__str.size());\n\t      }\n\t  }\n\telse if (_Alloc_traits::_S_propagate_on_move_assign()\n\t    || _Alloc_traits::_S_always_equal()\n\t    || _M_get_allocator() == __str._M_get_allocator())\n\t  {\n\t    // Just move the allocated pointer, our allocator can free it.\n\t    pointer __data = nullptr;\n\t    size_type __capacity;\n\t    if (!_M_is_local())\n\t      {\n\t\tif (_Alloc_traits::_S_always_equal())\n\t\t  {\n\t\t    // __str can reuse our existing storage.\n\t\t    __data = _M_data();\n\t\t    __capacity = _M_allocated_capacity;\n\t\t  }\n\t\telse // __str can't use it, so free it.\n\t\t  _M_destroy(_M_allocated_capacity);\n\t      }\n\n\t    _M_data(__str._M_data());\n\t    _M_length(__str.length());\n\t    _M_capacity(__str._M_allocated_capacity);\n\t    if (__data)\n\t      {\n\t\t__str._M_data(__data);\n\t\t__str._M_capacity(__capacity);\n\t      }\n\t    else\n\t      __str._M_data(__str._M_local_buf);\n\t  }\n\telse // Need to do a deep copy\n\t  assign(__str);\n\t__str.clear();\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Set value to string constructed from initializer %list.\n       *  @param  __l  std::initializer_list.\n       */\n      basic_string&\n      operator=(initializer_list<_CharT> __l)\n      {\n\tthis->assign(__l.begin(), __l.size());\n\treturn *this;\n      }\n#endif // C++11\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Set value to string constructed from a string_view.\n       *  @param  __svt  An object convertible to string_view.\n       */\n     template<typename _Tp>\n       _If_sv<_Tp, basic_string&>\n       operator=(const _Tp& __svt)\n       { return this->assign(__svt); }\n\n      /**\n       *  @brief  Convert to a string_view.\n       *  @return A string_view.\n       */\n      operator __sv_type() const noexcept\n      { return __sv_type(data(), size()); }\n#endif // C++17\n\n      // Iterators:\n      /**\n       *  Returns a read/write iterator that points to the first character in\n       *  the %string.\n       */\n      iterator\n      begin() _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      begin() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data()); }\n\n      /**\n       *  Returns a read/write iterator that points one past the last\n       *  character in the %string.\n       */\n      iterator\n      end() _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data() + this->size()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      end() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data() + this->size()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to the last\n       *  character in the %string.  Iteration is done in reverse element\n       *  order.\n       */\n      reverse_iterator\n      rbegin() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      rbegin() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to one before the\n       *  first character in the %string.  Iteration is done in reverse\n       *  element order.\n       */\n      reverse_iterator\n      rend() _GLIBCXX_NOEXCEPT\n      { return reverse_iterator(this->begin()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      rend() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->begin()); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_data() + this->size()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(this->begin()); }\n#endif\n\n    public:\n      // Capacity:\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      size() const _GLIBCXX_NOEXCEPT\n      { return _M_string_length; }\n\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      length() const _GLIBCXX_NOEXCEPT\n      { return _M_string_length; }\n\n      ///  Returns the size() of the largest possible %string.\n      size_type\n      max_size() const _GLIBCXX_NOEXCEPT\n      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *  @param  __c  Character to fill any new elements.\n       *\n       *  This function will %resize the %string to the specified\n       *  number of characters.  If the number is smaller than the\n       *  %string's current size the %string is truncated, otherwise\n       *  the %string is extended and new elements are %set to @a __c.\n       */\n      void\n      resize(size_type __n, _CharT __c);\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *\n       *  This function will resize the %string to the specified length.  If\n       *  the new size is smaller than the %string's current size the %string\n       *  is truncated, otherwise the %string is extended and new characters\n       *  are default-constructed.  For basic types such as char, this means\n       *  setting them to 0.\n       */\n      void\n      resize(size_type __n)\n      { this->resize(__n, _CharT()); }\n\n#if __cplusplus >= 201103L\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n      ///  A non-binding request to reduce capacity() to size().\n      void\n      shrink_to_fit() noexcept\n      { reserve(); }\n#pragma GCC diagnostic pop\n#endif\n\n      /**\n       *  Returns the total number of characters that the %string can hold\n       *  before needing to allocate more memory.\n       */\n      size_type\n      capacity() const _GLIBCXX_NOEXCEPT\n      {\n\treturn _M_is_local() ? size_type(_S_local_capacity)\n\t                     : _M_allocated_capacity;\n      }\n\n      /**\n       *  @brief  Attempt to preallocate enough memory for specified number of\n       *          characters.\n       *  @param  __res_arg  Number of characters required.\n       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().\n       *\n       *  This function attempts to reserve enough memory for the\n       *  %string to hold the specified number of characters.  If the\n       *  number requested is more than max_size(), length_error is\n       *  thrown.\n       *\n       *  The advantage of this function is that if optimal code is a\n       *  necessity and the user can determine the string length that will be\n       *  required, the user can reserve the memory in %advance, and thus\n       *  prevent a possible reallocation of memory and copying of %string\n       *  data.\n       */\n      void\n      reserve(size_type __res_arg);\n\n      /**\n       *  Equivalent to shrink_to_fit().\n       */\n#if __cplusplus > 201703L\n      [[deprecated(\"use shrink_to_fit() instead\")]]\n#endif\n      void\n      reserve();\n\n      /**\n       *  Erases the string, making it empty.\n       */\n      void\n      clear() _GLIBCXX_NOEXCEPT\n      { _M_set_length(0); }\n\n      /**\n       *  Returns true if the %string is empty.  Equivalent to \n       *  <code>*this == \"\"</code>.\n       */\n      _GLIBCXX_NODISCARD bool\n      empty() const _GLIBCXX_NOEXCEPT\n      { return this->size() == 0; }\n\n      // Element access:\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read-only (constant) reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      const_reference\n      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_assert(__pos <= size());\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      reference\n      operator[](size_type __pos)\n      {\n        // Allow pos == size() both in C++98 mode, as v3 extension,\n\t// and in C++11 mode.\n\t__glibcxx_assert(__pos <= size());\n        // In pedantic mode be strict in C++98 mode.\n\t_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read-only (const) reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.\n       */\n      const_reference\n      at(size_type __n) const\n      {\n\tif (__n >= this->size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\treturn _M_data()[__n];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.\n       */\n      reference\n      at(size_type __n)\n      {\n\tif (__n >= size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\treturn _M_data()[__n];\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read/write reference to the data at the first\n       *  element of the %string.\n       */\n      reference\n      front() noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the first\n       *  element of the %string.\n       */\n      const_reference\n      front() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read/write reference to the data at the last\n       *  element of the %string.\n       */\n      reference\n      back() noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the\n       *  last element of the %string.\n       */\n      const_reference\n      back() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n#endif\n\n      // Modifiers:\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const basic_string& __str)\n      { return this->append(__str); }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const _CharT* __s)\n      { return this->append(__s); }\n\n      /**\n       *  @brief  Append a character.\n       *  @param __c  The character to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(_CharT __c)\n      {\n\tthis->push_back(__c);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to be appended.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt  An object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\toperator+=(const _Tp& __svt)\n\t{ return this->append(__svt); }\n#endif // C++17\n\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const basic_string& __str)\n      { return _M_append(__str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Append a substring.\n       *  @param __str  The string to append.\n       *  @param __pos  Index of the first character of str to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a __pos is not a valid index.\n       *\n       *  This function appends @a __n characters from @a __str\n       *  starting at @a __pos to this string.  If @a __n is is larger\n       *  than the number of available characters in @a __str, the\n       *  remainder of @a __str is appended.\n       */\n      basic_string&\n      append(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return _M_append(__str._M_data()\n\t\t\t + __str._M_check(__pos, \"basic_string::append\"),\n\t\t\t __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Append a C substring.\n       *  @param __s  The C string to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s, size_type __n)\n      {\n\t__glibcxx_requires_string_len(__s, __n);\n\t_M_check_length(size_type(0), __n, \"basic_string::append\");\n\treturn _M_append(__s, __n);\n      }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\tconst size_type __n = traits_type::length(__s);\n\t_M_check_length(size_type(0), __n, \"basic_string::append\");\n\treturn _M_append(__s, __n);\n      }\n\n      /**\n       *  @brief  Append multiple characters.\n       *  @param __n  The number of characters to append.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  Appends __n copies of __c to this string.\n       */\n      basic_string&\n      append(size_type __n, _CharT __c)\n      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n      /**\n       *  @brief  Append a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Appends characters in the range [__first,__last) to this string.\n       */\n#if __cplusplus >= 201103L\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n#else\n      template<class _InputIterator>\n#endif\n        basic_string&\n        append(_InputIterator __first, _InputIterator __last)\n        { return this->replace(end(), end(), __first, __last); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt  An object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        append(const _Tp& __svt)\n        {\n          __sv_type __sv = __svt;\n          return this->append(__sv.data(), __sv.size());\n        }\n\n      /**\n       *  @brief  Append a range of characters from a string_view.\n       *  @param __svt  An object convertible to string_view to be appended from.\n       *  @param __pos The position in the string_view to append from.\n       *  @param __n   The number of characters to append from the string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n\tappend(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return _M_append(__sv.data()\n\t      + std::__sv_check(__sv.size(), __pos, \"basic_string::append\"),\n\t      std::__sv_limit(__sv.size(), __pos, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Append a single character.\n       *  @param __c  Character to append.\n       */\n      void\n      push_back(_CharT __c)\n      {\n\tconst size_type __size = this->size();\n\tif (__size + 1 > this->capacity())\n\t  this->_M_mutate(__size, size_type(0), 0, size_type(1));\n\ttraits_type::assign(this->_M_data()[__size], __c);\n\tthis->_M_set_length(__size + 1);\n      }\n\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(const basic_string& __str)\n      {\n#if __cplusplus >= 201103L\n\tif (_Alloc_traits::_S_propagate_on_copy_assign())\n\t  {\n\t    if (!_Alloc_traits::_S_always_equal() && !_M_is_local()\n\t\t&& _M_get_allocator() != __str._M_get_allocator())\n\t      {\n\t\t// Propagating allocator cannot free existing storage so must\n\t\t// deallocate it before replacing current allocator.\n\t\tif (__str.size() <= _S_local_capacity)\n\t\t  {\n\t\t    _M_destroy(_M_allocated_capacity);\n\t\t    _M_data(_M_local_data());\n\t\t    _M_set_length(0);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const auto __len = __str.size();\n\t\t    auto __alloc = __str._M_get_allocator();\n\t\t    // If this allocation throws there are no effects:\n\t\t    auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);\n\t\t    _M_destroy(_M_allocated_capacity);\n\t\t    _M_data(__ptr);\n\t\t    _M_capacity(__len);\n\t\t    _M_set_length(__len);\n\t\t  }\n\t      }\n\t    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());\n\t  }\n#endif\n\tthis->_M_assign(__str);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets this string to the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       */\n      basic_string&\n      assign(basic_string&& __str)\n      noexcept(_Alloc_traits::_S_nothrow_move())\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 2063. Contradictory requirements for string move assignment\n\treturn *this = std::move(__str);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Set value to a substring of a string.\n       *  @param __str  The string to use.\n       *  @param __pos  Index of the first character of str.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a pos is not a valid index.\n       *\n       *  This function sets this string to the substring of @a __str\n       *  consisting of @a __n characters at @a __pos.  If @a __n is\n       *  is larger than the number of available characters in @a\n       *  __str, the remainder of @a __str is used.\n       */\n      basic_string&\n      assign(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return _M_replace(size_type(0), this->size(), __str._M_data()\n\t\t\t  + __str._M_check(__pos, \"basic_string::assign\"),\n\t\t\t  __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Set value to a C substring.\n       *  @param __s  The C string to use.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the first @a __n\n       *  characters of @a __s.  If @a __n is is larger than the number of\n       *  available characters in @a __s, the remainder of @a __s is used.\n       */\n      basic_string&\n      assign(const _CharT* __s, size_type __n)\n      {\n\t__glibcxx_requires_string_len(__s, __n);\n\treturn _M_replace(size_type(0), this->size(), __s, __n);\n      }\n\n      /**\n       *  @brief  Set value to contents of a C string.\n       *  @param __s  The C string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the value of @a __s.\n       *  The data is copied, so there is no dependence on @a __s once the\n       *  function returns.\n       */\n      basic_string&\n      assign(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn _M_replace(size_type(0), this->size(), __s,\n\t\t\t  traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Set value to multiple characters.\n       *  @param __n  Length of the resulting string.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to @a __n copies of\n       *  character @a __c.\n       */\n      basic_string&\n      assign(size_type __n, _CharT __c)\n      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }\n\n      /**\n       *  @brief  Set value to a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Sets value of string to characters in the range [__first,__last).\n      */\n#if __cplusplus >= 201103L\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n#else\n      template<class _InputIterator>\n#endif\n        basic_string&\n        assign(_InputIterator __first, _InputIterator __last)\n        { return this->replace(begin(), end(), __first, __last); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to assign.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(initializer_list<_CharT> __l)\n      { return this->assign(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Set value from a string_view.\n       *  @param __svt  The source object convertible to string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tassign(const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->assign(__sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Set value from a range of characters in a string_view.\n       *  @param __svt  The source object convertible to string_view.\n       *  @param __pos  The position in the string_view to assign from.\n       *  @param __n  The number of characters to assign.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tassign(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return _M_replace(size_type(0), this->size(),\n\t      __sv.data()\n\t      + std::__sv_check(__sv.size(), __pos, \"basic_string::assign\"),\n\t      std::__sv_limit(__sv.size(), __pos, __n));\n\t}\n#endif // C++17\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Const_iterator referencing location in string to\n       *              insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing the first inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(const_iterator __p, size_type __n, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\tconst size_type __pos = __p - begin();\n\tthis->replace(__p, __p, __n, __c);\n\treturn iterator(this->_M_data() + __pos);\n      }\n#else\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      void\n      insert(iterator __p, size_type __n, _CharT __c)\n      {\tthis->replace(__p, __p, __n, __c);  }\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Const_iterator referencing location in string to\n       *              insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @return  Iterator referencing the first inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [beg,end).  If adding characters\n       *  causes the length to exceed max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n\titerator\n        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\t  const size_type __pos = __p - begin();\n\t  this->replace(__p, __p, __beg, __end);\n\t  return iterator(this->_M_data() + __pos);\n\t}\n#else\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [__beg,__end).  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      template<class _InputIterator>\n        void\n        insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n        { this->replace(__p, __p, __beg, __end); }\n#endif\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert an initializer_list of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       */\n      iterator\n      insert(const_iterator __p, initializer_list<_CharT> __l)\n      { return this->insert(__p, __l.begin(), __l.end()); }\n\n#ifdef _GLIBCXX_DEFINING_STRING_INSTANTIATIONS\n      // See PR libstdc++/83328\n      void\n      insert(iterator __p, initializer_list<_CharT> __l)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\tthis->insert(__p - begin(), __l.begin(), __l.size());\n      }\n#endif\n#endif // C++11\n\n      /**\n       *  @brief  Insert value of a string.\n       *  @param __pos1 Position in string to insert at.\n       *  @param __str  The string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts value of @a __str starting at @a __pos1.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str)\n      { return this->replace(__pos1, size_type(0),\n\t\t\t     __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Insert a substring.\n       *  @param __pos1  Position in string to insert at.\n       *  @param __str   The string to insert.\n       *  @param __pos2  Start of characters in str to insert.\n       *  @param __n  Number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos1 > size() or\n       *  @a __pos2 > @a str.size().\n       *\n       *  Starting at @a pos1, insert @a __n character of @a __str\n       *  beginning with @a __pos2.  If adding characters causes the\n       *  length to exceed max_size(), length_error is thrown.  If @a\n       *  __pos1 is beyond the end of this string or @a __pos2 is\n       *  beyond the end of @a __str, out_of_range is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str,\n\t     size_type __pos2, size_type __n = npos)\n      { return this->replace(__pos1, size_type(0), __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t     __str._M_limit(__pos2, __n)); }\n\n      /**\n       *  @brief  Insert a C substring.\n       *  @param __pos  Position in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @param __n  The number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a __n characters of @a __s starting at @a\n       *  __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos is beyond\n       *  end(), out_of_range is thrown.  The value of the string\n       *  doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s, size_type __n)\n      { return this->replace(__pos, size_type(0), __s, __n); }\n\n      /**\n       *  @brief  Insert a C string.\n       *  @param __pos  Position in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If\n       *  adding characters causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is\n       *  thrown.  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__pos, size_type(0), __s,\n\t\t\t     traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __pos  Index in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts @a __n copies of character @a __c starting at index\n       *  @a __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos > length(),\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, size_type __n, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::insert\"),\n\t\t\t      size_type(0), __n, __c); }\n\n      /**\n       *  @brief  Insert one character.\n       *  @param __p  Iterator referencing position in string to insert at.\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing newly inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts character @a __c at position referenced by @a __p.\n       *  If adding character causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(__const_iterator __p, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());\n\tconst size_type __pos = __p - begin();\n\t_M_replace_aux(__pos, size_type(0), size_type(1), __c);\n\treturn iterator(_M_data() + __pos);\n      }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tinsert(size_type __pos, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->insert(__pos, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos1  Position in string to insert at.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @param __pos2  Start of characters in str to insert.\n       *  @param __n    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tinsert(size_type __pos1, const _Tp& __svt,\n\t       size_type __pos2, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, size_type(0),\n\t      __sv.data()\n\t      + std::__sv_check(__sv.size(), __pos2, \"basic_string::insert\"),\n\t      std::__sv_limit(__sv.size(), __pos2, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Remove characters.\n       *  @param __pos  Index of first character to remove (default 0).\n       *  @param __n  Number of characters to remove (default remainder).\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Removes @a __n characters from this string starting at @a\n       *  __pos.  The length of the string is reduced by @a __n.  If\n       *  there are < @a __n characters to remove, the remainder of\n       *  the string is truncated.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      erase(size_type __pos = 0, size_type __n = npos)\n      {\n\t_M_check(__pos, \"basic_string::erase\");\n\tif (__n == npos)\n\t  this->_M_set_length(__pos);\n\telse if (__n != 0)\n\t  this->_M_erase(__pos, _M_limit(__pos, __n));\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Remove one character.\n       *  @param __position  Iterator referencing the character to remove.\n       *  @return  iterator referencing same location after removal.\n       *\n       *  Removes the character at @a __position from this string. The value\n       *  of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(__const_iterator __position)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__position >= begin()\n\t\t\t\t && __position < end());\n\tconst size_type __pos = __position - begin();\n\tthis->_M_erase(__pos, size_type(1));\n\treturn iterator(_M_data() + __pos);\n      }\n\n      /**\n       *  @brief  Remove a range of characters.\n       *  @param __first  Iterator referencing the first character to remove.\n       *  @param __last  Iterator referencing the end of the range.\n       *  @return  Iterator referencing location of first after removal.\n       *\n       *  Removes the characters in the range [first,last) from this string.\n       *  The value of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(__const_iterator __first, __const_iterator __last)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__first >= begin() && __first <= __last\n\t\t\t\t && __last <= end());\n        const size_type __pos = __first - begin();\n\tif (__last == end())\n\t  this->_M_set_length(__pos);\n\telse\n\t  this->_M_erase(__pos, __last - __first);\n\treturn iterator(this->_M_data() + __pos);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Remove the last character.\n       *\n       *  The string must be non-empty.\n       */\n      void\n      pop_back() noexcept\n      {\n\t__glibcxx_assert(!empty());\n\t_M_erase(size() - 1, 1);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos+__n) from\n       *  this string.  In place, the value of @a __str is inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of the result exceeds max_size(), length_error\n       *  is thrown.  The value of the string doesn't change if an\n       *  error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n, const basic_string& __str)\n      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos1  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @param __pos2  Index of first character of str to use.\n       *  @param __n2  Number of characters from str to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >\n       *  __str.size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos1,__pos1 + n) from this\n       *  string.  In place, the value of @a __str is inserted.  If @a __pos is\n       *  beyond end of string, out_of_range is thrown.  If the length of the\n       *  result exceeds max_size(), length_error is thrown.  The value of the\n       *  string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos)\n      { return this->replace(__pos1, __n1, __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"basic_string::replace\"),\n\t\t\t     __str._M_limit(__pos2, __n2)); }\n\n      /**\n       *  @brief  Replace characters with value of a C substring.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @param __n2  Number of characters from @a s to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos1 > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the first @a __n2 characters of\n       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If\n       *  @a __pos is beyond end of string, out_of_range is thrown.  If\n       *  the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2)\n      {\n\t__glibcxx_requires_string_len(__s, __n2);\n\treturn _M_replace(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t  _M_limit(__pos, __n1), __s, __n2);\n      }\n\n      /**\n       *  @brief  Replace characters with value of a C string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the characters of @a __s are\n       *  inserted.  If @a __pos is beyond end of string, out_of_range\n       *  is thrown.  If the length of result exceeds max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__pos, __n1, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace characters with multiple characters.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __n2  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos + n1) from this\n       *  string.  In place, @a __n2 copies of @a __c are inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t      _M_limit(__pos, __n1), __n2, __c); }\n\n      /**\n       *  @brief  Replace range of characters with string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __str  String value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the value of @a __str is inserted.  If the length of result\n       *  exceeds max_size(), length_error is thrown.  The value of\n       *  the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const basic_string& __str)\n      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace range of characters with C substring.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @param __n  Number of characters from s to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the first @a __n characters of @a __s are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const _CharT* __s, size_type __n)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\treturn this->replace(__i1 - begin(), __i2 - __i1, __s, __n);\n      }\n\n      /**\n       *  @brief  Replace range of characters with C string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the characters of @a __s are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__i1, __i2, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace range of characters with multiple characters\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __n  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  @a __n copies of @a __c are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,\n\t      _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\treturn _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);\n      }\n\n      /**\n       *  @brief  Replace range of characters with range.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __k1  Iterator referencing start of range to insert.\n       *  @param __k2  Iterator referencing end of range to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n#if __cplusplus >= 201103L\n      template<class _InputIterator,\n\t       typename = std::_RequireInputIter<_InputIterator>>\n        basic_string&\n        replace(const_iterator __i1, const_iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t   && __i2 <= end());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,\n\t\t\t\t\t   std::__false_type());\n\t}\n#else\n      template<class _InputIterator>\n#ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST\n        typename __enable_if_not_native_iterator<_InputIterator>::__type\n#else\n        basic_string&\n#endif\n        replace(iterator __i1, iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t   && __i2 <= end());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());\n\t}\n#endif\n\n      // Specializations for the common case of pointer and iterator:\n      // useful to avoid the overhead of temporary buffering in _M_replace.\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      _CharT* __k1, _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const _CharT* __k1, const _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      iterator __k1, iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n      basic_string&\n      replace(__const_iterator __i1, __const_iterator __i2,\n\t      const_iterator __k1, const_iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= end());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - begin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Replace range of characters with initializer_list.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string& replace(const_iterator __i1, const_iterator __i2,\n\t\t\t    initializer_list<_CharT> __l)\n      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos  The position to replace at.\n       *  @param __n    The number of characters to replace.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(size_type __pos, size_type __n, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos, __n, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos1  The position to replace at.\n       *  @param __n1    The number of characters to replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @param __pos2  The position in the string_view to insert from.\n       *  @param __n2    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, __n1,\n\t      __sv.data()\n\t      + std::__sv_check(__sv.size(), __pos2, \"basic_string::replace\"),\n\t      std::__sv_limit(__sv.size(), __pos2, __n2));\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __i1    An iterator referencing the start position\n          to replace at.\n       *  @param __i2    An iterator referencing the end position\n          for the replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__i1 - begin(), __i2 - __i1, __sv);\n\t}\n#endif // C++17\n\n    private:\n      template<class _Integer>\n\tbasic_string&\n\t_M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n\t\t\t    _Integer __n, _Integer __val, __true_type)\n        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }\n\n      template<class _InputIterator>\n\tbasic_string&\n\t_M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n\t\t\t    _InputIterator __k1, _InputIterator __k2,\n\t\t\t    __false_type);\n\n      basic_string&\n      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t     _CharT __c);\n\n      basic_string&\n      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,\n\t\t const size_type __len2);\n\n      basic_string&\n      _M_append(const _CharT* __s, size_type __n);\n\n    public:\n\n      /**\n       *  @brief  Copy substring into C string.\n       *  @param __s  C string to copy value into.\n       *  @param __n  Number of characters to copy.\n       *  @param __pos  Index of first character to copy.\n       *  @return  Number of characters actually copied\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Copies up to @a __n characters starting at @a __pos into the\n       *  C string @a __s.  If @a __pos is %greater than size(),\n       *  out_of_range is thrown.\n      */\n      size_type\n      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n\n      /**\n       *  @brief  Swap contents with another string.\n       *  @param __s  String to swap with.\n       *\n       *  Exchanges the contents of this string with that of @a __s in constant\n       *  time.\n      */\n      void\n      swap(basic_string& __s) _GLIBCXX_NOEXCEPT;\n\n      // String operations:\n      /**\n       *  @brief  Return const pointer to null-terminated contents.\n       *\n       *  This is a handle to internal data.  Do not modify or dire things may\n       *  happen.\n      */\n      const _CharT*\n      c_str() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n      /**\n       *  @brief  Return const pointer to contents.\n       *\n       *  This is a pointer to internal data.  It is undefined to modify\n       *  the contents through the returned pointer. To get a pointer that\n       *  allows modifying the contents use @c &str[0] instead,\n       *  (or in C++17 the non-const @c str.data() overload).\n      */\n      const _CharT*\n      data() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Return non-const pointer to contents.\n       *\n       *  This is a pointer to the character sequence held by the string.\n       *  Modifying the characters in the sequence is allowed.\n      */\n      _CharT*\n      data() noexcept\n      { return _M_data(); }\n#endif\n\n      /**\n       *  @brief  Return copy of allocator used to construct this string.\n      */\n      allocator_type\n      get_allocator() const _GLIBCXX_NOEXCEPT\n      { return _M_get_allocator(); }\n\n      /**\n       *  @brief  Find position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from @a s to search for.\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for value of @a __str within\n       *  this string.  If found, returns the index where it begins.  If not\n       *  found, returns npos.\n      */\n      size_type\n      find(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the value of @a\n       *  __s within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for value of @a\n       *  __str within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->rfind(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find last position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\trfind(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->rfind(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to start search at (default end).\n       *  @return  Index of start of  last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the value of\n       *  @a __s within this string.  If found, returns the index\n       *  where it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos = npos) const\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->rfind(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_first_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find position of a character of a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character of C substring.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of C string.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the character\n       *  @a __c within this string.  If found, returns the index\n       *  where it was found.  If not found, returns npos.\n       *\n       *  Note: equivalent to find(__c, __pos).\n      */\n      size_type\n      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      { return this->find(__c, __pos); }\n\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character of C substring.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character of C string.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n       *\n       *  Note: equivalent to rfind(__c, __pos).\n      */\n      size_type\n      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      { return this->rfind(__c, __pos); }\n\n      /**\n       *  @brief  Find position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not contained\n       *  in @a __str within this string.  If found, returns the index where it\n       *  was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find position of a character not in a string_view.\n       *  @param __svt  A object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_not_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from __s to consider.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in the first @a __n characters of @a __s within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos,\n\t\t\tsize_type __n) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character\n       *  other than @a __c within this string.  If found, returns the\n       *  index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(_CharT __c, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find last position of a character not in a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_not_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to consider.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character not\n       *  contained in the first @a __n characters of @a __s within this string.\n       *  If found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos,\n\t\t       size_type __n) const _GLIBCXX_NOEXCEPT;\n      /**\n       *  @brief  Find last position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __s within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character other than\n       *  @a __c within this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_last_not_of(_CharT __c, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Get a substring.\n       *  @param __pos  Index of first character (default 0).\n       *  @param __n  Number of characters in substring (default remainder).\n       *  @return  The new string.\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Construct and return a new string using the @a __n\n       *  characters starting at @a __pos.  If the string is too\n       *  short, use the remainder of the characters.  If @a __pos is\n       *  beyond the end of the string, out_of_range is thrown.\n      */\n      basic_string\n      substr(size_type __pos = 0, size_type __n = npos) const\n      { return basic_string(*this,\n\t\t\t    _M_check(__pos, \"basic_string::substr\"), __n); }\n\n      /**\n       *  @brief  Compare to a string.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a\n       *  __str, 0 if their values are equivalent, or > 0 if this\n       *  string is ordered after @a __str.  Determines the effective\n       *  length rlen of the strings to compare as the smallest of\n       *  size() and str.size().  The function then compares the two\n       *  strings by calling traits::compare(data(), str.data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(const basic_string& __str) const\n      {\n\tconst size_type __size = this->size();\n\tconst size_type __osize = __str.size();\n\tconst size_type __len = std::min(__size, __osize);\n\n\tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n\tif (!__r)\n\t  __r = _S_compare(__size, __osize);\n\treturn __r;\n      }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __svt An object convertible to string_view to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  const size_type __size = this->size();\n\t  const size_type __osize = __sv.size();\n\t  const size_type __len = std::min(__size, __osize);\n\n\t  int __r = traits_type::compare(_M_data(), __sv.data(), __len);\n\t  if (!__r)\n\t    __r = _S_compare(__size, __osize);\n\t  return __r;\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos  A position in the string to start comparing from.\n       *  @param __n  The number of characters to compare.\n       *  @param __svt  An object convertible to string_view to compare\n       *                against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos, size_type __n, const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this).substr(__pos, __n).compare(__sv);\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos1  A position in the string to start comparing from.\n       *  @param __n1  The number of characters to compare.\n       *  @param __svt  An object convertible to string_view to compare\n       *                against.\n       *  @param __pos2  A position in the string_view to start comparing from.\n       *  @param __n2  The number of characters to compare.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this)\n\t    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Compare substring to a string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n characters\n       *  starting at @a __pos.  Returns an integer < 0 if the\n       *  substring is ordered before @a __str, 0 if their values are\n       *  equivalent, or > 0 if the substring is ordered after @a\n       *  __str.  Determines the effective length rlen of the strings\n       *  to compare as the smallest of the length of the substring\n       *  and @a __str.size().  The function then compares the two\n       *  strings by calling\n       *  traits::compare(substring.data(),str.data(),rlen).  If the\n       *  result of the comparison is nonzero returns it, otherwise\n       *  the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n, const basic_string& __str) const;\n\n      /**\n       *  @brief  Compare substring to a substring.\n       *  @param __pos1  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @param __pos2  Index of first character of substring of str.\n       *  @param __n2  Number of characters in substring of str.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos1.  Form the substring of @a\n       *  __str from the @a __n2 characters starting at @a __pos2.\n       *  Returns an integer < 0 if this substring is ordered before\n       *  the substring of @a __str, 0 if their values are equivalent,\n       *  or > 0 if this substring is ordered after the substring of\n       *  @a __str.  Determines the effective length rlen of the\n       *  strings to compare as the smallest of the lengths of the\n       *  substrings.  The function then compares the two strings by\n       *  calling\n       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos) const;\n\n      /**\n       *  @brief  Compare to a C string.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if\n       *  their values are equivalent, or > 0 if this string is ordered after\n       *  @a __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of size() and the length of a string\n       *  constructed from @a __s.  The function then compares the two strings\n       *  by calling traits::compare(data(),s,rlen).  If the result of the\n       *  comparison is nonzero returns it, otherwise the shorter one is\n       *  ordered first.\n      */\n      int\n      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 5 String::compare specification questionable\n      /**\n       *  @brief  Compare substring to a C string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a pos.  Returns an integer < 0 if\n       *  the substring is ordered before @a __s, 0 if their values\n       *  are equivalent, or > 0 if the substring is ordered after @a\n       *  __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of the length of the substring and\n       *  the length of a string constructed from @a __s.  The\n       *  function then compares the two string by calling\n       *  traits::compare(substring.data(),__s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n\n      /**\n       *  @brief  Compare substring against a character %array.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  character %array to compare against.\n       *  @param __n2  Number of characters of s.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos.  Form a string from the\n       *  first @a __n2 characters of @a __s.  Returns an integer < 0\n       *  if this substring is ordered before the string from @a __s,\n       *  0 if their values are equivalent, or > 0 if this substring\n       *  is ordered after the string from @a __s.  Determines the\n       *  effective length rlen of the strings to compare as the\n       *  smallest of the length of the substring and @a __n2.  The\n       *  function then compares the two strings by calling\n       *  traits::compare(substring.data(),s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n       *\n       *  NB: s must have at least n2 characters, &apos;\\\\0&apos; has\n       *  no special meaning.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2) const;\n\n#if __cplusplus > 201703L\n      bool\n      starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept\n      { return __sv_type(this->data(), this->size()).starts_with(__x); }\n\n      bool\n      starts_with(_CharT __x) const noexcept\n      { return __sv_type(this->data(), this->size()).starts_with(__x); }\n\n      bool\n      starts_with(const _CharT* __x) const noexcept\n      { return __sv_type(this->data(), this->size()).starts_with(__x); }\n\n      bool\n      ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept\n      { return __sv_type(this->data(), this->size()).ends_with(__x); }\n\n      bool\n      ends_with(_CharT __x) const noexcept\n      { return __sv_type(this->data(), this->size()).ends_with(__x); }\n\n      bool\n      ends_with(const _CharT* __x) const noexcept\n      { return __sv_type(this->data(), this->size()).ends_with(__x); }\n#endif // C++20\n\n#if __cplusplus > 202002L\n      bool\n      contains(basic_string_view<_CharT, _Traits> __x) const noexcept\n      { return __sv_type(this->data(), this->size()).contains(__x); }\n\n      bool\n      contains(_CharT __x) const noexcept\n      { return __sv_type(this->data(), this->size()).contains(__x); }\n\n      bool\n      contains(const _CharT* __x) const noexcept\n      { return __sv_type(this->data(), this->size()).contains(__x); }\n#endif // C++23\n\n      // Allow basic_stringbuf::__xfer_bufptrs to call _M_length:\n      template<typename, typename, typename> friend class basic_stringbuf;\n    };\n_GLIBCXX_END_NAMESPACE_CXX11\n#else  // !_GLIBCXX_USE_CXX11_ABI\n  // Reference-counted COW string implentation\n\n  /**\n   *  @class basic_string basic_string.h <string>\n   *  @brief  Managing sequences of characters and character-like objects.\n   *\n   *  @ingroup strings\n   *  @ingroup sequences\n   *\n   *  @tparam _CharT  Type of character\n   *  @tparam _Traits  Traits for character type, defaults to\n   *                   char_traits<_CharT>.\n   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n   *\n   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n   *  <a href=\"tables.html#66\">reversible container</a>, and a\n   *  <a href=\"tables.html#67\">sequence</a>.  Of the\n   *  <a href=\"tables.html#68\">optional sequence requirements</a>, only\n   *  @c push_back, @c at, and @c %array access are supported.\n   *\n   *  @doctodo\n   *\n   *\n   *  Documentation?  What's that?\n   *  Nathan Myers <ncm@cantrip.org>.\n   *\n   *  A string looks like this:\n   *\n   *  @code\n   *                                        [_Rep]\n   *                                        _M_length\n   *   [basic_string<char_type>]            _M_capacity\n   *   _M_dataplus                          _M_refcount\n   *   _M_p ---------------->               unnamed array of char_type\n   *  @endcode\n   *\n   *  Where the _M_p points to the first character in the string, and\n   *  you cast it to a pointer-to-_Rep and subtract 1 to get a\n   *  pointer to the header.\n   *\n   *  This approach has the enormous advantage that a string object\n   *  requires only one allocation.  All the ugliness is confined\n   *  within a single %pair of inline functions, which each compile to\n   *  a single @a add instruction: _Rep::_M_data(), and\n   *  string::_M_rep(); and the allocation function which gets a\n   *  block of raw bytes and with room enough and constructs a _Rep\n   *  object at the front.\n   *\n   *  The reason you want _M_data pointing to the character %array and\n   *  not the _Rep is so that the debugger can see the string\n   *  contents. (Probably we should add a non-inline member to get\n   *  the _Rep for the debugger to use, so users can check the actual\n   *  string length.)\n   *\n   *  Note that the _Rep object is a POD so that you can have a\n   *  static <em>empty string</em> _Rep object already @a constructed before\n   *  static constructors have run.  The reference-count encoding is\n   *  chosen so that a 0 indicates one reference, so you never try to\n   *  destroy the empty-string _Rep object.\n   *\n   *  All but the last paragraph is considered pretty conventional\n   *  for a C++ string implementation.\n  */\n  // 21.3  Template class basic_string\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    class basic_string\n    {\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n\trebind<_CharT>::other _CharT_alloc_type;\n      typedef __gnu_cxx::__alloc_traits<_CharT_alloc_type> _CharT_alloc_traits;\n\n      // Types:\n    public:\n      typedef _Traits\t\t\t\t\t    traits_type;\n      typedef typename _Traits::char_type\t\t    value_type;\n      typedef _Alloc\t\t\t\t\t    allocator_type;\n      typedef typename _CharT_alloc_traits::size_type\t    size_type;\n      typedef typename _CharT_alloc_traits::difference_type difference_type;\n#if __cplusplus < 201103L\n      typedef typename _CharT_alloc_type::reference\t    reference;\n      typedef typename _CharT_alloc_type::const_reference   const_reference;\n#else\n      typedef value_type&\t\t\t\t    reference;\n      typedef const value_type&\t\t\t\t    const_reference;\n#endif\n      typedef typename _CharT_alloc_traits::pointer\t    pointer;\n      typedef typename _CharT_alloc_traits::const_pointer   const_pointer;\n      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;\n      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\n                                                            const_iterator;\n      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n      typedef std::reverse_iterator<iterator>\t\t    reverse_iterator;\n\n    protected:\n      // type used for positions in insert, erase etc.\n      typedef iterator __const_iterator;\n\n    private:\n      // _Rep: string representation\n      //   Invariants:\n      //   1. String really contains _M_length + 1 characters: due to 21.3.4\n      //      must be kept null-terminated.\n      //   2. _M_capacity >= _M_length\n      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).\n      //   3. _M_refcount has three states:\n      //      -1: leaked, one reference, no ref-copies allowed, non-const.\n      //       0: one reference, non-const.\n      //     n>0: n + 1 references, operations require a lock, const.\n      //   4. All fields==0 is an empty string, given the extra storage\n      //      beyond-the-end for a null terminator; thus, the shared\n      //      empty string representation needs no constructor.\n\n      struct _Rep_base\n      {\n\tsize_type\t\t_M_length;\n\tsize_type\t\t_M_capacity;\n\t_Atomic_word\t\t_M_refcount;\n      };\n\n      struct _Rep : _Rep_base\n      {\n\t// Types:\n\ttypedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n\t  rebind<char>::other _Raw_bytes_alloc;\n\n\t// (Public) Data members:\n\n\t// The maximum number of individual char_type elements of an\n\t// individual string is determined by _S_max_size. This is the\n\t// value that will be returned by max_size().  (Whereas npos\n\t// is the maximum number of bytes the allocator can allocate.)\n\t// If one was to divvy up the theoretical largest size string,\n\t// with a terminating character and m _CharT elements, it'd\n\t// look like this:\n\t// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)\n\t// Solving for m:\n\t// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1\n\t// In addition, this implementation quarters this amount.\n\tstatic const size_type\t_S_max_size;\n\tstatic const _CharT\t_S_terminal;\n\n\t// The following storage is init'd to 0 by the linker, resulting\n        // (carefully) in an empty string with one reference.\n        static size_type _S_empty_rep_storage[];\n\n        static _Rep&\n        _S_empty_rep() _GLIBCXX_NOEXCEPT\n        { \n\t  // NB: Mild hack to avoid strict-aliasing warnings.  Note that\n\t  // _S_empty_rep_storage is never modified and the punning should\n\t  // be reasonably safe in this case.\n\t  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);\n\t  return *reinterpret_cast<_Rep*>(__p);\n\t}\n\n        bool\n\t_M_is_leaked() const _GLIBCXX_NOEXCEPT\n        {\n#if defined(__GTHREADS)\n          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,\n          // so we need to use an atomic load. However, _M_is_leaked\n          // predicate does not change concurrently (i.e. the string is either\n          // leaked or not), so a relaxed load is enough.\n          return __atomic_load_n(&this->_M_refcount, __ATOMIC_RELAXED) < 0;\n#else\n          return this->_M_refcount < 0;\n#endif\n        }\n\n        bool\n\t_M_is_shared() const _GLIBCXX_NOEXCEPT\n\t{\n#if defined(__GTHREADS)\n          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,\n          // so we need to use an atomic load. Another thread can drop last\n          // but one reference concurrently with this check, so we need this\n          // load to be acquire to synchronize with release fetch_and_add in\n          // _M_dispose.\n          return __atomic_load_n(&this->_M_refcount, __ATOMIC_ACQUIRE) > 0;\n#else\n          return this->_M_refcount > 0;\n#endif\n        }\n\n        void\n\t_M_set_leaked() _GLIBCXX_NOEXCEPT\n        { this->_M_refcount = -1; }\n\n        void\n\t_M_set_sharable() _GLIBCXX_NOEXCEPT\n        { this->_M_refcount = 0; }\n\n\tvoid\n\t_M_set_length_and_sharable(size_type __n) _GLIBCXX_NOEXCEPT\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n#endif\n\t    {\n\t      this->_M_set_sharable();  // One reference.\n\t      this->_M_length = __n;\n\t      traits_type::assign(this->_M_refdata()[__n], _S_terminal);\n\t      // grrr. (per 21.3.4)\n\t      // You cannot leave those LWG people alone for a second.\n\t    }\n\t}\n\n\t_CharT*\n\t_M_refdata() throw()\n\t{ return reinterpret_cast<_CharT*>(this + 1); }\n\n\t_CharT*\n\t_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)\n\t{\n\t  return (!_M_is_leaked() && __alloc1 == __alloc2)\n\t          ? _M_refcopy() : _M_clone(__alloc1);\n\t}\n\n\t// Create & Destroy\n\tstatic _Rep*\n\t_S_create(size_type, size_type, const _Alloc&);\n\n\tvoid\n\t_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n#endif\n\t    {\n\t      // Be race-detector-friendly.  For more info see bits/c++config.\n\t      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);\n              // Decrement of _M_refcount is acq_rel, because:\n              // - all but last decrements need to release to synchronize with\n              //   the last decrement that will delete the object.\n              // - the last decrement needs to acquire to synchronize with\n              //   all the previous decrements.\n              // - last but one decrement needs to release to synchronize with\n              //   the acquire load in _M_is_shared that will conclude that\n              //   the object is not shared anymore.\n\t      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,\n\t\t\t\t\t\t\t -1) <= 0)\n\t\t{\n\t\t  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);\n\t\t  _M_destroy(__a);\n\t\t}\n\t    }\n\t}  // XXX MT\n\n\tvoid\n\t_M_destroy(const _Alloc&) throw();\n\n\t_CharT*\n\t_M_refcopy() throw()\n\t{\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n#endif\n            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);\n\t  return _M_refdata();\n\t}  // XXX MT\n\n\t_CharT*\n\t_M_clone(const _Alloc&, size_type __res = 0);\n      };\n\n      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n      struct _Alloc_hider : _Alloc\n      {\n\t_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT\n\t: _Alloc(__a), _M_p(__dat) { }\n\n\t_CharT* _M_p; // The actual data.\n      };\n\n    public:\n      // Data Members (public):\n      // NB: This is an unsigned type, and thus represents the maximum\n      // size that the allocator can hold.\n      ///  Value returned by various member functions when they fail.\n      static const size_type\tnpos = static_cast<size_type>(-1);\n\n    private:\n      // Data Members (private):\n      mutable _Alloc_hider\t_M_dataplus;\n\n      _CharT*\n      _M_data() const _GLIBCXX_NOEXCEPT\n      { return  _M_dataplus._M_p; }\n\n      _CharT*\n      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT\n      { return (_M_dataplus._M_p = __p); }\n\n      _Rep*\n      _M_rep() const _GLIBCXX_NOEXCEPT\n      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }\n\n      // For the internal use we have functions similar to `begin'/`end'\n      // but they do not call _M_leak.\n      iterator\n      _M_ibegin() const _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data()); }\n\n      iterator\n      _M_iend() const _GLIBCXX_NOEXCEPT\n      { return iterator(_M_data() + this->size()); }\n\n      void\n      _M_leak()    // for use in begin() & non-const op[]\n      {\n\tif (!_M_rep()->_M_is_leaked())\n\t  _M_leak_hard();\n      }\n\n      size_type\n      _M_check(size_type __pos, const char* __s) const\n      {\n\tif (__pos > this->size())\n\t  __throw_out_of_range_fmt(__N(\"%s: __pos (which is %zu) > \"\n\t\t\t\t       \"this->size() (which is %zu)\"),\n\t\t\t\t   __s, __pos, this->size());\n\treturn __pos;\n      }\n\n      void\n      _M_check_length(size_type __n1, size_type __n2, const char* __s) const\n      {\n\tif (this->max_size() - (this->size() - __n1) < __n2)\n\t  __throw_length_error(__N(__s));\n      }\n\n      // NB: _M_limit doesn't check for a bad __pos value.\n      size_type\n      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT\n      {\n\tconst bool __testoff =  __off < this->size() - __pos;\n\treturn __testoff ? __off : this->size() - __pos;\n      }\n\n      // True if _Rep and source do not overlap.\n      bool\n      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT\n      {\n\treturn (less<const _CharT*>()(__s, _M_data())\n\t\t|| less<const _CharT*>()(_M_data() + this->size(), __s));\n      }\n\n      // When __n = 1 way faster than the general multichar\n      // traits_type::copy/move/assign.\n      static void\n      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::copy(__d, __s, __n);\n      }\n\n      static void\n      _M_move(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, *__s);\n\telse\n\t  traits_type::move(__d, __s, __n);\t  \n      }\n\n      static void\n      _M_assign(_CharT* __d, size_type __n, _CharT __c) _GLIBCXX_NOEXCEPT\n      {\n\tif (__n == 1)\n\t  traits_type::assign(*__d, __c);\n\telse\n\t  traits_type::assign(__d, __n, __c);\t  \n      }\n\n      // _S_copy_chars is a separate template to permit specialization\n      // to optimize for the common case of pointers as iterators.\n      template<class _Iterator>\n        static void\n        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\n        {\n\t  for (; __k1 != __k2; ++__k1, (void)++__p)\n\t    traits_type::assign(*__p, *__k1); // These types are off.\n\t}\n\n      static void\n      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\n      _GLIBCXX_NOEXCEPT\n      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n\n      static void\n      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT\n      { _M_copy(__p, __k1, __k2 - __k1); }\n\n      static void\n      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\n      _GLIBCXX_NOEXCEPT\n      { _M_copy(__p, __k1, __k2 - __k1); }\n\n      static int\n      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT\n      {\n\tconst difference_type __d = difference_type(__n1 - __n2);\n\n\tif (__d > __gnu_cxx::__numeric_traits<int>::__max)\n\t  return __gnu_cxx::__numeric_traits<int>::__max;\n\telse if (__d < __gnu_cxx::__numeric_traits<int>::__min)\n\t  return __gnu_cxx::__numeric_traits<int>::__min;\n\telse\n\t  return int(__d);\n      }\n\n      void\n      _M_mutate(size_type __pos, size_type __len1, size_type __len2);\n\n      void\n      _M_leak_hard();\n\n      static _Rep&\n      _S_empty_rep() _GLIBCXX_NOEXCEPT\n      { return _Rep::_S_empty_rep(); }\n\n#if __cplusplus >= 201703L\n      // A helper type for avoiding boiler-plate.\n      typedef basic_string_view<_CharT, _Traits> __sv_type;\n\n      template<typename _Tp, typename _Res>\n\tusing _If_sv = enable_if_t<\n\t  __and_<is_convertible<const _Tp&, __sv_type>,\n\t\t __not_<is_convertible<const _Tp*, const basic_string*>>,\n\t\t __not_<is_convertible<const _Tp&, const _CharT*>>>::value,\n\t  _Res>;\n\n      // Allows an implicit conversion to __sv_type.\n      static __sv_type\n      _S_to_string_view(__sv_type __svt) noexcept\n      { return __svt; }\n\n      // Wraps a string_view by explicit conversion and thus\n      // allows to add an internal constructor that does not\n      // participate in overload resolution when a string_view\n      // is provided.\n      struct __sv_wrapper\n      {\n\texplicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }\n\t__sv_type _M_sv;\n      };\n\n      /**\n       *  @brief  Only internally used: Construct string from a string view\n       *          wrapper.\n       *  @param  __svw  string view wrapper.\n       *  @param  __a  Allocator to use.\n       */\n      explicit\n      basic_string(__sv_wrapper __svw, const _Alloc& __a)\n      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }\n#endif\n\n    public:\n      // Construct/copy/destroy:\n      // NB: We overload ctors in some cases instead of using default\n      // arguments, per 17.4.4.4 para. 2 item 2.\n\n      /**\n       *  @brief  Default constructor creates an empty string.\n       */\n      basic_string()\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      _GLIBCXX_NOEXCEPT\n      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc())\n#else\n      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc())\n#endif\n      { }\n\n      /**\n       *  @brief  Construct an empty string using allocator @a a.\n       */\n      explicit\n      basic_string(const _Alloc& __a)\n      : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)\n      { }\n\n      // NB: per LWG issue 42, semantics different from IS:\n      /**\n       *  @brief  Construct string with copy of value of @a str.\n       *  @param  __str  Source string.\n       */\n      basic_string(const basic_string& __str)\n      : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),\n\t\t\t\t\t    __str.get_allocator()),\n\t\t    __str.get_allocator())\n      { }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2583. no way to supply an allocator for basic_string(str, pos)\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   const _Alloc& __a = _Alloc());\n\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n);\n      /**\n       *  @brief  Construct string as copy of a substring.\n       *  @param  __str  Source string.\n       *  @param  __pos  Index of first character to copy from.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use.\n       */\n      basic_string(const basic_string& __str, size_type __pos,\n\t\t   size_type __n, const _Alloc& __a);\n\n      /**\n       *  @brief  Construct string initialized by a character %array.\n       *  @param  __s  Source character %array.\n       *  @param  __n  Number of characters to copy.\n       *  @param  __a  Allocator to use (default is default allocator).\n       *\n       *  NB: @a __s must have at least @a __n characters, &apos;\\\\0&apos;\n       *  has no special meaning.\n       */\n      basic_string(const _CharT* __s, size_type __n,\n\t\t   const _Alloc& __a = _Alloc())\n      : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)\n      { }\n\n      /**\n       *  @brief  Construct string as copy of a C string.\n       *  @param  __s  Source C string.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n#if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3076. basic_string CTAD ambiguity\n      template<typename = _RequireAllocator<_Alloc>>\n#endif\n      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :\n\t\t\t\t __s + npos, __a), __a)\n      { }\n\n      /**\n       *  @brief  Construct string as multiple characters.\n       *  @param  __n  Number of characters.\n       *  @param  __c  Character to use.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_S_construct(__n, __c, __a), __a)\n      { }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move construct string.\n       *  @param  __str  Source string.\n       *\n       *  The newly-created string contains the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       */\n      basic_string(basic_string&& __str)\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      noexcept // FIXME C++11: should always be noexcept.\n#endif\n      : _M_dataplus(std::move(__str._M_dataplus))\n      {\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t__str._M_data(_S_empty_rep()._M_refdata());\n#else\n\t__str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));\n#endif\n      }\n\n      /**\n       *  @brief  Construct string from an initializer %list.\n       *  @param  __l  std::initializer_list of characters.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\n      : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)\n      { }\n\n      basic_string(const basic_string& __str, const _Alloc& __a)\n      : _M_dataplus(__str._M_rep()->_M_grab(__a, __str.get_allocator()), __a)\n      { }\n\n      basic_string(basic_string&& __str, const _Alloc& __a)\n      : _M_dataplus(__str._M_data(), __a)\n      {\n\tif (__a == __str.get_allocator())\n\t  {\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\t    __str._M_data(_S_empty_rep()._M_refdata());\n#else\n\t    __str._M_data(_S_construct(size_type(), _CharT(), __a));\n#endif\n\t  }\n\telse\n\t  _M_dataplus._M_p = _S_construct(__str.begin(), __str.end(), __a);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Construct string as copy of a range.\n       *  @param  __beg  Start of range.\n       *  @param  __end  End of range.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template<class _InputIterator>\n        basic_string(_InputIterator __beg, _InputIterator __end,\n\t\t     const _Alloc& __a = _Alloc())\n\t: _M_dataplus(_S_construct(__beg, __end, __a), __a)\n\t{ }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Construct string from a substring of a string_view.\n       *  @param  __t   Source object convertible to string view.\n       *  @param  __pos The index of the first character to copy from __t.\n       *  @param  __n   The number of characters to copy from __t.\n       *  @param  __a   Allocator to use.\n       */\n      template<typename _Tp,\n\t       typename = enable_if_t<is_convertible_v<const _Tp&, __sv_type>>>\n\tbasic_string(const _Tp& __t, size_type __pos, size_type __n,\n\t\t     const _Alloc& __a = _Alloc())\n\t: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }\n\n      /**\n       *  @brief  Construct string from a string_view.\n       *  @param  __t  Source object convertible to string view.\n       *  @param  __a  Allocator to use (default is default allocator).\n       */\n      template<typename _Tp, typename = _If_sv<_Tp, void>>\n\texplicit\n\tbasic_string(const _Tp& __t, const _Alloc& __a = _Alloc())\n\t: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }\n#endif // C++17\n\n      /**\n       *  @brief  Destroy the string instance.\n       */\n      ~basic_string() _GLIBCXX_NOEXCEPT\n      { _M_rep()->_M_dispose(this->get_allocator()); }\n\n      /**\n       *  @brief  Assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       */\n      basic_string&\n      operator=(const basic_string& __str)\n      { return this->assign(__str); }\n\n      /**\n       *  @brief  Copy contents of @a s into this string.\n       *  @param  __s  Source null-terminated string.\n       */\n      basic_string&\n      operator=(const _CharT* __s) \n      { return this->assign(__s); }\n\n      /**\n       *  @brief  Set value to string of length 1.\n       *  @param  __c  Source character.\n       *\n       *  Assigning to a character makes this string length 1 and\n       *  (*this)[0] == @a c.\n       */\n      basic_string&\n      operator=(_CharT __c) \n      { \n\tthis->assign(1, __c); \n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Move assign the value of @a str to this string.\n       *  @param  __str  Source string.\n       *\n       *  The contents of @a str are moved into this string (without copying).\n       *  @a str is a valid, but unspecified string.\n       */\n      basic_string&\n      operator=(basic_string&& __str)\n      _GLIBCXX_NOEXCEPT_IF(allocator_traits<_Alloc>::is_always_equal::value)\n      {\n\t// NB: DR 1204.\n\tthis->swap(__str);\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Set value to string constructed from initializer %list.\n       *  @param  __l  std::initializer_list.\n       */\n      basic_string&\n      operator=(initializer_list<_CharT> __l)\n      {\n\tthis->assign(__l.begin(), __l.size());\n\treturn *this;\n      }\n#endif // C++11\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Set value to string constructed from a string_view.\n       *  @param  __svt An object convertible to  string_view.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\toperator=(const _Tp& __svt)\n\t{ return this->assign(__svt); }\n\n      /**\n       *  @brief  Convert to a string_view.\n       *  @return A string_view.\n       */\n      operator __sv_type() const noexcept\n      { return __sv_type(data(), size()); }\n#endif // C++17\n\n      // Iterators:\n      /**\n       *  Returns a read/write iterator that points to the first character in\n       *  the %string.  Unshares the string.\n       */\n      iterator\n      begin() // FIXME C++11: should be noexcept.\n      {\n\t_M_leak();\n\treturn iterator(_M_data());\n      }\n\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      begin() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data()); }\n\n      /**\n       *  Returns a read/write iterator that points one past the last\n       *  character in the %string.  Unshares the string.\n       */\n      iterator\n      end() // FIXME C++11: should be noexcept.\n      {\n\t_M_leak();\n\treturn iterator(_M_data() + this->size());\n      }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      end() const _GLIBCXX_NOEXCEPT\n      { return const_iterator(_M_data() + this->size()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to the last\n       *  character in the %string.  Iteration is done in reverse element\n       *  order.  Unshares the string.\n       */\n      reverse_iterator\n      rbegin() // FIXME C++11: should be noexcept.\n      { return reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      rbegin() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read/write reverse iterator that points to one before the\n       *  first character in the %string.  Iteration is done in reverse\n       *  element order.  Unshares the string.\n       */\n      reverse_iterator\n      rend() // FIXME C++11: should be noexcept.\n      { return reverse_iterator(this->begin()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      rend() const _GLIBCXX_NOEXCEPT\n      { return const_reverse_iterator(this->begin()); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read-only (constant) iterator that points to the first\n       *  character in the %string.\n       */\n      const_iterator\n      cbegin() const noexcept\n      { return const_iterator(this->_M_data()); }\n\n      /**\n       *  Returns a read-only (constant) iterator that points one past the\n       *  last character in the %string.\n       */\n      const_iterator\n      cend() const noexcept\n      { return const_iterator(this->_M_data() + this->size()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to the last character in the %string.  Iteration is done in\n       *  reverse element order.\n       */\n      const_reverse_iterator\n      crbegin() const noexcept\n      { return const_reverse_iterator(this->end()); }\n\n      /**\n       *  Returns a read-only (constant) reverse iterator that points\n       *  to one before the first character in the %string.  Iteration\n       *  is done in reverse element order.\n       */\n      const_reverse_iterator\n      crend() const noexcept\n      { return const_reverse_iterator(this->begin()); }\n#endif\n\n    public:\n      // Capacity:\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      size() const _GLIBCXX_NOEXCEPT\n      { return _M_rep()->_M_length; }\n\n      ///  Returns the number of characters in the string, not including any\n      ///  null-termination.\n      size_type\n      length() const _GLIBCXX_NOEXCEPT\n      { return _M_rep()->_M_length; }\n\n      ///  Returns the size() of the largest possible %string.\n      size_type\n      max_size() const _GLIBCXX_NOEXCEPT\n      { return _Rep::_S_max_size; }\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *  @param  __c  Character to fill any new elements.\n       *\n       *  This function will %resize the %string to the specified\n       *  number of characters.  If the number is smaller than the\n       *  %string's current size the %string is truncated, otherwise\n       *  the %string is extended and new elements are %set to @a __c.\n       */\n      void\n      resize(size_type __n, _CharT __c);\n\n      /**\n       *  @brief  Resizes the %string to the specified number of characters.\n       *  @param  __n  Number of characters the %string should contain.\n       *\n       *  This function will resize the %string to the specified length.  If\n       *  the new size is smaller than the %string's current size the %string\n       *  is truncated, otherwise the %string is extended and new characters\n       *  are default-constructed.  For basic types such as char, this means\n       *  setting them to 0.\n       */\n      void\n      resize(size_type __n)\n      { this->resize(__n, _CharT()); }\n\n#if __cplusplus >= 201103L\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n      ///  A non-binding request to reduce capacity() to size().\n      void\n      shrink_to_fit() noexcept\n      { reserve(); }\n#pragma GCC diagnostic pop\n#endif\n\n      /**\n       *  Returns the total number of characters that the %string can hold\n       *  before needing to allocate more memory.\n       */\n      size_type\n      capacity() const _GLIBCXX_NOEXCEPT\n      { return _M_rep()->_M_capacity; }\n\n      /**\n       *  @brief  Attempt to preallocate enough memory for specified number of\n       *          characters.\n       *  @param  __res_arg  Number of characters required.\n       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().\n       *\n       *  This function attempts to reserve enough memory for the\n       *  %string to hold the specified number of characters.  If the\n       *  number requested is more than max_size(), length_error is\n       *  thrown.\n       *\n       *  The advantage of this function is that if optimal code is a\n       *  necessity and the user can determine the string length that will be\n       *  required, the user can reserve the memory in %advance, and thus\n       *  prevent a possible reallocation of memory and copying of %string\n       *  data.\n       */\n      void\n      reserve(size_type __res_arg);\n\n      /// Equivalent to shrink_to_fit().\n#if __cplusplus > 201703L\n      [[deprecated(\"use shrink_to_fit() instead\")]]\n#endif\n      void\n      reserve();\n\n      /**\n       *  Erases the string, making it empty.\n       */\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      void\n      clear() _GLIBCXX_NOEXCEPT\n      {\n\tif (_M_rep()->_M_is_shared())\n\t  {\n\t    _M_rep()->_M_dispose(this->get_allocator());\n\t    _M_data(_S_empty_rep()._M_refdata());\n\t  }\n\telse\n\t  _M_rep()->_M_set_length_and_sharable(0);\n      }\n#else\n      // PR 56166: this should not throw.\n      void\n      clear()\n      { _M_mutate(0, this->size(), 0); }\n#endif\n\n      /**\n       *  Returns true if the %string is empty.  Equivalent to \n       *  <code>*this == \"\"</code>.\n       */\n      _GLIBCXX_NODISCARD bool\n      empty() const _GLIBCXX_NOEXCEPT\n      { return this->size() == 0; }\n\n      // Element access:\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read-only (constant) reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)\n       */\n      const_reference\n      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_assert(__pos <= size());\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Subscript access to the data contained in the %string.\n       *  @param  __pos  The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *\n       *  This operator allows for easy, array-style, data access.\n       *  Note that data access with this operator is unchecked and\n       *  out_of_range lookups are not defined. (For checked lookups\n       *  see at().)  Unshares the string.\n       */\n      reference\n      operator[](size_type __pos)\n      {\n        // Allow pos == size() both in C++98 mode, as v3 extension,\n\t// and in C++11 mode.\n\t__glibcxx_assert(__pos <= size());\n        // In pedantic mode be strict in C++98 mode.\n\t_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());\n\t_M_leak();\n\treturn _M_data()[__pos];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read-only (const) reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.\n       */\n      const_reference\n      at(size_type __n) const\n      {\n\tif (__n >= this->size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\treturn _M_data()[__n];\n      }\n\n      /**\n       *  @brief  Provides access to the data contained in the %string.\n       *  @param __n The index of the character to access.\n       *  @return  Read/write reference to the character.\n       *  @throw  std::out_of_range  If @a n is an invalid index.\n       *\n       *  This function provides for safer data access.  The parameter is\n       *  first checked that it is in the range of the string.  The function\n       *  throws out_of_range if the check fails.  Success results in\n       *  unsharing the string.\n       */\n      reference\n      at(size_type __n)\n      {\n\tif (__n >= size())\n\t  __throw_out_of_range_fmt(__N(\"basic_string::at: __n \"\n\t\t\t\t       \"(which is %zu) >= this->size() \"\n\t\t\t\t       \"(which is %zu)\"),\n\t\t\t\t   __n, this->size());\n\t_M_leak();\n\treturn _M_data()[__n];\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  Returns a read/write reference to the data at the first\n       *  element of the %string.\n       */\n      reference\n      front()\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the first\n       *  element of the %string.\n       */\n      const_reference\n      front() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](0);\n      }\n\n      /**\n       *  Returns a read/write reference to the data at the last\n       *  element of the %string.\n       */\n      reference\n      back()\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n\n      /**\n       *  Returns a read-only (constant) reference to the data at the\n       *  last element of the %string.\n       */\n      const_reference\n      back() const noexcept\n      {\n\t__glibcxx_assert(!empty());\n\treturn operator[](this->size() - 1);\n      }\n#endif\n\n      // Modifiers:\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const basic_string& __str)\n      { return this->append(__str); }\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(const _CharT* __s)\n      { return this->append(__s); }\n\n      /**\n       *  @brief  Append a character.\n       *  @param __c  The character to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(_CharT __c)\n      { \n\tthis->push_back(__c);\n\treturn *this;\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to be appended.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      operator+=(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt The object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\toperator+=(const _Tp& __svt)\n\t{ return this->append(__svt); }\n#endif // C++17\n\n      /**\n       *  @brief  Append a string to this string.\n       *  @param __str  The string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const basic_string& __str);\n\n      /**\n       *  @brief  Append a substring.\n       *  @param __str  The string to append.\n       *  @param __pos  Index of the first character of str to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a __pos is not a valid index.\n       *\n       *  This function appends @a __n characters from @a __str\n       *  starting at @a __pos to this string.  If @a __n is is larger\n       *  than the number of available characters in @a __str, the\n       *  remainder of @a __str is appended.\n       */\n      basic_string&\n      append(const basic_string& __str, size_type __pos, size_type __n = npos);\n\n      /**\n       *  @brief  Append a C substring.\n       *  @param __s  The C string to append.\n       *  @param __n  The number of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s, size_type __n);\n\n      /**\n       *  @brief  Append a C string.\n       *  @param __s  The C string to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->append(__s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Append multiple characters.\n       *  @param __n  The number of characters to append.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  Appends __n copies of __c to this string.\n       */\n      basic_string&\n      append(size_type __n, _CharT __c);\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Append an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to append.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      append(initializer_list<_CharT> __l)\n      { return this->append(__l.begin(), __l.size()); }\n#endif // C++11\n\n      /**\n       *  @brief  Append a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Appends characters in the range [__first,__last) to this string.\n       */\n      template<class _InputIterator>\n        basic_string&\n        append(_InputIterator __first, _InputIterator __last)\n        { return this->replace(_M_iend(), _M_iend(), __first, __last); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Append a string_view.\n       *  @param __svt The object convertible to string_view to be appended.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tappend(const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->append(__sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Append a range of characters from a string_view.\n       *  @param __svt The object convertible to string_view to be appended\n       *               from.\n       *  @param __pos The position in the string_view to append from.\n       *  @param __n   The number of characters to append from the string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n\tappend(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return append(__sv.data()\n\t      + std::__sv_check(__sv.size(), __pos, \"basic_string::append\"),\n\t      std::__sv_limit(__sv.size(), __pos, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Append a single character.\n       *  @param __c  Character to append.\n       */\n      void\n      push_back(_CharT __c)\n      { \n\tconst size_type __len = 1 + this->size();\n\tif (__len > this->capacity() || _M_rep()->_M_is_shared())\n\t  this->reserve(__len);\n\ttraits_type::assign(_M_data()[this->size()], __c);\n\t_M_rep()->_M_set_length_and_sharable(__len);\n      }\n\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(const basic_string& __str);\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to contents of another string.\n       *  @param  __str  Source string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets this string to the exact contents of @a __str.\n       *  @a __str is a valid, but unspecified string.\n       */\n      basic_string&\n      assign(basic_string&& __str)\n      noexcept(allocator_traits<_Alloc>::is_always_equal::value)\n      {\n\tthis->swap(__str);\n\treturn *this;\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Set value to a substring of a string.\n       *  @param __str  The string to use.\n       *  @param __pos  Index of the first character of str.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range if @a pos is not a valid index.\n       *\n       *  This function sets this string to the substring of @a __str\n       *  consisting of @a __n characters at @a __pos.  If @a __n is\n       *  is larger than the number of available characters in @a\n       *  __str, the remainder of @a __str is used.\n       */\n      basic_string&\n      assign(const basic_string& __str, size_type __pos, size_type __n = npos)\n      { return this->assign(__str._M_data()\n\t\t\t    + __str._M_check(__pos, \"basic_string::assign\"),\n\t\t\t    __str._M_limit(__pos, __n)); }\n\n      /**\n       *  @brief  Set value to a C substring.\n       *  @param __s  The C string to use.\n       *  @param __n  Number of characters to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the first @a __n\n       *  characters of @a __s.  If @a __n is is larger than the number of\n       *  available characters in @a __s, the remainder of @a __s is used.\n       */\n      basic_string&\n      assign(const _CharT* __s, size_type __n);\n\n      /**\n       *  @brief  Set value to contents of a C string.\n       *  @param __s  The C string to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to the value of @a __s.\n       *  The data is copied, so there is no dependence on @a __s once the\n       *  function returns.\n       */\n      basic_string&\n      assign(const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->assign(__s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Set value to multiple characters.\n       *  @param __n  Length of the resulting string.\n       *  @param __c  The character to use.\n       *  @return  Reference to this string.\n       *\n       *  This function sets the value of this string to @a __n copies of\n       *  character @a __c.\n       */\n      basic_string&\n      assign(size_type __n, _CharT __c)\n      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }\n\n      /**\n       *  @brief  Set value to a range of characters.\n       *  @param __first  Iterator referencing the first character to append.\n       *  @param __last  Iterator marking the end of the range.\n       *  @return  Reference to this string.\n       *\n       *  Sets value of string to characters in the range [__first,__last).\n      */\n      template<class _InputIterator>\n        basic_string&\n        assign(_InputIterator __first, _InputIterator __last)\n        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Set value to an initializer_list of characters.\n       *  @param __l  The initializer_list of characters to assign.\n       *  @return  Reference to this string.\n       */\n      basic_string&\n      assign(initializer_list<_CharT> __l)\n      { return this->assign(__l.begin(), __l.size()); }\n#endif // C++11\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Set value from a string_view.\n       *  @param __svt The source object convertible to string_view.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tassign(const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->assign(__sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Set value from a range of characters in a string_view.\n       *  @param __svt  The source object convertible to string_view.\n       *  @param __pos  The position in the string_view to assign from.\n       *  @param __n  The number of characters to assign.\n       *  @return  Reference to this string.\n       */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        assign(const _Tp& __svt, size_type __pos, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return assign(__sv.data()\n\t      + std::__sv_check(__sv.size(), __pos, \"basic_string::assign\"),\n\t      std::__sv_limit(__sv.size(), __pos, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts @a __n copies of character @a __c starting at the\n       *  position referenced by iterator @a __p.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      void\n      insert(iterator __p, size_type __n, _CharT __c)\n      {\tthis->replace(__p, __p, __n, __c);  }\n\n      /**\n       *  @brief  Insert a range of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __beg  Start of range.\n       *  @param __end  End of range.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts characters in range [__beg,__end).  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      template<class _InputIterator>\n        void\n        insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n        { this->replace(__p, __p, __beg, __end); }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Insert an initializer_list of characters.\n       *  @param __p  Iterator referencing location in string to insert at.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       */\n      void\n      insert(iterator __p, initializer_list<_CharT> __l)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());\n\tthis->insert(__p - _M_ibegin(), __l.begin(), __l.size());\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Insert value of a string.\n       *  @param __pos1  Position in string to insert at.\n       *  @param __str  The string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts value of @a __str starting at @a __pos1.  If adding\n       *  characters causes the length to exceed max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str)\n      { return this->insert(__pos1, __str, size_type(0), __str.size()); }\n\n      /**\n       *  @brief  Insert a substring.\n       *  @param __pos1  Position in string to insert at.\n       *  @param __str  The string to insert.\n       *  @param __pos2  Start of characters in str to insert.\n       *  @param __n  Number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos1 > size() or\n       *  @a __pos2 > @a str.size().\n       *\n       *  Starting at @a pos1, insert @a __n character of @a __str\n       *  beginning with @a __pos2.  If adding characters causes the\n       *  length to exceed max_size(), length_error is thrown.  If @a\n       *  __pos1 is beyond the end of this string or @a __pos2 is\n       *  beyond the end of @a __str, out_of_range is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos1, const basic_string& __str,\n\t     size_type __pos2, size_type __n = npos)\n      { return this->insert(__pos1, __str._M_data()\n\t\t\t    + __str._M_check(__pos2, \"basic_string::insert\"),\n\t\t\t    __str._M_limit(__pos2, __n)); }\n\n      /**\n       *  @brief  Insert a C substring.\n       *  @param __pos  Position in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @param __n  The number of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a __n characters of @a __s starting at @a\n       *  __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos is beyond\n       *  end(), out_of_range is thrown.  The value of the string\n       *  doesn't change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s, size_type __n);\n\n      /**\n       *  @brief  Insert a C string.\n       *  @param __pos  Position in string to insert at.\n       *  @param __s  The C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If\n       *  adding characters causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is\n       *  thrown.  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      insert(size_type __pos, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->insert(__pos, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Insert multiple characters.\n       *  @param __pos  Index in string to insert at.\n       *  @param __n  Number of characters to insert\n       *  @param __c  The character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *  @throw  std::out_of_range  If @a __pos is beyond the end of this\n       *  string.\n       *\n       *  Inserts @a __n copies of character @a __c starting at index\n       *  @a __pos.  If adding characters causes the length to exceed\n       *  max_size(), length_error is thrown.  If @a __pos > length(),\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      insert(size_type __pos, size_type __n, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::insert\"),\n\t\t\t      size_type(0), __n, __c); }\n\n      /**\n       *  @brief  Insert one character.\n       *  @param __p  Iterator referencing position in string to insert at.\n       *  @param __c  The character to insert.\n       *  @return  Iterator referencing newly inserted char.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Inserts character @a __c at position referenced by @a __p.\n       *  If adding character causes the length to exceed max_size(),\n       *  length_error is thrown.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      iterator\n      insert(iterator __p, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());\n\tconst size_type __pos = __p - _M_ibegin();\n\t_M_replace_aux(__pos, size_type(0), size_type(1), __c);\n\t_M_rep()->_M_set_leaked();\n\treturn iterator(_M_data() + __pos);\n      }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos  Position in string to insert at.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\tinsert(size_type __pos, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->insert(__pos, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Insert a string_view.\n       *  @param __pos1  Position in string to insert at.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @param __pos2  Position in string_view to insert from.\n       *  @param __n    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        insert(size_type __pos1, const _Tp& __svt,\n\t       size_type __pos2, size_type __n = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, size_type(0), __sv.data()\n\t      + std::__sv_check(__sv.size(), __pos2, \"basic_string::insert\"),\n\t      std::__sv_limit(__sv.size(), __pos2, __n));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Remove characters.\n       *  @param __pos  Index of first character to remove (default 0).\n       *  @param __n  Number of characters to remove (default remainder).\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *\n       *  Removes @a __n characters from this string starting at @a\n       *  __pos.  The length of the string is reduced by @a __n.  If\n       *  there are < @a __n characters to remove, the remainder of\n       *  the string is truncated.  If @a __p is beyond end of string,\n       *  out_of_range is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      erase(size_type __pos = 0, size_type __n = npos)\n      { \n\t_M_mutate(_M_check(__pos, \"basic_string::erase\"),\n\t\t  _M_limit(__pos, __n), size_type(0));\n\treturn *this;\n      }\n\n      /**\n       *  @brief  Remove one character.\n       *  @param __position  Iterator referencing the character to remove.\n       *  @return  iterator referencing same location after removal.\n       *\n       *  Removes the character at @a __position from this string. The value\n       *  of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(iterator __position)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()\n\t\t\t\t && __position < _M_iend());\n\tconst size_type __pos = __position - _M_ibegin();\n\t_M_mutate(__pos, size_type(1), size_type(0));\n\t_M_rep()->_M_set_leaked();\n\treturn iterator(_M_data() + __pos);\n      }\n\n      /**\n       *  @brief  Remove a range of characters.\n       *  @param __first  Iterator referencing the first character to remove.\n       *  @param __last  Iterator referencing the end of the range.\n       *  @return  Iterator referencing location of first after removal.\n       *\n       *  Removes the characters in the range [first,last) from this string.\n       *  The value of the string doesn't change if an error is thrown.\n      */\n      iterator\n      erase(iterator __first, iterator __last);\n \n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Remove the last character.\n       *\n       *  The string must be non-empty.\n       */\n      void\n      pop_back() // FIXME C++11: should be noexcept.\n      {\n\t__glibcxx_assert(!empty());\n\terase(size() - 1, 1);\n      }\n#endif // C++11\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos is beyond the end of this\n       *  string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos+__n) from\n       *  this string.  In place, the value of @a __str is inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of the result exceeds max_size(), length_error\n       *  is thrown.  The value of the string doesn't change if an\n       *  error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n, const basic_string& __str)\n      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace characters with value from another string.\n       *  @param __pos1  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __str  String to insert.\n       *  @param __pos2  Index of first character of str to use.\n       *  @param __n2  Number of characters from str to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >\n       *  __str.size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos1,__pos1 + n) from this\n       *  string.  In place, the value of @a __str is inserted.  If @a __pos is\n       *  beyond end of string, out_of_range is thrown.  If the length of the\n       *  result exceeds max_size(), length_error is thrown.  The value of the\n       *  string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos)\n      { return this->replace(__pos1, __n1, __str._M_data()\n\t\t\t     + __str._M_check(__pos2, \"basic_string::replace\"),\n\t\t\t     __str._M_limit(__pos2, __n2)); }\n\n      /**\n       *  @brief  Replace characters with value of a C substring.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @param __n2  Number of characters from @a s to use.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos1 > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the first @a __n2 characters of\n       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If\n       *  @a __pos is beyond end of string, out_of_range is thrown.  If\n       *  the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2);\n\n      /**\n       *  @brief  Replace characters with value of a C string.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __s  C string to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__pos,__pos + __n1)\n       *  from this string.  In place, the characters of @a __s are\n       *  inserted.  If @a __pos is beyond end of string, out_of_range\n       *  is thrown.  If the length of result exceeds max_size(),\n       *  length_error is thrown.  The value of the string doesn't\n       *  change if an error is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__pos, __n1, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace characters with multiple characters.\n       *  @param __pos  Index of first character to replace.\n       *  @param __n1  Number of characters to be replaced.\n       *  @param __n2  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::out_of_range  If @a __pos > size().\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [pos,pos + n1) from this\n       *  string.  In place, @a __n2 copies of @a __c are inserted.\n       *  If @a __pos is beyond end of string, out_of_range is thrown.\n       *  If the length of result exceeds max_size(), length_error is\n       *  thrown.  The value of the string doesn't change if an error\n       *  is thrown.\n      */\n      basic_string&\n      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n      { return _M_replace_aux(_M_check(__pos, \"basic_string::replace\"),\n\t\t\t      _M_limit(__pos, __n1), __n2, __c); }\n\n      /**\n       *  @brief  Replace range of characters with string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __str  String value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the value of @a __str is inserted.  If the length of result\n       *  exceeds max_size(), length_error is thrown.  The value of\n       *  the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, const basic_string& __str)\n      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n\n      /**\n       *  @brief  Replace range of characters with C substring.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @param __n  Number of characters from s to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the first @a __n characters of @a __s are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);\n      }\n\n      /**\n       *  @brief  Replace range of characters with C string.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __s  C string value to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  the characters of @a __s are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, const _CharT* __s)\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->replace(__i1, __i2, __s, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Replace range of characters with multiple characters\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __n  Number of characters to insert.\n       *  @param __c  Character to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  @a __n copies of @a __c are inserted.  If the length of\n       *  result exceeds max_size(), length_error is thrown.  The\n       *  value of the string doesn't change if an error is thrown.\n      */\n      basic_string&\n      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\treturn _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);\n      }\n\n      /**\n       *  @brief  Replace range of characters with range.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __k1  Iterator referencing start of range to insert.\n       *  @param __k2  Iterator referencing end of range to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      template<class _InputIterator>\n        basic_string&\n        replace(iterator __i1, iterator __i2,\n\t\t_InputIterator __k1, _InputIterator __k2)\n        {\n\t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t   && __i2 <= _M_iend());\n\t  __glibcxx_requires_valid_range(__k1, __k2);\n\t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());\n\t}\n\n      // Specializations for the common case of pointer and iterator:\n      // useful to avoid the overhead of temporary buffering in _M_replace.\n      basic_string&\n      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(iterator __i1, iterator __i2,\n\t      const _CharT* __k1, const _CharT* __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1, __k2 - __k1);\n      }\n\n      basic_string&\n      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n      basic_string&\n      replace(iterator __i1, iterator __i2,\n\t      const_iterator __k1, const_iterator __k2)\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n\t\t\t\t && __i2 <= _M_iend());\n\t__glibcxx_requires_valid_range(__k1, __k2);\n\treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n\t\t\t     __k1.base(), __k2 - __k1);\n      }\n\n#if __cplusplus >= 201103L\n      /**\n       *  @brief  Replace range of characters with initializer_list.\n       *  @param __i1  Iterator referencing start of range to replace.\n       *  @param __i2  Iterator referencing end of range to replace.\n       *  @param __l  The initializer_list of characters to insert.\n       *  @return  Reference to this string.\n       *  @throw  std::length_error  If new length exceeds @c max_size().\n       *\n       *  Removes the characters in the range [__i1,__i2).  In place,\n       *  characters in the range [__k1,__k2) are inserted.  If the\n       *  length of result exceeds max_size(), length_error is thrown.\n       *  The value of the string doesn't change if an error is\n       *  thrown.\n      */\n      basic_string& replace(iterator __i1, iterator __i2,\n\t\t\t    initializer_list<_CharT> __l)\n      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }\n#endif // C++11\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos  The position to replace at.\n       *  @param __n    The number of characters to replace.\n       *  @param __svt  The object convertible to string_view to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(size_type __pos, size_type __n, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos, __n, __sv.data(), __sv.size());\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __pos1  The position to replace at.\n       *  @param __n1    The number of characters to replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @param __pos2  The position in the string_view to insert from.\n       *  @param __n2    The number of characters to insert.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n        _If_sv<_Tp, basic_string&>\n        replace(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__pos1, __n1,\n\t      __sv.data()\n\t      + std::__sv_check(__sv.size(), __pos2, \"basic_string::replace\"),\n\t      std::__sv_limit(__sv.size(), __pos2, __n2));\n\t}\n\n      /**\n       *  @brief  Replace range of characters with string_view.\n       *  @param __i1    An iterator referencing the start position\n          to replace at.\n       *  @param __i2    An iterator referencing the end position\n          for the replace.\n       *  @param __svt   The object convertible to string_view to insert from.\n       *  @return  Reference to this string.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, basic_string&>\n\treplace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->replace(__i1 - begin(), __i2 - __i1, __sv);\n\t}\n#endif // C++17\n\n    private:\n      template<class _Integer>\n\tbasic_string&\n\t_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,\n\t\t\t    _Integer __val, __true_type)\n        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }\n\n      template<class _InputIterator>\n\tbasic_string&\n\t_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\n\t\t\t    _InputIterator __k2, __false_type);\n\n      basic_string&\n      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t     _CharT __c);\n\n      basic_string&\n      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,\n\t\t      size_type __n2);\n\n      // _S_construct_aux is used to implement the 21.3.1 para 15 which\n      // requires special behaviour if _InIter is an integral type\n      template<class _InIterator>\n        static _CharT*\n        _S_construct_aux(_InIterator __beg, _InIterator __end,\n\t\t\t const _Alloc& __a, __false_type)\n\t{\n          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;\n          return _S_construct(__beg, __end, __a, _Tag());\n\t}\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 438. Ambiguity in the \"do the right thing\" clause\n      template<class _Integer>\n        static _CharT*\n        _S_construct_aux(_Integer __beg, _Integer __end,\n\t\t\t const _Alloc& __a, __true_type)\n        { return _S_construct_aux_2(static_cast<size_type>(__beg),\n\t\t\t\t    __end, __a); }\n\n      static _CharT*\n      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)\n      { return _S_construct(__req, __c, __a); }\n\n      template<class _InIterator>\n        static _CharT*\n        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)\n\t{\n\t  typedef typename std::__is_integer<_InIterator>::__type _Integral;\n\t  return _S_construct_aux(__beg, __end, __a, _Integral());\n        }\n\n      // For Input Iterators, used in istreambuf_iterators, etc.\n      template<class _InIterator>\n        static _CharT*\n         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\n\t\t      input_iterator_tag);\n\n      // For forward_iterators up to random_access_iterators, used for\n      // string::iterator, _CharT*, etc.\n      template<class _FwdIterator>\n        static _CharT*\n        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,\n\t\t     forward_iterator_tag);\n\n      static _CharT*\n      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);\n\n    public:\n\n      /**\n       *  @brief  Copy substring into C string.\n       *  @param __s  C string to copy value into.\n       *  @param __n  Number of characters to copy.\n       *  @param __pos  Index of first character to copy.\n       *  @return  Number of characters actually copied\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Copies up to @a __n characters starting at @a __pos into the\n       *  C string @a __s.  If @a __pos is %greater than size(),\n       *  out_of_range is thrown.\n      */\n      size_type\n      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n\n      /**\n       *  @brief  Swap contents with another string.\n       *  @param __s  String to swap with.\n       *\n       *  Exchanges the contents of this string with that of @a __s in constant\n       *  time.\n      */\n      void\n      swap(basic_string& __s)\n      _GLIBCXX_NOEXCEPT_IF(allocator_traits<_Alloc>::is_always_equal::value);\n\n      // String operations:\n      /**\n       *  @brief  Return const pointer to null-terminated contents.\n       *\n       *  This is a handle to internal data.  Do not modify or dire things may\n       *  happen.\n      */\n      const _CharT*\n      c_str() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n      /**\n       *  @brief  Return const pointer to contents.\n       *\n       *  This is a pointer to internal data.  It is undefined to modify\n       *  the contents through the returned pointer. To get a pointer that\n       *  allows modifying the contents use @c &str[0] instead,\n       *  (or in C++17 the non-const @c str.data() overload).\n      */\n      const _CharT*\n      data() const _GLIBCXX_NOEXCEPT\n      { return _M_data(); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Return non-const pointer to contents.\n       *\n       *  This is a pointer to the character sequence held by the string.\n       *  Modifying the characters in the sequence is allowed.\n      */\n      _CharT*\n      data() noexcept\n      {\n\t_M_leak();\n\treturn _M_data();\n      }\n#endif\n\n      /**\n       *  @brief  Return copy of allocator used to construct this string.\n      */\n      allocator_type\n      get_allocator() const _GLIBCXX_NOEXCEPT\n      { return _M_dataplus; }\n\n      /**\n       *  @brief  Find position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from @a s to search for.\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for value of @a __str within\n       *  this string.  If found, returns the index where it begins.  If not\n       *  found, returns npos.\n      */\n      size_type\n      find(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the value of @a\n       *  __s within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of start of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a string.\n       *  @param __str  String to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for value of @a\n       *  __str within this string.  If found, returns the index where\n       *  it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->rfind(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a C substring.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of start of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the first @a\n       *  __n characters in @a __s within this string.  If found,\n       *  returns the index where it begins.  If not found, returns\n       *  npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a C string.\n       *  @param __s  C string to locate.\n       *  @param __pos  Index of character to start search at (default end).\n       *  @return  Index of start of  last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for the value of\n       *  @a __s within this string.  If found, returns the index\n       *  where it begins.  If not found, returns npos.\n      */\n      size_type\n      rfind(const _CharT* __s, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->rfind(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find last position of a string_view.\n       *  @param __svt  The object convertible to string_view to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of start of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\trfind(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->rfind(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_first_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a character of C substring.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character of C string.\n       *  @param __s  String containing characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for the character\n       *  @a __c within this string.  If found, returns the index\n       *  where it was found.  If not found, returns npos.\n       *\n       *  Note: equivalent to find(__c, __pos).\n      */\n      size_type\n      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT\n      { return this->find(__c, __pos); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find position of a character of a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __str  String containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a character of C substring.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to search for.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  first @a __n characters of @a __s within this string.  If\n       *  found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n      _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find last position of a character of C string.\n       *  @param __s  C string containing characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for one of the\n       *  characters of @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_last_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a character.\n       *  @param __c  Character to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for @a __c within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n       *\n       *  Note: equivalent to rfind(__c, __pos).\n      */\n      size_type\n      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT\n      { return this->rfind(__c, __pos); }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find last position of a character of string.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to locate.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n      */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not contained\n       *  in @a __str within this string.  If found, returns the index where it\n       *  was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from.\n       *  @param __n  Number of characters from __s to consider.\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in the first @a __n characters of @a __s within\n       *  this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos,\n\t\t\tsize_type __n) const _GLIBCXX_NOEXCEPT;\n\n      /**\n       *  @brief  Find position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character not\n       *  contained in @a __s within this string.  If found, returns\n       *  the index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_first_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       *\n       *  Starting from @a __pos, searches forward for a character\n       *  other than @a __c within this string.  If found, returns the\n       *  index where it was found.  If not found, returns npos.\n      */\n      size_type\n      find_first_not_of(_CharT __c, size_type __pos = 0) const\n      _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find position of a character not in a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search from (default 0).\n       *  @return  Index of first occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_first_not_of(const _Tp& __svt, size_type __pos = 0) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_first_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Find last position of a character not in string.\n       *  @param __str  String containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __str within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n\n      /**\n       *  @brief  Find last position of a character not in C substring.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from.\n       *  @param __n  Number of characters from s to consider.\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character not\n       *  contained in the first @a __n characters of @a __s within this string.\n       *  If found, returns the index where it was found.  If not found,\n       *  returns npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos,\n\t\t       size_type __n) const _GLIBCXX_NOEXCEPT;\n      /**\n       *  @brief  Find last position of a character not in C string.\n       *  @param __s  C string containing characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character\n       *  not contained in @a __s within this string.  If found,\n       *  returns the index where it was found.  If not found, returns\n       *  npos.\n      */\n      size_type\n      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT\n      {\n\t__glibcxx_requires_string(__s);\n\treturn this->find_last_not_of(__s, __pos, traits_type::length(__s));\n      }\n\n      /**\n       *  @brief  Find last position of a different character.\n       *  @param __c  Character to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       *\n       *  Starting from @a __pos, searches backward for a character other than\n       *  @a __c within this string.  If found, returns the index where it was\n       *  found.  If not found, returns npos.\n      */\n      size_type\n      find_last_not_of(_CharT __c, size_type __pos = npos) const\n      _GLIBCXX_NOEXCEPT;\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Find last position of a character not in a string_view.\n       *  @param __svt  An object convertible to string_view containing\n       *                characters to avoid.\n       *  @param __pos  Index of character to search back from (default end).\n       *  @return  Index of last occurrence.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, size_type>\n\tfind_last_not_of(const _Tp& __svt, size_type __pos = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return this->find_last_not_of(__sv.data(), __pos, __sv.size());\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Get a substring.\n       *  @param __pos  Index of first character (default 0).\n       *  @param __n  Number of characters in substring (default remainder).\n       *  @return  The new string.\n       *  @throw  std::out_of_range  If __pos > size().\n       *\n       *  Construct and return a new string using the @a __n\n       *  characters starting at @a __pos.  If the string is too\n       *  short, use the remainder of the characters.  If @a __pos is\n       *  beyond the end of the string, out_of_range is thrown.\n      */\n      basic_string\n      substr(size_type __pos = 0, size_type __n = npos) const\n      { return basic_string(*this,\n\t\t\t    _M_check(__pos, \"basic_string::substr\"), __n); }\n\n      /**\n       *  @brief  Compare to a string.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a\n       *  __str, 0 if their values are equivalent, or > 0 if this\n       *  string is ordered after @a __str.  Determines the effective\n       *  length rlen of the strings to compare as the smallest of\n       *  size() and str.size().  The function then compares the two\n       *  strings by calling traits::compare(data(), str.data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(const basic_string& __str) const\n      {\n\tconst size_type __size = this->size();\n\tconst size_type __osize = __str.size();\n\tconst size_type __len = std::min(__size, __osize);\n\n\tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n\tif (!__r)\n\t  __r = _S_compare(__size, __osize);\n\treturn __r;\n      }\n\n#if __cplusplus >= 201703L\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __svt An object convertible to string_view to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t   __sv_type __sv = __svt;\n\t  const size_type __size = this->size();\n\t  const size_type __osize = __sv.size();\n\t  const size_type __len = std::min(__size, __osize);\n\n\t  int __r = traits_type::compare(_M_data(), __sv.data(), __len);\n\t  if (!__r)\n\t    __r = _S_compare(__size, __osize);\n\t  return __r;\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos  A position in the string to start comparing from.\n       *  @param __n  The number of characters to compare.\n       *  @param __svt  An object convertible to string_view to compare\n       *                against.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos, size_type __n, const _Tp& __svt) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this).substr(__pos, __n).compare(__sv);\n\t}\n\n      /**\n       *  @brief  Compare to a string_view.\n       *  @param __pos1  A position in the string to start comparing from.\n       *  @param __n1  The number of characters to compare.\n       *  @param __svt   An object convertible to string_view to compare\n       *                 against.\n       *  @param __pos2  A position in the string_view to start comparing from.\n       *  @param __n2  The number of characters to compare.\n       *  @return  Integer < 0, 0, or > 0.\n       */\n      template<typename _Tp>\n\t_If_sv<_Tp, int>\n\tcompare(size_type __pos1, size_type __n1, const _Tp& __svt,\n\t\tsize_type __pos2, size_type __n2 = npos) const\n\tnoexcept(is_same<_Tp, __sv_type>::value)\n\t{\n\t  __sv_type __sv = __svt;\n\t  return __sv_type(*this)\n\t    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n\t}\n#endif // C++17\n\n      /**\n       *  @brief  Compare substring to a string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n characters\n       *  starting at @a __pos.  Returns an integer < 0 if the\n       *  substring is ordered before @a __str, 0 if their values are\n       *  equivalent, or > 0 if the substring is ordered after @a\n       *  __str.  Determines the effective length rlen of the strings\n       *  to compare as the smallest of the length of the substring\n       *  and @a __str.size().  The function then compares the two\n       *  strings by calling\n       *  traits::compare(substring.data(),str.data(),rlen).  If the\n       *  result of the comparison is nonzero returns it, otherwise\n       *  the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n, const basic_string& __str) const;\n\n      /**\n       *  @brief  Compare substring to a substring.\n       *  @param __pos1  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __str  String to compare against.\n       *  @param __pos2  Index of first character of substring of str.\n       *  @param __n2  Number of characters in substring of str.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos1.  Form the substring of @a\n       *  __str from the @a __n2 characters starting at @a __pos2.\n       *  Returns an integer < 0 if this substring is ordered before\n       *  the substring of @a __str, 0 if their values are equivalent,\n       *  or > 0 if this substring is ordered after the substring of\n       *  @a __str.  Determines the effective length rlen of the\n       *  strings to compare as the smallest of the lengths of the\n       *  substrings.  The function then compares the two strings by\n       *  calling\n       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).\n       *  If the result of the comparison is nonzero returns it,\n       *  otherwise the shorter one is ordered first.\n      */\n      int\n      compare(size_type __pos1, size_type __n1, const basic_string& __str,\n\t      size_type __pos2, size_type __n2 = npos) const;\n\n      /**\n       *  @brief  Compare to a C string.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if\n       *  their values are equivalent, or > 0 if this string is ordered after\n       *  @a __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of size() and the length of a string\n       *  constructed from @a __s.  The function then compares the two strings\n       *  by calling traits::compare(data(),s,rlen).  If the result of the\n       *  comparison is nonzero returns it, otherwise the shorter one is\n       *  ordered first.\n      */\n      int\n      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 5 String::compare specification questionable\n      /**\n       *  @brief  Compare substring to a C string.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  C string to compare against.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a pos.  Returns an integer < 0 if\n       *  the substring is ordered before @a __s, 0 if their values\n       *  are equivalent, or > 0 if the substring is ordered after @a\n       *  __s.  Determines the effective length rlen of the strings to\n       *  compare as the smallest of the length of the substring and\n       *  the length of a string constructed from @a __s.  The\n       *  function then compares the two string by calling\n       *  traits::compare(substring.data(),__s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n\n      /**\n       *  @brief  Compare substring against a character %array.\n       *  @param __pos  Index of first character of substring.\n       *  @param __n1  Number of characters in substring.\n       *  @param __s  character %array to compare against.\n       *  @param __n2  Number of characters of s.\n       *  @return  Integer < 0, 0, or > 0.\n       *\n       *  Form the substring of this string from the @a __n1\n       *  characters starting at @a __pos.  Form a string from the\n       *  first @a __n2 characters of @a __s.  Returns an integer < 0\n       *  if this substring is ordered before the string from @a __s,\n       *  0 if their values are equivalent, or > 0 if this substring\n       *  is ordered after the string from @a __s.  Determines the\n       *  effective length rlen of the strings to compare as the\n       *  smallest of the length of the substring and @a __n2.  The\n       *  function then compares the two strings by calling\n       *  traits::compare(substring.data(),s,rlen).  If the result of\n       *  the comparison is nonzero returns it, otherwise the shorter\n       *  one is ordered first.\n       *\n       *  NB: s must have at least n2 characters, &apos;\\\\0&apos; has\n       *  no special meaning.\n      */\n      int\n      compare(size_type __pos, size_type __n1, const _CharT* __s,\n\t      size_type __n2) const;\n\n#if __cplusplus > 201703L\n      bool\n      starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept\n      { return __sv_type(this->data(), this->size()).starts_with(__x); }\n\n      bool\n      starts_with(_CharT __x) const noexcept\n      { return __sv_type(this->data(), this->size()).starts_with(__x); }\n\n      bool\n      starts_with(const _CharT* __x) const noexcept\n      { return __sv_type(this->data(), this->size()).starts_with(__x); }\n\n      bool\n      ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept\n      { return __sv_type(this->data(), this->size()).ends_with(__x); }\n\n      bool\n      ends_with(_CharT __x) const noexcept\n      { return __sv_type(this->data(), this->size()).ends_with(__x); }\n\n      bool\n      ends_with(const _CharT* __x) const noexcept\n      { return __sv_type(this->data(), this->size()).ends_with(__x); }\n#endif // C++20\n\n#if __cplusplus > 202011L\n      bool\n      contains(basic_string_view<_CharT, _Traits> __x) const noexcept\n      { return __sv_type(this->data(), this->size()).contains(__x); }\n\n      bool\n      contains(_CharT __x) const noexcept\n      { return __sv_type(this->data(), this->size()).contains(__x); }\n\n      bool\n      contains(const _CharT* __x) const noexcept\n      { return __sv_type(this->data(), this->size()).contains(__x); }\n#endif // C++23\n\n# ifdef _GLIBCXX_TM_TS_INTERNAL\n      friend void\n      ::_txnal_cow_string_C1_for_exceptions(void* that, const char* s,\n\t\t\t\t\t    void* exc);\n      friend const char*\n      ::_txnal_cow_string_c_str(const void *that);\n      friend void\n      ::_txnal_cow_string_D1(void *that);\n      friend void\n      ::_txnal_cow_string_D1_commit(void *that);\n# endif\n  };\n#endif  // !_GLIBCXX_USE_CXX11_ABI\n\n#if __cpp_deduction_guides >= 201606\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n  template<typename _InputIterator, typename _CharT\n\t     = typename iterator_traits<_InputIterator>::value_type,\n\t   typename _Allocator = allocator<_CharT>,\n\t   typename = _RequireInputIter<_InputIterator>,\n\t   typename = _RequireAllocator<_Allocator>>\n    basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())\n      -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 3075. basic_string needs deduction guides from basic_string_view\n  template<typename _CharT, typename _Traits,\n\t   typename _Allocator = allocator<_CharT>,\n\t   typename = _RequireAllocator<_Allocator>>\n    basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())\n      -> basic_string<_CharT, _Traits, _Allocator>;\n\n  template<typename _CharT, typename _Traits,\n\t   typename _Allocator = allocator<_CharT>,\n\t   typename = _RequireAllocator<_Allocator>>\n    basic_string(basic_string_view<_CharT, _Traits>,\n\t\t typename basic_string<_CharT, _Traits, _Allocator>::size_type,\n\t\t typename basic_string<_CharT, _Traits, _Allocator>::size_type,\n\t\t const _Allocator& = _Allocator())\n      -> basic_string<_CharT, _Traits, _Allocator>;\n_GLIBCXX_END_NAMESPACE_CXX11\n#endif\n\n  // operator+\n  /**\n   *  @brief  Concatenate two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with value of @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    {\n      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n      __str.append(__rhs);\n      return __str;\n    }\n\n  /**\n   *  @brief  Concatenate C string and string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with value of @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT,_Traits,_Alloc>\n    operator+(const _CharT* __lhs,\n\t      const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n\n  /**\n   *  @brief  Concatenate character and string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT,_Traits,_Alloc>\n    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n\n  /**\n   *  @brief  Concatenate string and C string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const _CharT* __rhs)\n    {\n      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n      __str.append(__rhs);\n      return __str;\n    }\n\n  /**\n   *  @brief  Concatenate string and character.\n   *  @param __lhs  First string.\n   *  @param __rhs  Last string.\n   *  @return  New string with @a __lhs followed by @a __rhs.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n    {\n      typedef basic_string<_CharT, _Traits, _Alloc>\t__string_type;\n      typedef typename __string_type::size_type\t\t__size_type;\n      __string_type __str(__lhs);\n      __str.append(__size_type(1), __rhs);\n      return __str;\n    }\n\n#if __cplusplus >= 201103L\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return std::move(__lhs.append(__rhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, __lhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    {\n#if _GLIBCXX_USE_CXX11_ABI\n      using _Alloc_traits = allocator_traits<_Alloc>;\n      bool __use_rhs = false;\n      if _GLIBCXX17_CONSTEXPR (typename _Alloc_traits::is_always_equal{})\n\t__use_rhs = true;\n      else if (__lhs.get_allocator() == __rhs.get_allocator())\n\t__use_rhs = true;\n      if (__use_rhs)\n#endif\n\t{\n\t  const auto __size = __lhs.size() + __rhs.size();\n\t  if (__size > __lhs.capacity() && __size <= __rhs.capacity())\n\t    return std::move(__rhs.insert(0, __lhs));\n\t}\n      return std::move(__lhs.append(__rhs));\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(const _CharT* __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, __lhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(_CharT __lhs,\n\t      basic_string<_CharT, _Traits, _Alloc>&& __rhs)\n    { return std::move(__rhs.insert(0, 1, __lhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      const _CharT* __rhs)\n    { return std::move(__lhs.append(__rhs)); }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_string<_CharT, _Traits, _Alloc>\n    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,\n\t      _CharT __rhs)\n    { return std::move(__lhs.append(1, __rhs)); }\n#endif\n\n  // operator ==\n  /**\n   *  @brief  Test equivalence of two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) == 0; }\n\n  template<typename _CharT>\n    inline\n    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type\n    operator==(const basic_string<_CharT>& __lhs,\n\t       const basic_string<_CharT>& __rhs) _GLIBCXX_NOEXCEPT\n    { return (__lhs.size() == __rhs.size()\n\t      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),\n\t\t\t\t\t\t    __lhs.size())); }\n\n  /**\n   *  @brief  Test equivalence of string and C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) == 0; }\n\n#if __cpp_lib_three_way_comparison\n  /**\n   *  @brief  Three-way comparison of a string and a C string.\n   *  @param __lhs  A string.\n   *  @param __rhs  A null-terminated string.\n   *  @return  A value indicating whether `__lhs` is less than, equal to,\n   *\t       greater than, or incomparable with `__rhs`.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline auto\n    operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t\tconst basic_string<_CharT, _Traits, _Alloc>& __rhs) noexcept\n    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))\n    { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }\n\n  /**\n   *  @brief  Three-way comparison of a string and a C string.\n   *  @param __lhs  A string.\n   *  @param __rhs  A null-terminated string.\n   *  @return  A value indicating whether `__lhs` is less than, equal to,\n   *\t       greater than, or incomparable with `__rhs`.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline auto\n    operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t\tconst _CharT* __rhs) noexcept\n    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))\n    { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }\n#else\n  /**\n   *  @brief  Test equivalence of C string and string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator==(const _CharT* __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) == 0; }\n\n  // operator !=\n  /**\n   *  @brief  Test difference of two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return !(__lhs == __rhs); }\n\n  /**\n   *  @brief  Test difference of C string and string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator!=(const _CharT* __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return !(__lhs == __rhs); }\n\n  /**\n   *  @brief  Test difference of string and C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return !(__lhs == __rhs); }\n\n  // operator <\n  /**\n   *  @brief  Test if string precedes string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) < 0; }\n\n  /**\n   *  @brief  Test if string precedes C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const _CharT* __rhs)\n    { return __lhs.compare(__rhs) < 0; }\n\n  /**\n   *  @brief  Test if C string precedes string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<(const _CharT* __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) > 0; }\n\n  // operator >\n  /**\n   *  @brief  Test if string follows string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) > 0; }\n\n  /**\n   *  @brief  Test if string follows C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t      const _CharT* __rhs)\n    { return __lhs.compare(__rhs) > 0; }\n\n  /**\n   *  @brief  Test if C string follows string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>(const _CharT* __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) < 0; }\n\n  // operator <=\n  /**\n   *  @brief  Test if string doesn't follow string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) <= 0; }\n\n  /**\n   *  @brief  Test if string doesn't follow C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) <= 0; }\n\n  /**\n   *  @brief  Test if C string doesn't follow string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator<=(const _CharT* __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) >= 0; }\n\n  // operator >=\n  /**\n   *  @brief  Test if string doesn't precede string.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT\n    { return __lhs.compare(__rhs) >= 0; }\n\n  /**\n   *  @brief  Test if string doesn't precede C string.\n   *  @param __lhs  String.\n   *  @param __rhs  C string.\n   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t       const _CharT* __rhs)\n    { return __lhs.compare(__rhs) >= 0; }\n\n  /**\n   *  @brief  Test if C string doesn't precede string.\n   *  @param __lhs  C string.\n   *  @param __rhs  String.\n   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline bool\n    operator>=(const _CharT* __lhs,\n\t     const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    { return __rhs.compare(__lhs) <= 0; }\n#endif // three-way comparison\n\n  /**\n   *  @brief  Swap contents of two strings.\n   *  @param __lhs  First string.\n   *  @param __rhs  Second string.\n   *\n   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline void\n    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\t basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    _GLIBCXX_NOEXCEPT_IF(noexcept(__lhs.swap(__rhs)))\n    { __lhs.swap(__rhs); }\n\n\n  /**\n   *  @brief  Read stream into a string.\n   *  @param __is  Input stream.\n   *  @param __str  Buffer to store into.\n   *  @return  Reference to the input stream.\n   *\n   *  Stores characters from @a __is into @a __str until whitespace is\n   *  found, the end of the stream is encountered, or str.max_size()\n   *  is reached.  If is.width() is non-zero, that is the limit on the\n   *  number of characters stored into @a __str.  Any previous\n   *  contents of @a __str are erased.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is,\n\t       basic_string<_CharT, _Traits, _Alloc>& __str);\n\n  template<>\n    basic_istream<char>&\n    operator>>(basic_istream<char>& __is, basic_string<char>& __str);\n\n  /**\n   *  @brief  Write string to a stream.\n   *  @param __os  Output stream.\n   *  @param __str  String to write out.\n   *  @return  Reference to the output stream.\n   *\n   *  Output characters of @a __str into os following the same rules as for\n   *  writing a C string.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os,\n\t       const basic_string<_CharT, _Traits, _Alloc>& __str)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 586. string inserter not a formatted function\n      return __ostream_insert(__os, __str.data(), __str.size());\n    }\n\n  /**\n   *  @brief  Read a line from stream into a string.\n   *  @param __is  Input stream.\n   *  @param __str  Buffer to store into.\n   *  @param __delim  Character marking end of line.\n   *  @return  Reference to the input stream.\n   *\n   *  Stores characters from @a __is into @a __str until @a __delim is\n   *  found, the end of the stream is encountered, or str.max_size()\n   *  is reached.  Any previous contents of @a __str are erased.  If\n   *  @a __delim is encountered, it is extracted but not stored into\n   *  @a __str.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);\n\n  /**\n   *  @brief  Read a line from stream into a string.\n   *  @param __is  Input stream.\n   *  @param __str  Buffer to store into.\n   *  @return  Reference to the input stream.\n   *\n   *  Stores characters from is into @a __str until &apos;\\n&apos; is\n   *  found, the end of the stream is encountered, or str.max_size()\n   *  is reached.  Any previous contents of @a __str are erased.  If\n   *  end of line is encountered, it is extracted but not stored into\n   *  @a __str.\n   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str)\n    { return std::getline(__is, __str, __is.widen('\\n')); }\n\n#if __cplusplus >= 201103L\n  /// Read a line from an rvalue stream into a string.\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>&& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\n    { return std::getline(__is, __str, __delim); }\n\n  /// Read a line from an rvalue stream into a string.\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    inline basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>&& __is,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str)\n    { return std::getline(__is, __str); }\n#endif\n\n  template<>\n    basic_istream<char>&\n    getline(basic_istream<char>& __in, basic_string<char>& __str,\n\t    char __delim);\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  template<>\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,\n\t    wchar_t __delim);\n#endif  \n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#if __cplusplus >= 201103L\n\n#include <ext/string_conversions.h>\n#include <bits/charconv.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n_GLIBCXX_BEGIN_NAMESPACE_CXX11\n\n#if _GLIBCXX_USE_C99_STDLIB\n  // 21.4 Numeric Conversions [string.conversions].\n  inline int\n  stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa<long, int>(&std::strtol, \"stoi\", __str.c_str(),\n\t\t\t\t\t__idx, __base); }\n\n  inline long\n  stol(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtol, \"stol\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long\n  stoul(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoul, \"stoul\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline long long\n  stoll(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoll, \"stoll\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long long\n  stoull(const string& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::strtoull, \"stoull\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  // NB: strtof vs strtod.\n  inline float\n  stof(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtof, \"stof\", __str.c_str(), __idx); }\n\n  inline double\n  stod(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtod, \"stod\", __str.c_str(), __idx); }\n\n  inline long double\n  stold(const string& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::strtold, \"stold\", __str.c_str(), __idx); }\n#endif // _GLIBCXX_USE_C99_STDLIB\n\n  // DR 1261. Insufficent overloads for to_string / to_wstring\n\n  inline string\n  to_string(int __val)\n  {\n    const bool __neg = __val < 0;\n    const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;\n    const auto __len = __detail::__to_chars_len(__uval);\n    string __str(__neg + __len, '-');\n    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);\n    return __str;\n  }\n\n  inline string\n  to_string(unsigned __val)\n  {\n    string __str(__detail::__to_chars_len(__val), '\\0');\n    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);\n    return __str;\n  }\n\n  inline string\n  to_string(long __val)\n  {\n    const bool __neg = __val < 0;\n    const unsigned long __uval = __neg ? (unsigned long)~__val + 1ul : __val;\n    const auto __len = __detail::__to_chars_len(__uval);\n    string __str(__neg + __len, '-');\n    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);\n    return __str;\n  }\n\n  inline string\n  to_string(unsigned long __val)\n  {\n    string __str(__detail::__to_chars_len(__val), '\\0');\n    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);\n    return __str;\n  }\n\n  inline string\n  to_string(long long __val)\n  {\n    const bool __neg = __val < 0;\n    const unsigned long long __uval\n      = __neg ? (unsigned long long)~__val + 1ull : __val;\n    const auto __len = __detail::__to_chars_len(__uval);\n    string __str(__neg + __len, '-');\n    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);\n    return __str;\n  }\n\n  inline string\n  to_string(unsigned long long __val)\n  {\n    string __str(__detail::__to_chars_len(__val), '\\0');\n    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);\n    return __str;\n  }\n\n#if _GLIBCXX_USE_C99_STDIO\n  // NB: (v)snprintf vs sprintf.\n\n  inline string\n  to_string(float __val)\n  {\n    const int __n = \n      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n\t\t\t\t\t   \"%f\", __val);\n  }\n\n  inline string\n  to_string(double __val)\n  {\n    const int __n = \n      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n\t\t\t\t\t   \"%f\", __val);\n  }\n\n  inline string\n  to_string(long double __val)\n  {\n    const int __n = \n      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\n\t\t\t\t\t   \"%Lf\", __val);\n  }\n#endif // _GLIBCXX_USE_C99_STDIO\n\n#if defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_WCHAR\n  inline int \n  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, \"stoi\", __str.c_str(),\n\t\t\t\t\t__idx, __base); }\n\n  inline long \n  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstol, \"stol\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long\n  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoul, \"stoul\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline long long\n  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoll, \"stoll\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  inline unsigned long long\n  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)\n  { return __gnu_cxx::__stoa(&std::wcstoull, \"stoull\", __str.c_str(),\n\t\t\t     __idx, __base); }\n\n  // NB: wcstof vs wcstod.\n  inline float\n  stof(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstof, \"stof\", __str.c_str(), __idx); }\n\n  inline double\n  stod(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstod, \"stod\", __str.c_str(), __idx); }\n\n  inline long double\n  stold(const wstring& __str, size_t* __idx = 0)\n  { return __gnu_cxx::__stoa(&std::wcstold, \"stold\", __str.c_str(), __idx); }\n\n#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF\n  // DR 1261.\n  inline wstring\n  to_wstring(int __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),\n\t\t\t\t\t    L\"%d\", __val); }\n\n  inline wstring\n  to_wstring(unsigned __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(unsigned),\n\t\t\t\t\t    L\"%u\", __val); }\n\n  inline wstring\n  to_wstring(long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),\n\t\t\t\t\t    L\"%ld\", __val); }\n\n  inline wstring\n  to_wstring(unsigned long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(unsigned long),\n\t\t\t\t\t    L\"%lu\", __val); }\n\n  inline wstring\n  to_wstring(long long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(long long),\n\t\t\t\t\t    L\"%lld\", __val); }\n\n  inline wstring\n  to_wstring(unsigned long long __val)\n  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\n\t\t\t\t\t    4 * sizeof(unsigned long long),\n\t\t\t\t\t    L\"%llu\", __val); }\n\n  inline wstring\n  to_wstring(float __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n\t\t\t\t\t    L\"%f\", __val);\n  }\n\n  inline wstring\n  to_wstring(double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n\t\t\t\t\t    L\"%f\", __val);\n  }\n\n  inline wstring\n  to_wstring(long double __val)\n  {\n    const int __n =\n      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\n    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\n\t\t\t\t\t    L\"%Lf\", __val);\n  }\n#endif // _GLIBCXX_HAVE_BROKEN_VSWPRINTF\n#endif // _GLIBCXX_USE_WCHAR_T && _GLIBCXX_USE_C99_WCHAR\n\n_GLIBCXX_END_NAMESPACE_CXX11\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif /* C++11 */\n\n#if __cplusplus >= 201103L\n\n#include <bits/functional_hash.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // DR 1182.\n\n#ifndef _GLIBCXX_COMPATIBILITY_CXX0X\n  /// std::hash specialization for string.\n  template<>\n    struct hash<string>\n    : public __hash_base<size_t, string>\n    {\n      size_t\n      operator()(const string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(), __s.length()); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<string>> : std::false_type\n    { };\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n  /// std::hash specialization for wstring.\n  template<>\n    struct hash<wstring>\n    : public __hash_base<size_t, wstring>\n    {\n      size_t\n      operator()(const wstring& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(wchar_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<wstring>> : std::false_type\n    { };\n#endif\n#endif /* _GLIBCXX_COMPATIBILITY_CXX0X */\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n  /// std::hash specialization for u8string.\n  template<>\n    struct hash<u8string>\n    : public __hash_base<size_t, u8string>\n    {\n      size_t\n      operator()(const u8string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(char8_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<u8string>> : std::false_type\n    { };\n#endif\n\n  /// std::hash specialization for u16string.\n  template<>\n    struct hash<u16string>\n    : public __hash_base<size_t, u16string>\n    {\n      size_t\n      operator()(const u16string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(char16_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<u16string>> : std::false_type\n    { };\n\n  /// std::hash specialization for u32string.\n  template<>\n    struct hash<u32string>\n    : public __hash_base<size_t, u32string>\n    {\n      size_t\n      operator()(const u32string& __s) const noexcept\n      { return std::_Hash_impl::hash(__s.data(),\n                                     __s.length() * sizeof(char32_t)); }\n    };\n\n  template<>\n    struct __is_fast_hash<hash<u32string>> : std::false_type\n    { };\n\n#if __cplusplus >= 201402L\n\n#define __cpp_lib_string_udls 201304\n\n  inline namespace literals\n  {\n  inline namespace string_literals\n  {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wliteral-suffix\"\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char>\n    operator\"\"s(const char* __str, size_t __len)\n    { return basic_string<char>{__str, __len}; }\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<wchar_t>\n    operator\"\"s(const wchar_t* __str, size_t __len)\n    { return basic_string<wchar_t>{__str, __len}; }\n#endif\n\n#ifdef _GLIBCXX_USE_CHAR8_T\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char8_t>\n    operator\"\"s(const char8_t* __str, size_t __len)\n    { return basic_string<char8_t>{__str, __len}; }\n#endif\n\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char16_t>\n    operator\"\"s(const char16_t* __str, size_t __len)\n    { return basic_string<char16_t>{__str, __len}; }\n\n    _GLIBCXX_DEFAULT_ABI_TAG\n    inline basic_string<char32_t>\n    operator\"\"s(const char32_t* __str, size_t __len)\n    { return basic_string<char32_t>{__str, __len}; }\n\n#pragma GCC diagnostic pop\n  } // inline namespace string_literals\n  } // inline namespace literals\n\n#if __cplusplus >= 201703L\n  namespace __detail::__variant\n  {\n    template<typename> struct _Never_valueless_alt; // see <variant>\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // basic_string into a variant, but only if moving the string cannot throw.\n    template<typename _Tp, typename _Traits, typename _Alloc>\n      struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>\n      : __and_<\n\tis_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>,\n\tis_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>\n\t>::type\n      { };\n  }  // namespace __detail::__variant\n#endif // C++17\n#endif // C++14\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif // C++11\n\n#endif /* _BASIC_STRING_H */\n"}],"crc32":1957858842,"timestamp":1702397466,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]