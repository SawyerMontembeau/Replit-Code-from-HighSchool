[{"ops":[{"insert":"// Components for manipulating sequences of characters -*- C++ -*-\n\n// Copyright (C) 1997-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/basic_string.tcc\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{string}\n */\n\n//\n// ISO C++ 14882: 21  Strings library\n//\n\n// Written by Jason Merrill based upon the specification by Takanori Adachi\n// in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.\n// Non-reference-counted implementation written by Paolo Carlini and\n// updated by Jonathan Wakely for ISO-14882-2011.\n\n#ifndef _BASIC_STRING_TCC\n#define _BASIC_STRING_TCC 1\n\n#pragma GCC system_header\n\n#include <bits/cxxabi_forced.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if _GLIBCXX_USE_CXX11_ABI\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    const typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::npos;\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    swap(basic_string& __s) _GLIBCXX_NOEXCEPT\n    {\n      if (this == &__s)\n\treturn;\n\n      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());\n\n      if (_M_is_local())\n\tif (__s._M_is_local())\n\t  {\n\t    if (length() && __s.length())\n\t      {\n\t\t_CharT __tmp_data[_S_local_capacity + 1];\n\t\ttraits_type::copy(__tmp_data, __s._M_local_buf,\n\t\t\t\t  _S_local_capacity + 1);\n\t\ttraits_type::copy(__s._M_local_buf, _M_local_buf,\n\t\t\t\t  _S_local_capacity + 1);\n\t\ttraits_type::copy(_M_local_buf, __tmp_data,\n\t\t\t\t  _S_local_capacity + 1);\n\t      }\n\t    else if (__s.length())\n\t      {\n\t\ttraits_type::copy(_M_local_buf, __s._M_local_buf,\n\t\t\t\t  _S_local_capacity + 1);\n\t\t_M_length(__s.length());\n\t\t__s._M_set_length(0);\n\t\treturn;\n\t      }\n\t    else if (length())\n\t      {\n\t\ttraits_type::copy(__s._M_local_buf, _M_local_buf,\n\t\t\t\t  _S_local_capacity + 1);\n\t\t__s._M_length(length());\n\t\t_M_set_length(0);\n\t\treturn;\n\t      }\n\t  }\n\telse\n\t  {\n\t    const size_type __tmp_capacity = __s._M_allocated_capacity;\n\t    traits_type::copy(__s._M_local_buf, _M_local_buf,\n\t\t\t      _S_local_capacity + 1);\n\t    _M_data(__s._M_data());\n\t    __s._M_data(__s._M_local_buf);\n\t    _M_capacity(__tmp_capacity);\n\t  }\n      else\n\t{\n\t  const size_type __tmp_capacity = _M_allocated_capacity;\n\t  if (__s._M_is_local())\n\t    {\n\t      traits_type::copy(_M_local_buf, __s._M_local_buf,\n\t\t\t\t_S_local_capacity + 1);\n\t      __s._M_data(_M_data());\n\t      _M_data(_M_local_buf);\n\t    }\n\t  else\n\t    {\n\t      pointer __tmp_ptr = _M_data();\n\t      _M_data(__s._M_data());\n\t      __s._M_data(__tmp_ptr);\n\t      _M_capacity(__s._M_allocated_capacity);\n\t    }\n\t  __s._M_capacity(__tmp_capacity);\n\t}\n\n      const size_type __tmp_length = length();\n      _M_length(__s.length());\n      __s._M_length(__tmp_length);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::pointer\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_create(size_type& __capacity, size_type __old_capacity)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 83.  String::npos vs. string::max_size()\n      if (__capacity > max_size())\n\tstd::__throw_length_error(__N(\"basic_string::_M_create\"));\n\n      // The below implements an exponential growth policy, necessary to\n      // meet amortized linear time requirements of the library: see\n      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\n      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)\n\t{\n\t  __capacity = 2 * __old_capacity;\n\t  // Never allocate a string bigger than max_size.\n\t  if (__capacity > max_size())\n\t    __capacity = max_size();\n\t}\n\n      // NB: Need an array of char_type[__capacity], plus a terminating\n      // null char_type() element.\n      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);\n    }\n\n  // NB: This is the special case for Input Iterators, used in\n  // istreambuf_iterators, etc.\n  // Input Iterators have a cost structure very different from\n  // pointers, calling for a different coding style.\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    template<typename _InIterator>\n      void\n      basic_string<_CharT, _Traits, _Alloc>::\n      _M_construct(_InIterator __beg, _InIterator __end,\n\t\t   std::input_iterator_tag)\n      {\n\tsize_type __len = 0;\n\tsize_type __capacity = size_type(_S_local_capacity);\n\n\twhile (__beg != __end && __len < __capacity)\n\t  {\n\t    _M_data()[__len++] = *__beg;\n\t    ++__beg;\n\t  }\n\n\t__try\n\t  {\n\t    while (__beg != __end)\n\t      {\n\t\tif (__len == __capacity)\n\t\t  {\n\t\t    // Allocate more space.\n\t\t    __capacity = __len + 1;\n\t\t    pointer __another = _M_create(__capacity, __len);\n\t\t    this->_S_copy(__another, _M_data(), __len);\n\t\t    _M_dispose();\n\t\t    _M_data(__another);\n\t\t    _M_capacity(__capacity);\n\t\t  }\n\t\t_M_data()[__len++] = *__beg;\n\t\t++__beg;\n\t      }\n\t  }\n\t__catch(...)\n\t  {\n\t    _M_dispose();\n\t    __throw_exception_again;\n\t  }\n\n\t_M_set_length(__len);\n      }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    template<typename _InIterator>\n      void\n      basic_string<_CharT, _Traits, _Alloc>::\n      _M_construct(_InIterator __beg, _InIterator __end,\n\t\t   std::forward_iterator_tag)\n      {\n\t// NB: Not required, but considered best practice.\n\tif (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)\n\t  std::__throw_logic_error(__N(\"basic_string::\"\n\t\t\t\t       \"_M_construct null not valid\"));\n\n\tsize_type __dnew = static_cast<size_type>(std::distance(__beg, __end));\n\n\tif (__dnew > size_type(_S_local_capacity))\n\t  {\n\t    _M_data(_M_create(__dnew, size_type(0)));\n\t    _M_capacity(__dnew);\n\t  }\n\n\t// Check for out_of_range and length_error exceptions.\n\t__try\n\t  { this->_S_copy_chars(_M_data(), __beg, __end); }\n\t__catch(...)\n\t  {\n\t    _M_dispose();\n\t    __throw_exception_again;\n\t  }\n\n\t_M_set_length(__dnew);\n      }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_construct(size_type __n, _CharT __c)\n    {\n      if (__n > size_type(_S_local_capacity))\n\t{\n\t  _M_data(_M_create(__n, size_type(0)));\n\t  _M_capacity(__n);\n\t}\n\n      if (__n)\n\tthis->_S_assign(_M_data(), __n, __c);\n\n      _M_set_length(__n);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_assign(const basic_string& __str)\n    {\n      if (this != &__str)\n\t{\n\t  const size_type __rsize = __str.length();\n\t  const size_type __capacity = capacity();\n\n\t  if (__rsize > __capacity)\n\t    {\n\t      size_type __new_capacity = __rsize;\n\t      pointer __tmp = _M_create(__new_capacity, __capacity);\n\t      _M_dispose();\n\t      _M_data(__tmp);\n\t      _M_capacity(__new_capacity);\n\t    }\n\n\t  if (__rsize)\n\t    this->_S_copy(_M_data(), __str._M_data(), __rsize);\n\n\t  _M_set_length(__rsize);\n\t}\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    reserve(size_type __res)\n    {\n      const size_type __capacity = capacity();\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2968. Inconsistencies between basic_string reserve and\n      // vector/unordered_map/unordered_set reserve functions\n      // P0966 reserve should not shrink\n      if (__res <= __capacity)\n\treturn;\n\n      pointer __tmp = _M_create(__res, __capacity);\n      this->_S_copy(__tmp, _M_data(), length() + 1);\n      _M_dispose();\n      _M_data(__tmp);\n      _M_capacity(__res);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,\n\t      size_type __len2)\n    {\n      const size_type __how_much = length() - __pos - __len1;\n\n      size_type __new_capacity = length() + __len2 - __len1;\n      pointer __r = _M_create(__new_capacity, capacity());\n\n      if (__pos)\n\tthis->_S_copy(__r, _M_data(), __pos);\n      if (__s && __len2)\n\tthis->_S_copy(__r + __pos, __s, __len2);\n      if (__how_much)\n\tthis->_S_copy(__r + __pos + __len2,\n\t\t      _M_data() + __pos + __len1, __how_much);\n\n      _M_dispose();\n      _M_data(__r);\n      _M_capacity(__new_capacity);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_erase(size_type __pos, size_type __n)\n    {\n      const size_type __how_much = length() - __pos - __n;\n\n      if (__how_much && __n)\n\tthis->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);\n\n      _M_set_length(length() - __n);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    reserve()\n    {\n      if (_M_is_local())\n\treturn;\n\n      const size_type __length = length();\n      const size_type __capacity = _M_allocated_capacity;\n\n      if (__length <= size_type(_S_local_capacity))\n\t{\n\t  this->_S_copy(_M_local_data(), _M_data(), __length + 1);\n\t  _M_destroy(__capacity);\n\t  _M_data(_M_local_data());\n\t}\n#if __cpp_exceptions\n      else if (__length < __capacity)\n\ttry\n\t  {\n\t    pointer __tmp\n\t      = _Alloc_traits::allocate(_M_get_allocator(), __length + 1);\n\t    this->_S_copy(__tmp, _M_data(), __length + 1);\n\t    _M_dispose();\n\t    _M_data(__tmp);\n\t    _M_capacity(__length);\n\t  }\n\tcatch (const __cxxabiv1::__forced_unwind&)\n\t  { throw; }\n\tcatch (...)\n\t  { /* swallow the exception */ }\n#endif\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    resize(size_type __n, _CharT __c)\n    {\n      const size_type __size = this->size();\n      if (__size < __n)\n\tthis->append(__n - __size, __c);\n      else if (__n < __size)\n\tthis->_M_set_length(__n);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_append(const _CharT* __s, size_type __n)\n    {\n      const size_type __len = __n + this->size();\n\n      if (__len <= this->capacity())\n\t{\n\t  if (__n)\n\t    this->_S_copy(this->_M_data() + this->size(), __s, __n);\n\t}\n      else\n\tthis->_M_mutate(this->size(), size_type(0), __s, __n);\n\n      this->_M_set_length(__len);\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    template<typename _InputIterator>\n      basic_string<_CharT, _Traits, _Alloc>&\n      basic_string<_CharT, _Traits, _Alloc>::\n      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,\n\t\t\t  _InputIterator __k1, _InputIterator __k2,\n\t\t\t  std::__false_type)\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 2788. unintentionally require a default constructible allocator\n\tconst basic_string __s(__k1, __k2, this->get_allocator());\n\tconst size_type __n1 = __i2 - __i1;\n\treturn _M_replace(__i1 - begin(), __n1, __s._M_data(),\n\t\t\t  __s.size());\n      }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t   _CharT __c)\n    {\n      _M_check_length(__n1, __n2, \"basic_string::_M_replace_aux\");\n\n      const size_type __old_size = this->size();\n      const size_type __new_size = __old_size + __n2 - __n1;\n\n      if (__new_size <= this->capacity())\n\t{\n\t  pointer __p = this->_M_data() + __pos1;\n\n\t  const size_type __how_much = __old_size - __pos1 - __n1;\n\t  if (__how_much && __n1 != __n2)\n\t    this->_S_move(__p + __n2, __p + __n1, __how_much);\n\t}\n      else\n\tthis->_M_mutate(__pos1, __n1, 0, __n2);\n\n      if (__n2)\n\tthis->_S_assign(this->_M_data() + __pos1, __n2, __c);\n\n      this->_M_set_length(__new_size);\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,\n\t       const size_type __len2)\n    {\n      _M_check_length(__len1, __len2, \"basic_string::_M_replace\");\n\n      const size_type __old_size = this->size();\n      const size_type __new_size = __old_size + __len2 - __len1;\n\n      if (__new_size <= this->capacity())\n\t{\n\t  pointer __p = this->_M_data() + __pos;\n\n\t  const size_type __how_much = __old_size - __pos - __len1;\n\t  if (_M_disjunct(__s))\n\t    {\n\t      if (__how_much && __len1 != __len2)\n\t\tthis->_S_move(__p + __len2, __p + __len1, __how_much);\n\t      if (__len2)\n\t\tthis->_S_copy(__p, __s, __len2);\n\t    }\n\t  else\n\t    {\n\t      // Work in-place.\n\t      if (__len2 && __len2 <= __len1)\n\t\tthis->_S_move(__p, __s, __len2);\n\t      if (__how_much && __len1 != __len2)\n\t\tthis->_S_move(__p + __len2, __p + __len1, __how_much);\n\t      if (__len2 > __len1)\n\t\t{\n\t\t  if (__s + __len2 <= __p + __len1)\n\t\t    this->_S_move(__p, __s, __len2);\n\t\t  else if (__s >= __p + __len1)\n\t\t    {\n\t\t      // Hint to middle end that __p and __s overlap\n\t\t      // (PR 98465).\n\t\t      const size_type __poff = (__s - __p) + (__len2 - __len1);\n\t\t      this->_S_copy(__p, __p + __poff, __len2);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      const size_type __nleft = (__p + __len1) - __s;\n\t\t      this->_S_move(__p, __s, __nleft);\n\t\t      this->_S_copy(__p + __nleft, __p + __len2,\n\t\t\t\t    __len2 - __nleft);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\tthis->_M_mutate(__pos, __len1, __s, __len2);\n\n      this->_M_set_length(__new_size);\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    copy(_CharT* __s, size_type __n, size_type __pos) const\n    {\n      _M_check(__pos, \"basic_string::copy\");\n      __n = _M_limit(__pos, __n);\n      __glibcxx_requires_string_len(__s, __n);\n      if (__n)\n\t_S_copy(__s, _M_data() + __pos, __n);\n      // 21.3.5.7 par 3: do not append null.  (good.)\n      return __n;\n    }\n\n#else  // !_GLIBCXX_USE_CXX11_ABI\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    const typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    const _CharT\n    basic_string<_CharT, _Traits, _Alloc>::\n    _Rep::_S_terminal = _CharT();\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    const typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::npos;\n\n  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)\n  // at static init time (before static ctors are run).\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[\n    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /\n      sizeof(size_type)];\n\n  // NB: This is the special case for Input Iterators, used in\n  // istreambuf_iterators, etc.\n  // Input Iterators have a cost structure very different from\n  // pointers, calling for a different coding style.\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    template<typename _InIterator>\n      _CharT*\n      basic_string<_CharT, _Traits, _Alloc>::\n      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\n\t\t   input_iterator_tag)\n      {\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\tif (__beg == __end && __a == _Alloc())\n\t  return _S_empty_rep()._M_refdata();\n#endif\n\t// Avoid reallocation for common case.\n\t_CharT __buf[128];\n\tsize_type __len = 0;\n\twhile (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))\n\t  {\n\t    __buf[__len++] = *__beg;\n\t    ++__beg;\n\t  }\n\t_Rep* __r = _Rep::_S_create(__len, size_type(0), __a);\n\t_M_copy(__r->_M_refdata(), __buf, __len);\n\t__try\n\t  {\n\t    while (__beg != __end)\n\t      {\n\t\tif (__len == __r->_M_capacity)\n\t\t  {\n\t\t    // Allocate more space.\n\t\t    _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);\n\t\t    _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);\n\t\t    __r->_M_destroy(__a);\n\t\t    __r = __another;\n\t\t  }\n\t\t__r->_M_refdata()[__len++] = *__beg;\n\t\t++__beg;\n\t      }\n\t  }\n\t__catch(...)\n\t  {\n\t    __r->_M_destroy(__a);\n\t    __throw_exception_again;\n\t  }\n\t__r->_M_set_length_and_sharable(__len);\n\treturn __r->_M_refdata();\n      }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    template <typename _InIterator>\n      _CharT*\n      basic_string<_CharT, _Traits, _Alloc>::\n      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\n\t\t   forward_iterator_tag)\n      {\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n\tif (__beg == __end && __a == _Alloc())\n\t  return _S_empty_rep()._M_refdata();\n#endif\n\t// NB: Not required, but considered best practice.\n\tif (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)\n\t  __throw_logic_error(__N(\"basic_string::_S_construct null not valid\"));\n\n\tconst size_type __dnew = static_cast<size_type>(std::distance(__beg,\n\t\t\t\t\t\t\t\t      __end));\n\t// Check for out_of_range and length_error exceptions.\n\t_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);\n\t__try\n\t  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }\n\t__catch(...)\n\t  {\n\t    __r->_M_destroy(__a);\n\t    __throw_exception_again;\n\t  }\n\t__r->_M_set_length_and_sharable(__dnew);\n\treturn __r->_M_refdata();\n      }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    _CharT*\n    basic_string<_CharT, _Traits, _Alloc>::\n    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)\n    {\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      if (__n == 0 && __a == _Alloc())\n\treturn _S_empty_rep()._M_refdata();\n#endif\n      // Check for out_of_range and length_error exceptions.\n      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);\n      if (__n)\n\t_M_assign(__r->_M_refdata(), __n, __c);\n\n      __r->_M_set_length_and_sharable(__n);\n      return __r->_M_refdata();\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>::\n    basic_string(const basic_string& __str, size_type __pos, const _Alloc& __a)\n    : _M_dataplus(_S_construct(__str._M_data()\n\t\t\t       + __str._M_check(__pos,\n\t\t\t\t\t\t\"basic_string::basic_string\"),\n\t\t\t       __str._M_data() + __str._M_limit(__pos, npos)\n\t\t\t       + __pos, __a), __a)\n    { }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>::\n    basic_string(const basic_string& __str, size_type __pos, size_type __n)\n    : _M_dataplus(_S_construct(__str._M_data()\n\t\t\t       + __str._M_check(__pos,\n\t\t\t\t\t\t\"basic_string::basic_string\"),\n\t\t\t       __str._M_data() + __str._M_limit(__pos, __n)\n\t\t\t       + __pos, _Alloc()), _Alloc())\n    { }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>::\n    basic_string(const basic_string& __str, size_type __pos,\n\t\t size_type __n, const _Alloc& __a)\n    : _M_dataplus(_S_construct(__str._M_data()\n\t\t\t       + __str._M_check(__pos,\n\t\t\t\t\t\t\"basic_string::basic_string\"),\n\t\t\t       __str._M_data() + __str._M_limit(__pos, __n)\n\t\t\t       + __pos, __a), __a)\n    { }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    assign(const basic_string& __str)\n    {\n      if (_M_rep() != __str._M_rep())\n\t{\n\t  // XXX MT\n\t  const allocator_type __a = this->get_allocator();\n\t  _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());\n\t  _M_rep()->_M_dispose(__a);\n\t  _M_data(__tmp);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    assign(const _CharT* __s, size_type __n)\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      _M_check_length(this->size(), __n, \"basic_string::assign\");\n      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())\n\treturn _M_replace_safe(size_type(0), this->size(), __s, __n);\n      else\n\t{\n\t  // Work in-place.\n\t  const size_type __pos = __s - _M_data();\n\t  if (__pos >= __n)\n\t    _M_copy(_M_data(), __s, __n);\n\t  else if (__pos)\n\t    _M_move(_M_data(), __s, __n);\n\t  _M_rep()->_M_set_length_and_sharable(__n);\n\t  return *this;\n\t}\n     }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    append(size_type __n, _CharT __c)\n    {\n      if (__n)\n\t{\n\t  _M_check_length(size_type(0), __n, \"basic_string::append\");\t  \n\t  const size_type __len = __n + this->size();\n\t  if (__len > this->capacity() || _M_rep()->_M_is_shared())\n\t    this->reserve(__len);\n\t  _M_assign(_M_data() + this->size(), __n, __c);\n\t  _M_rep()->_M_set_length_and_sharable(__len);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    append(const _CharT* __s, size_type __n)\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      if (__n)\n\t{\n\t  _M_check_length(size_type(0), __n, \"basic_string::append\");\n\t  const size_type __len = __n + this->size();\n\t  if (__len > this->capacity() || _M_rep()->_M_is_shared())\n\t    {\n\t      if (_M_disjunct(__s))\n\t\tthis->reserve(__len);\n\t      else\n\t\t{\n\t\t  const size_type __off = __s - _M_data();\n\t\t  this->reserve(__len);\n\t\t  __s = _M_data() + __off;\n\t\t}\n\t    }\n\t  _M_copy(_M_data() + this->size(), __s, __n);\n\t  _M_rep()->_M_set_length_and_sharable(__len);\n\t}\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    append(const basic_string& __str)\n    {\n      const size_type __size = __str.size();\n      if (__size)\n\t{\n\t  const size_type __len = __size + this->size();\n\t  if (__len > this->capacity() || _M_rep()->_M_is_shared())\n\t    this->reserve(__len);\n\t  _M_copy(_M_data() + this->size(), __str._M_data(), __size);\n\t  _M_rep()->_M_set_length_and_sharable(__len);\n\t}\n      return *this;\n    }    \n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    append(const basic_string& __str, size_type __pos, size_type __n)\n    {\n      __str._M_check(__pos, \"basic_string::append\");\n      __n = __str._M_limit(__pos, __n);\n      if (__n)\n\t{\n\t  const size_type __len = __n + this->size();\n\t  if (__len > this->capacity() || _M_rep()->_M_is_shared())\n\t    this->reserve(__len);\n\t  _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);\n\t  _M_rep()->_M_set_length_and_sharable(__len);\t  \n\t}\n      return *this;\n    }\n\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT, _Traits, _Alloc>&\n     basic_string<_CharT, _Traits, _Alloc>::\n     insert(size_type __pos, const _CharT* __s, size_type __n)\n     {\n       __glibcxx_requires_string_len(__s, __n);\n       _M_check(__pos, \"basic_string::insert\");\n       _M_check_length(size_type(0), __n, \"basic_string::insert\");\n       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())\n         return _M_replace_safe(__pos, size_type(0), __s, __n);\n       else\n         {\n           // Work in-place.\n           const size_type __off = __s - _M_data();\n           _M_mutate(__pos, 0, __n);\n           __s = _M_data() + __off;\n           _CharT* __p = _M_data() + __pos;\n           if (__s  + __n <= __p)\n             _M_copy(__p, __s, __n);\n           else if (__s >= __p)\n             _M_copy(__p, __s + __n, __n);\n           else\n             {\n\t       const size_type __nleft = __p - __s;\n               _M_copy(__p, __s, __nleft);\n               _M_copy(__p + __nleft, __p + __n, __n - __nleft);\n             }\n           return *this;\n         }\n     }\n\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     typename basic_string<_CharT, _Traits, _Alloc>::iterator\n     basic_string<_CharT, _Traits, _Alloc>::\n     erase(iterator __first, iterator __last)\n     {\n       _GLIBCXX_DEBUG_PEDASSERT(__first >= _M_ibegin() && __first <= __last\n\t\t\t\t&& __last <= _M_iend());\n\n       // NB: This isn't just an optimization (bail out early when\n       // there is nothing to do, really), it's also a correctness\n       // issue vs MT, see libstdc++/40518.\n       const size_type __size = __last - __first;\n       if (__size)\n\t {\n\t   const size_type __pos = __first - _M_ibegin();\n\t   _M_mutate(__pos, __size, size_type(0));\n\t   _M_rep()->_M_set_leaked();\n\t   return iterator(_M_data() + __pos);\n\t }\n       else\n\t return __first;\n     }\n\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT, _Traits, _Alloc>&\n     basic_string<_CharT, _Traits, _Alloc>::\n     replace(size_type __pos, size_type __n1, const _CharT* __s,\n\t     size_type __n2)\n     {\n       __glibcxx_requires_string_len(__s, __n2);\n       _M_check(__pos, \"basic_string::replace\");\n       __n1 = _M_limit(__pos, __n1);\n       _M_check_length(__n1, __n2, \"basic_string::replace\");\n       bool __left;\n       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())\n         return _M_replace_safe(__pos, __n1, __s, __n2);\n       else if ((__left = __s + __n2 <= _M_data() + __pos)\n\t\t|| _M_data() + __pos + __n1 <= __s)\n\t {\n\t   // Work in-place: non-overlapping case.\n\t   size_type __off = __s - _M_data();\n\t   __left ? __off : (__off += __n2 - __n1);\n\t   _M_mutate(__pos, __n1, __n2);\n\t   _M_copy(_M_data() + __pos, _M_data() + __off, __n2);\n\t   return *this;\n\t }\n       else\n\t {\n\t   // Todo: overlapping case.\n\t   const basic_string __tmp(__s, __n2);\n\t   return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);\n\t }\n     }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::_Rep::\n    _M_destroy(const _Alloc& __a) throw ()\n    {\n      const size_type __size = sizeof(_Rep_base) +\n\t                       (this->_M_capacity + 1) * sizeof(_CharT);\n      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_leak_hard()\n    {\n#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n      if (_M_rep() == &_S_empty_rep())\n\treturn;\n#endif\n      if (_M_rep()->_M_is_shared())\n\t_M_mutate(0, 0, 0);\n      _M_rep()->_M_set_leaked();\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_mutate(size_type __pos, size_type __len1, size_type __len2)\n    {\n      const size_type __old_size = this->size();\n      const size_type __new_size = __old_size + __len2 - __len1;\n      const size_type __how_much = __old_size - __pos - __len1;\n\n      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())\n\t{\n\t  // Must reallocate.\n\t  const allocator_type __a = get_allocator();\n\t  _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);\n\n\t  if (__pos)\n\t    _M_copy(__r->_M_refdata(), _M_data(), __pos);\n\t  if (__how_much)\n\t    _M_copy(__r->_M_refdata() + __pos + __len2,\n\t\t    _M_data() + __pos + __len1, __how_much);\n\n\t  _M_rep()->_M_dispose(__a);\n\t  _M_data(__r->_M_refdata());\n\t}\n      else if (__how_much && __len1 != __len2)\n\t{\n\t  // Work in-place.\n\t  _M_move(_M_data() + __pos + __len2,\n\t\t  _M_data() + __pos + __len1, __how_much);\n\t}\n      _M_rep()->_M_set_length_and_sharable(__new_size);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    reserve(size_type __res)\n    {\n      const size_type __capacity = capacity();\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2968. Inconsistencies between basic_string reserve and\n      // vector/unordered_map/unordered_set reserve functions\n      // P0966 reserve should not shrink\n      if (__res <= __capacity)\n\t{\n\t  if (!_M_rep()->_M_is_shared())\n\t    return;\n\n\t  // unshare, but keep same capacity\n\t  __res = __capacity;\n\t}\n\n      const allocator_type __a = get_allocator();\n      _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());\n      _M_rep()->_M_dispose(__a);\n      _M_data(__tmp);\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    swap(basic_string& __s)\n    _GLIBCXX_NOEXCEPT_IF(allocator_traits<_Alloc>::is_always_equal::value)\n    {\n      if (_M_rep()->_M_is_leaked())\n\t_M_rep()->_M_set_sharable();\n      if (__s._M_rep()->_M_is_leaked())\n\t__s._M_rep()->_M_set_sharable();\n      if (this->get_allocator() == __s.get_allocator())\n\t{\n\t  _CharT* __tmp = _M_data();\n\t  _M_data(__s._M_data());\n\t  __s._M_data(__tmp);\n\t}\n      // The code below can usually be optimized away.\n      else\n\t{\n\t  const basic_string __tmp1(_M_ibegin(), _M_iend(),\n\t\t\t\t    __s.get_allocator());\n\t  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),\n\t\t\t\t    this->get_allocator());\n\t  *this = __tmp2;\n\t  __s = __tmp1;\n\t}\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*\n    basic_string<_CharT, _Traits, _Alloc>::_Rep::\n    _S_create(size_type __capacity, size_type __old_capacity,\n\t      const _Alloc& __alloc)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 83.  String::npos vs. string::max_size()\n      if (__capacity > _S_max_size)\n\t__throw_length_error(__N(\"basic_string::_S_create\"));\n\n      // The standard places no restriction on allocating more memory\n      // than is strictly needed within this layer at the moment or as\n      // requested by an explicit application call to reserve(n).\n\n      // Many malloc implementations perform quite poorly when an\n      // application attempts to allocate memory in a stepwise fashion\n      // growing each allocation size by only 1 char.  Additionally,\n      // it makes little sense to allocate less linear memory than the\n      // natural blocking size of the malloc implementation.\n      // Unfortunately, we would need a somewhat low-level calculation\n      // with tuned parameters to get this perfect for any particular\n      // malloc implementation.  Fortunately, generalizations about\n      // common features seen among implementations seems to suffice.\n\n      // __pagesize need not match the actual VM page size for good\n      // results in practice, thus we pick a common value on the low\n      // side.  __malloc_header_size is an estimate of the amount of\n      // overhead per memory allocation (in practice seen N * sizeof\n      // (void*) where N is 0, 2 or 4).  According to folklore,\n      // picking this value on the high side is better than\n      // low-balling it (especially when this algorithm is used with\n      // malloc implementations that allocate memory blocks rounded up\n      // to a size which is a power of 2).\n      const size_type __pagesize = 4096;\n      const size_type __malloc_header_size = 4 * sizeof(void*);\n\n      // The below implements an exponential growth policy, necessary to\n      // meet amortized linear time requirements of the library: see\n      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\n      // It's active for allocations requiring an amount of memory above\n      // system pagesize. This is consistent with the requirements of the\n      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html\n      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)\n\t__capacity = 2 * __old_capacity;\n\n      // NB: Need an array of char_type[__capacity], plus a terminating\n      // null char_type() element, plus enough for the _Rep data structure.\n      // Whew. Seemingly so needy, yet so elemental.\n      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n\n      const size_type __adj_size = __size + __malloc_header_size;\n      if (__adj_size > __pagesize && __capacity > __old_capacity)\n\t{\n\t  const size_type __extra = __pagesize - __adj_size % __pagesize;\n\t  __capacity += __extra / sizeof(_CharT);\n\t  // Never allocate a string bigger than _S_max_size.\n\t  if (__capacity > _S_max_size)\n\t    __capacity = _S_max_size;\n\t  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n\t}\n\n      // NB: Might throw, but no worries about a leak, mate: _Rep()\n      // does not throw.\n      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);\n      _Rep *__p = new (__place) _Rep;\n      __p->_M_capacity = __capacity;\n      // ABI compatibility - 3.4.x set in _S_create both\n      // _M_refcount and _M_length.  All callers of _S_create\n      // in basic_string.tcc then set just _M_length.\n      // In 4.0.x and later both _M_refcount and _M_length\n      // are initialized in the callers, unfortunately we can\n      // have 3.4.x compiled code with _S_create callers inlined\n      // calling 4.0.x+ _S_create.\n      __p->_M_set_sharable();\n      return __p;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    _CharT*\n    basic_string<_CharT, _Traits, _Alloc>::_Rep::\n    _M_clone(const _Alloc& __alloc, size_type __res)\n    {\n      // Requested capacity of the clone.\n      const size_type __requested_cap = this->_M_length + __res;\n      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,\n\t\t\t\t  __alloc);\n      if (this->_M_length)\n\t_M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);\n\n      __r->_M_set_length_and_sharable(this->_M_length);\n      return __r->_M_refdata();\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    resize(size_type __n, _CharT __c)\n    {\n      const size_type __size = this->size();\n      _M_check_length(__size, __n, \"basic_string::resize\");\n      if (__size < __n)\n\tthis->append(__n - __size, __c);\n      else if (__n < __size)\n\tthis->erase(__n);\n      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    template<typename _InputIterator>\n      basic_string<_CharT, _Traits, _Alloc>&\n      basic_string<_CharT, _Traits, _Alloc>::\n      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\n\t\t\t  _InputIterator __k2, __false_type)\n      {\n\tconst basic_string __s(__k1, __k2);\n\tconst size_type __n1 = __i2 - __i1;\n\t_M_check_length(__n1, __s.size(), \"basic_string::_M_replace_dispatch\");\n\treturn _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),\n\t\t\t       __s.size());\n      }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\n\t\t   _CharT __c)\n    {\n      _M_check_length(__n1, __n2, \"basic_string::_M_replace_aux\");\n      _M_mutate(__pos1, __n1, __n2);\n      if (__n2)\n\t_M_assign(_M_data() + __pos1, __n2, __c);\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>&\n    basic_string<_CharT, _Traits, _Alloc>::\n    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,\n\t\t    size_type __n2)\n    {\n      _M_mutate(__pos1, __n1, __n2);\n      if (__n2)\n\t_M_copy(_M_data() + __pos1, __s, __n2);\n      return *this;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    void\n    basic_string<_CharT, _Traits, _Alloc>::\n    reserve()\n    {\n#if __cpp_exceptions\n      if (length() < capacity() || _M_rep()->_M_is_shared())\n\ttry\n\t  {\n\t    const allocator_type __a = get_allocator();\n\t    _CharT* __tmp = _M_rep()->_M_clone(__a);\n\t    _M_rep()->_M_dispose(__a);\n\t    _M_data(__tmp);\n\t  }\n\tcatch (const __cxxabiv1::__forced_unwind&)\n\t  { throw; }\n\tcatch (...)\n\t  { /* swallow the exception */ }\n#endif\n    }\n\n    template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    copy(_CharT* __s, size_type __n, size_type __pos) const\n    {\n      _M_check(__pos, \"basic_string::copy\");\n      __n = _M_limit(__pos, __n);\n      __glibcxx_requires_string_len(__s, __n);\n      if (__n)\n\t_M_copy(__s, _M_data() + __pos, __n);\n      // 21.3.5.7 par 3: do not append null.  (good.)\n      return __n;\n    }\n#endif  // !_GLIBCXX_USE_CXX11_ABI\n   \n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>\n    operator+(const _CharT* __lhs,\n\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    {\n      __glibcxx_requires_string(__lhs);\n      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;\n      typedef typename __string_type::size_type\t  __size_type;\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n\trebind<_CharT>::other _Char_alloc_type;\n      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;\n      const __size_type __len = _Traits::length(__lhs);\n      __string_type __str(_Alloc_traits::_S_select_on_copy(\n          __rhs.get_allocator()));\n      __str.reserve(__len + __rhs.size());\n      __str.append(__lhs, __len);\n      __str.append(__rhs);\n      return __str;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_string<_CharT, _Traits, _Alloc>\n    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n    {\n      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;\n      typedef typename __string_type::size_type\t  __size_type;\n      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n\trebind<_CharT>::other _Char_alloc_type;\n      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;\n      __string_type __str(_Alloc_traits::_S_select_on_copy(\n          __rhs.get_allocator()));\n      const __size_type __len = __rhs.size();\n      __str.reserve(__len + 1);\n      __str.append(__size_type(1), __lhs);\n      __str.append(__rhs);\n      return __str;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find(const _CharT* __s, size_type __pos, size_type __n) const\n    _GLIBCXX_NOEXCEPT\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      const size_type __size = this->size();\n\n      if (__n == 0)\n\treturn __pos <= __size ? __pos : npos;\n      if (__pos >= __size)\n\treturn npos;\n\n      const _CharT __elem0 = __s[0];\n      const _CharT* const __data = data();\n      const _CharT* __first = __data + __pos;\n      const _CharT* const __last = __data + __size;\n      size_type __len = __size - __pos;\n\n      while (__len >= __n)\n\t{\n\t  // Find the first occurrence of __elem0:\n\t  __first = traits_type::find(__first, __len - __n + 1, __elem0);\n\t  if (!__first)\n\t    return npos;\n\t  // Compare the full strings from the first occurrence of __elem0.\n\t  // We already know that __first[0] == __s[0] but compare them again\n\t  // anyway because __s is probably aligned, which helps memcmp.\n\t  if (traits_type::compare(__first, __s, __n) == 0)\n\t    return __first - __data;\n\t  __len = __last - ++__first;\n\t}\n      return npos;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT\n    {\n      size_type __ret = npos;\n      const size_type __size = this->size();\n      if (__pos < __size)\n\t{\n\t  const _CharT* __data = _M_data();\n\t  const size_type __n = __size - __pos;\n\t  const _CharT* __p = traits_type::find(__data + __pos, __n, __c);\n\t  if (__p)\n\t    __ret = __p - __data;\n\t}\n      return __ret;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    rfind(const _CharT* __s, size_type __pos, size_type __n) const\n    _GLIBCXX_NOEXCEPT\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      const size_type __size = this->size();\n      if (__n <= __size)\n\t{\n\t  __pos = std::min(size_type(__size - __n), __pos);\n\t  const _CharT* __data = _M_data();\n\t  do\n\t    {\n\t      if (traits_type::compare(__data + __pos, __s, __n) == 0)\n\t\treturn __pos;\n\t    }\n\t  while (__pos-- > 0);\n\t}\n      return npos;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    rfind(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT\n    {\n      size_type __size = this->size();\n      if (__size)\n\t{\n\t  if (--__size > __pos)\n\t    __size = __pos;\n\t  for (++__size; __size-- > 0; )\n\t    if (traits_type::eq(_M_data()[__size], __c))\n\t      return __size;\n\t}\n      return npos;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n    _GLIBCXX_NOEXCEPT\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      for (; __n && __pos < this->size(); ++__pos)\n\t{\n\t  const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);\n\t  if (__p)\n\t    return __pos;\n\t}\n      return npos;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n    _GLIBCXX_NOEXCEPT\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      size_type __size = this->size();\n      if (__size && __n)\n\t{\n\t  if (--__size > __pos)\n\t    __size = __pos;\n\t  do\n\t    {\n\t      if (traits_type::find(__s, __n, _M_data()[__size]))\n\t\treturn __size;\n\t    }\n\t  while (__size-- != 0);\n\t}\n      return npos;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n    _GLIBCXX_NOEXCEPT\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      for (; __pos < this->size(); ++__pos)\n\tif (!traits_type::find(__s, __n, _M_data()[__pos]))\n\t  return __pos;\n      return npos;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_first_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT\n    {\n      for (; __pos < this->size(); ++__pos)\n\tif (!traits_type::eq(_M_data()[__pos], __c))\n\t  return __pos;\n      return npos;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n    _GLIBCXX_NOEXCEPT\n    {\n      __glibcxx_requires_string_len(__s, __n);\n      size_type __size = this->size();\n      if (__size)\n\t{\n\t  if (--__size > __pos)\n\t    __size = __pos;\n\t  do\n\t    {\n\t      if (!traits_type::find(__s, __n, _M_data()[__size]))\n\t\treturn __size;\n\t    }\n\t  while (__size--);\n\t}\n      return npos;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    typename basic_string<_CharT, _Traits, _Alloc>::size_type\n    basic_string<_CharT, _Traits, _Alloc>::\n    find_last_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT\n    {\n      size_type __size = this->size();\n      if (__size)\n\t{\n\t  if (--__size > __pos)\n\t    __size = __pos;\n\t  do\n\t    {\n\t      if (!traits_type::eq(_M_data()[__size], __c))\n\t\treturn __size;\n\t    }\n\t  while (__size--);\n\t}\n      return npos;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    int\n    basic_string<_CharT, _Traits, _Alloc>::\n    compare(size_type __pos, size_type __n, const basic_string& __str) const\n    {\n      _M_check(__pos, \"basic_string::compare\");\n      __n = _M_limit(__pos, __n);\n      const size_type __osize = __str.size();\n      const size_type __len = std::min(__n, __osize);\n      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);\n      if (!__r)\n\t__r = _S_compare(__n, __osize);\n      return __r;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    int\n    basic_string<_CharT, _Traits, _Alloc>::\n    compare(size_type __pos1, size_type __n1, const basic_string& __str,\n\t    size_type __pos2, size_type __n2) const\n    {\n      _M_check(__pos1, \"basic_string::compare\");\n      __str._M_check(__pos2, \"basic_string::compare\");\n      __n1 = _M_limit(__pos1, __n1);\n      __n2 = __str._M_limit(__pos2, __n2);\n      const size_type __len = std::min(__n1, __n2);\n      int __r = traits_type::compare(_M_data() + __pos1,\n\t\t\t\t     __str.data() + __pos2, __len);\n      if (!__r)\n\t__r = _S_compare(__n1, __n2);\n      return __r;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    int\n    basic_string<_CharT, _Traits, _Alloc>::\n    compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT\n    {\n      __glibcxx_requires_string(__s);\n      const size_type __size = this->size();\n      const size_type __osize = traits_type::length(__s);\n      const size_type __len = std::min(__size, __osize);\n      int __r = traits_type::compare(_M_data(), __s, __len);\n      if (!__r)\n\t__r = _S_compare(__size, __osize);\n      return __r;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    int\n    basic_string <_CharT, _Traits, _Alloc>::\n    compare(size_type __pos, size_type __n1, const _CharT* __s) const\n    {\n      __glibcxx_requires_string(__s);\n      _M_check(__pos, \"basic_string::compare\");\n      __n1 = _M_limit(__pos, __n1);\n      const size_type __osize = traits_type::length(__s);\n      const size_type __len = std::min(__n1, __osize);\n      int __r = traits_type::compare(_M_data() + __pos, __s, __len);\n      if (!__r)\n\t__r = _S_compare(__n1, __osize);\n      return __r;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    int\n    basic_string <_CharT, _Traits, _Alloc>::\n    compare(size_type __pos, size_type __n1, const _CharT* __s,\n\t    size_type __n2) const\n    {\n      __glibcxx_requires_string_len(__s, __n2);\n      _M_check(__pos, \"basic_string::compare\");\n      __n1 = _M_limit(__pos, __n1);\n      const size_type __len = std::min(__n1, __n2);\n      int __r = traits_type::compare(_M_data() + __pos, __s, __len);\n      if (!__r)\n\t__r = _S_compare(__n1, __n2);\n      return __r;\n    }\n\n  // 21.3.7.9 basic_string::getline and operators\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __in,\n\t       basic_string<_CharT, _Traits, _Alloc>& __str)\n    {\n      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n      typedef basic_string<_CharT, _Traits, _Alloc>\t__string_type;\n      typedef typename __istream_type::ios_base         __ios_base;\n      typedef typename __istream_type::int_type\t\t__int_type;\n      typedef typename __string_type::size_type\t\t__size_type;\n      typedef ctype<_CharT>\t\t\t\t__ctype_type;\n      typedef typename __ctype_type::ctype_base         __ctype_base;\n\n      __size_type __extracted = 0;\n      typename __ios_base::iostate __err = __ios_base::goodbit;\n      typename __istream_type::sentry __cerb(__in, false);\n      if (__cerb)\n\t{\n\t  __try\n\t    {\n\t      // Avoid reallocation for common case.\n\t      __str.erase();\n\t      _CharT __buf[128];\n\t      __size_type __len = 0;\t      \n\t      const streamsize __w = __in.width();\n\t      const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)\n\t\t                              : __str.max_size();\n\t      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());\n\t      const __int_type __eof = _Traits::eof();\n\t      __int_type __c = __in.rdbuf()->sgetc();\n\n\t      while (__extracted < __n\n\t\t     && !_Traits::eq_int_type(__c, __eof)\n\t\t     && !__ct.is(__ctype_base::space,\n\t\t\t\t _Traits::to_char_type(__c)))\n\t\t{\n\t\t  if (__len == sizeof(__buf) / sizeof(_CharT))\n\t\t    {\n\t\t      __str.append(__buf, sizeof(__buf) / sizeof(_CharT));\n\t\t      __len = 0;\n\t\t    }\n\t\t  __buf[__len++] = _Traits::to_char_type(__c);\n\t\t  ++__extracted;\n\t\t  __c = __in.rdbuf()->snextc();\n\t\t}\n\t      __str.append(__buf, __len);\n\n\t      if (__extracted < __n && _Traits::eq_int_type(__c, __eof))\n\t\t__err |= __ios_base::eofbit;\n\t      __in.width(0);\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      __in._M_setstate(__ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    {\n\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t      // 91. Description of operator>> and getline() for string<>\n\t      // might cause endless loop\n\t      __in._M_setstate(__ios_base::badbit);\n\t    }\n\t}\n      // 211.  operator>>(istream&, string&) doesn't set failbit\n      if (!__extracted)\n\t__err |= __ios_base::failbit;\n      if (__err)\n\t__in.setstate(__err);\n      return __in;\n    }\n\n  template<typename _CharT, typename _Traits, typename _Alloc>\n    basic_istream<_CharT, _Traits>&\n    getline(basic_istream<_CharT, _Traits>& __in,\n\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\n    {\n      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n      typedef basic_string<_CharT, _Traits, _Alloc>\t__string_type;\n      typedef typename __istream_type::ios_base         __ios_base;\n      typedef typename __istream_type::int_type\t\t__int_type;\n      typedef typename __string_type::size_type\t\t__size_type;\n\n      __size_type __extracted = 0;\n      const __size_type __n = __str.max_size();\n      typename __ios_base::iostate __err = __ios_base::goodbit;\n      typename __istream_type::sentry __cerb(__in, true);\n      if (__cerb)\n\t{\n\t  __try\n\t    {\n\t      __str.erase();\n\t      const __int_type __idelim = _Traits::to_int_type(__delim);\n\t      const __int_type __eof = _Traits::eof();\n\t      __int_type __c = __in.rdbuf()->sgetc();\n\n\t      while (__extracted < __n\n\t\t     && !_Traits::eq_int_type(__c, __eof)\n\t\t     && !_Traits::eq_int_type(__c, __idelim))\n\t\t{\n\t\t  __str += _Traits::to_char_type(__c);\n\t\t  ++__extracted;\n\t\t  __c = __in.rdbuf()->snextc();\n\t\t}\n\n\t      if (_Traits::eq_int_type(__c, __eof))\n\t\t__err |= __ios_base::eofbit;\n\t      else if (_Traits::eq_int_type(__c, __idelim))\n\t\t{\n\t\t  ++__extracted;\t\t  \n\t\t  __in.rdbuf()->sbumpc();\n\t\t}\n\t      else\n\t\t__err |= __ios_base::failbit;\n\t    }\n\t  __catch(__cxxabiv1::__forced_unwind&)\n\t    {\n\t      __in._M_setstate(__ios_base::badbit);\n\t      __throw_exception_again;\n\t    }\n\t  __catch(...)\n\t    {\n\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t      // 91. Description of operator>> and getline() for string<>\n\t      // might cause endless loop\n\t      __in._M_setstate(__ios_base::badbit);\n\t    }\n\t}\n      if (!__extracted)\n\t__err |= __ios_base::failbit;\n      if (__err)\n\t__in.setstate(__err);\n      return __in;\n    }\n\n  // Inhibit implicit instantiations for required instantiations,\n  // which are defined via explicit instantiations elsewhere.\n#if _GLIBCXX_EXTERN_TEMPLATE\n  // The explicit instantiation definitions in src/c++11/string-inst.cc and\n  // src/c++17/string-inst.cc only instantiate the members required for C++17\n  // and earlier standards (so not C++20's starts_with and ends_with).\n  // Suppress the explicit instantiation declarations for C++20, so C++20\n  // code will implicitly instantiate std::string and std::wstring as needed.\n# if __cplusplus <= 201703L && _GLIBCXX_EXTERN_TEMPLATE > 0\n  extern template class basic_string<char>;\n# elif ! _GLIBCXX_USE_CXX11_ABI\n  // Still need to prevent implicit instantiation of the COW empty rep,\n  // to ensure the definition in libstdc++.so is unique (PR 86138).\n  extern template basic_string<char>::size_type\n    basic_string<char>::_Rep::_S_empty_rep_storage[];\n# endif\n\n  extern template\n    basic_istream<char>&\n    operator>>(basic_istream<char>&, string&);\n  extern template\n    basic_ostream<char>&\n    operator<<(basic_ostream<char>&, const string&);\n  extern template\n    basic_istream<char>&\n    getline(basic_istream<char>&, string&, char);\n  extern template\n    basic_istream<char>&\n    getline(basic_istream<char>&, string&);\n\n#ifdef _GLIBCXX_USE_WCHAR_T\n# if __cplusplus <= 201703L && _GLIBCXX_EXTERN_TEMPLATE > 0\n  extern template class basic_string<wchar_t>;\n# elif ! _GLIBCXX_USE_CXX11_ABI\n  extern template basic_string<wchar_t>::size_type\n    basic_string<wchar_t>::_Rep::_S_empty_rep_storage[];\n# endif\n\n  extern template\n    basic_istream<wchar_t>&\n    operator>>(basic_istream<wchar_t>&, wstring&);\n  extern template\n    basic_ostream<wchar_t>&\n    operator<<(basic_ostream<wchar_t>&, const wstring&);\n  extern template\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>&, wstring&, wchar_t);\n  extern template\n    basic_istream<wchar_t>&\n    getline(basic_istream<wchar_t>&, wstring&);\n#endif // _GLIBCXX_USE_WCHAR_T\n#endif // _GLIBCXX_EXTERN_TEMPLATE\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif\n"}],"crc32":183025863,"timestamp":1702397466,"tsString":"2024-01-02 16:52:28.0 +00:00:00","version":1}]